{"pages":[{"title":"","text":"һ����˼�����ũ","link":"/about/index.html"}],"posts":[{"title":"Android刘海屏适配","text":"刘海屏和水滴屏的手机目前市场上还是挺多的，所以如果有必要的话，我们开发者还是需要去适配一下。 那什么情况下我们需要去适配这个刘海屏呢？ 如果App使用了沉浸式的状态栏，或者透明状态栏，我们自己的布局延伸到了状态栏内部，这时候如果我们在刘海处有一个可交互的控件就会被遮挡 使用了全面屏的页面，比如APP的闪屏界面，图片查看大图的页面，这时候状态栏不可见，刘海会遮挡一部分地方。 如果没有上面两种情况，可以不去适配刘海屏。Android从9.0开始加入刘海屏适配的API，9.0之前的刘海屏手机想要适配就得去各个厂商的官网去找适配的代码了。 Anroid9.0官方适配的原则 如果不是全屏模式（有状态栏）则不受刘海屏的影响。因为刘海屏的高度一般就是状态栏的高度 对于全屏显示的界面，如果没有适配刘海屏，系统会有一个默认的下移处理来避开刘海屏，竖屏向下移动，横屏想右移动。 想要真正的全屏显示，需要通过Android9.0提供的API进行适配处理。 所以说，如果遇到》=9.0的Android刘海屏手机，如果没有适配刘海，我们设置的全屏的界面默认不是全屏的，会避开刘海区域。 那如果设置了全屏或者沉浸栏，如何让内容延伸进状态栏呢，需要调用几个新的API,下面的API只有targetSdkVersion 28以上才能找到，先判断是否有刘海 123456789101112131415161718/** * 判断是否有刘海 */@TargetApi(28)private fun hasDisplayCutout(window: Window): Boolean { val displayCutout: DisplayCutout? val rootView = window.decorView val insets = rootView.rootWindowInsets if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P &amp;&amp; insets != null) { displayCutout = insets.displayCutout if (displayCutout != null) { if (displayCutout.boundingRects != null &amp;&amp; displayCutout.boundingRects.size &gt; 0 &amp;&amp; displayCutout.safeInsetTop &gt; 0) { return true } } } return false} 然后允许内容延伸进刘海区域其实也就是状态栏1234567891011if(hasDisplayCutout(window)){ //2.让内容区域延伸进刘海 val params = window.attributes /** * * @see #LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT 全屏模式，内容下移，非全屏不受影响 * * @see #LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 允许内容去延伸进刘海区 * * @see #LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 不允许内容延伸进刘海区 */ params.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES window.attributes = params } OK 内容延伸到状态栏中了，如果我们界面顶部有一个可交互的控件，比如很多APP在顶部设置一个全局的搜索框，这就会被刘海遮盖住了。解决方法很简单 1.设计的时候避开这个区域 2.给该控件一个顶部的margin值或者给它的父控件一个padding值，这个值可以直接拿状态栏的高度1234567891011121314151617181920212223242526 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //1.设置全屏 requestWindowFeature(Window.FEATURE_NO_TITLE) val window = window window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN) setContentView(R.layout.activity_bang) root_view.setPadding(0,getStatusBarHeight(this),0,0) }/** * 获取状态栏高度 * * @param context * @return */ fun getStatusBarHeight(context: Context): Int { var statusBarHeight = 0 val resourceId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\") if (resourceId &gt; 0) { statusBarHeight = context.getResources().getDimensionPixelSize(resourceId) } return statusBarHeight } 3.在布局文件的根布局加一个属性android:fitsSystemWindows=”true”，就会自动往下移动 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout android:id=\"@+id/root_view\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@mipmap/loading\" android:fitsSystemWindows=\"true\" &gt; &lt;EditText android:layout_width=\"200dp\" android:layout_height=\"40dp\" android:layout_centerHorizontal=\"true\" android:text=\"请输入\" android:background=\"@drawable/selector_button\" /&gt;&lt;/RelativeLayout&gt; 对于国内的一些手机厂商的适配，8.0,9.0的手机都有，需要去其官网看看其文档，然后根据不同的机型调用不同厂商的API。 优先使用厂商的API，即使是9.0的手机，厂商没有对应API的时候在使用谷歌提供的9.0以上的适配方式 判断是那个厂商使用可以使用布兰柯基大佬的util 华为:https://devcenter.huawei.com/consumer/cn/devservice/doc/50114 小米:https://dev.mi.com/console/doc/detail?pId=1293 Oppo:https://open.oppomobile.com/service/message/detail?id=61876 Vivo:https://dev.vivo.com.cn/documentCenter/doc/103","link":"/2019/04/05/technology/Android刘海屏适配/"},{"title":"Canvas和属性动画实现好看的效果","text":"旋转，聚合，水波纹 最终效果如下图 实现步骤： 绘制6个小圆圈，小圆圈是围绕着一个大圆平均绘制的，我们可以计算大圆的总弧度，然后除以小圆的个数，就能得到每个小圆之间间隔的弧度。然后循环绘制12345678910111213private void drawSmallCircle(Canvas canvas) { canvas.drawColor(Color.WHITE); //一个完整的圆的弧度是2π，计算每个小圆之间的弧度 float angleEach = (float) (2*Math.PI/mCircleColors.length); //循环绘制6个小圆 for (int i = 0; i &lt; mCircleColors.length; i++) { float angle = i*angleEach+mCurrentAngle; float x = (float) (Math.cos(angle)*mRotateRadius+mCenterX); float y = (float) (Math.sin(angle)*mRotateRadius+mCenterY); mPaint.setColor(mCircleColors[i]); canvas.drawCircle(x,y,mCircleRadius,mPaint); } } 小圆的的原点的坐标可以看下图，根据我们中学数学中所讲，x=sin(角度)大圆的半径，y=cos(角度)大圆的半径。最后在加上大圆的原点坐标，就是上面代码上中的计算方法了。 让着些小圆转起来，那就需要通过属性动画了，通过属性动画，动态的改变弧度的大小，就能该表小球的原点坐标了，最后重绘即可。1234567891011121314151617181920212223private void initRotateAnimator() { //弧度从0到最大弧度 ValueAnimator rotateAnimator = ValueAnimator.ofFloat(0, (float) (Math.PI * 2)); rotateAnimator.setDuration(1000); rotateAnimator.setRepeatCount(2); rotateAnimator.setInterpolator(new LinearInterpolator()); rotateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mCurrentAngle = (float) animation.getAnimatedValue(); invalidate(); } }); //监听动画结束，然后开启另一个动画 rotateAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); initAggregationAnimator(); } }); rotateAnimator.start();} 3.让小球执行聚合扩展的动画，首先我们动态的改变大圆的半径值，然后重绘。这里需要设置一个特殊的插值器OvershootInterpolator，它的意思是向前甩一定值后再回到原来位置。123456789101112131415161718192021private void initAggregationAnimator() { ValueAnimator aggregationAnimator = ValueAnimator.ofFloat(mCircleRadius, mRotateRadius); aggregationAnimator.setDuration(500); aggregationAnimator.setInterpolator(new OvershootInterpolator(10f)); aggregationAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mRotateRadius = (float) animation.getAnimatedValue(); invalidate(); } }); //监听动画结束，然后开启另一个动画 aggregationAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); initRippleAnimator(); } }); aggregationAnimator.reverse();} 上面的两个动画中用到了两个插值器：LinearInterpolator和OvershootInterpolator。Android系统中默认给我们提供了很多插值器如下： 插值器 | 描述 :-: | :-: AccelerateDecelerateInterpolator | 开始和结束缓慢，中间加速 AccelerateInterpolator | 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator | 开始的时候向后甩一下，然后向前 AnticipateOvershootInterpolator | 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator | 动画结束的时候弹起 CycleInterpolator | 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator | 开始的时候快，结束的时候慢 LinearInterpolator | 以常量速率变化 OvershootInterpolator | 运动到终点后，冲过终点后再回弹 4.最后绘制一个水波纹的效果，可以通过绘制空心圆的做法实现，通过属性动画，动态改变圆的半径，圆的半径从0到屏幕对角线的一半。123456789101112131415private void initRippleAnimator() {//mDistance为屏幕对角线的一半 ValueAnimator rippleAnimator = ValueAnimator.ofFloat(mCircleRadius, mDistance); rippleAnimator.setDuration(1200); rippleAnimator.setInterpolator(new LinearInterpolator()); rippleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { isRipple = true; mHollowRadius = (float) animation.getAnimatedValue(); invalidate(); } }); rippleAnimator.start();} 最后是onDraw方法中,因为前两部需要绘制6个小圆，最后一步绘制一个空心圆不用绘制小圆，通过一个标志位isRipple来判断需要绘制哪个。标志位在第二个动画结束的时候置为true。1234567891011protected void onDraw(Canvas canvas) { super.onDraw(canvas); if(isRipple){ float strokeWidth = (mDistance - mHollowRadius); mHollowPaint.setStrokeWidth(strokeWidth); float radius = strokeWidth / 2 + mHollowRadius; canvas.drawCircle(mCenterX,mCenterY,radius,mHollowPaint); }else { drawSmallCircle(canvas); } } 到此动画完成。 源码位置请点这里","link":"/2019/03/29/technology/Canvas和属性动画实现好看的效果/"},{"title":"夯实自己的金字塔","text":"不知道大家有没有这种情况，有时候今天的工作很多，自己沉浸在工作之中，忽然间一看时间，已经快下班了，心里面感觉慢慢的充实 有的时候工作少很，刷刷朋友圈，浏览一下新闻，逛一下论坛，一看时间怎么过的这么慢啊，啥时候下班啊，感到非常的无聊，然后继续刷网页逛论坛知道下班结束，心里面感觉到慢慢的空虚。 不只是工作中，平时的放假中也经常会体现，有事情去做无论是学习还是娱乐还是生活琐事，会感觉时间过的很快，但是如果没事情做呢，床上躺尸一天还会感觉非常累。 很多时候我们都是这样重复着每一天，有时候充实，有时候空虚，也许会认为这就是生活的多姿，就没有去在意，但是正常情况下充实是我们想要的，空虚不是我们想要的，为什么不能让每天都是充实的呢？ 稍微想一下，就会发现，这跟我们是否有一个行动的目标有关系，当有目标的时候，我们自然就向着目标前进就行了，反之就像一个无头苍蝇到处乱飞哪也到不了。 所以想要充实自己首先要有一个目标，从大的目标开始，然后分解成一个一个的小目标，比如大目标，两年之内学好英语，小目标就是今天背几个单词说几句口语。 然后按照自己的小目标一天一天的去完成，一个人的技能是生活的支柱，技能的金字塔需要我们一块砖一块砖的去砌，每天一点一点的往上堆砌，总有一天会变成一个高大的金字塔，如果偷懒，每天东逛西爽，技能的金字塔永远也起不来，生活也就失去了支柱。 当我们娱乐的时候身体会感到很满足比如游戏刷视频，而大部分人也都倾向于去享受这种满足感，对于比较辛苦的事情没有耐心比如学习和工作，没有那种延时满足的觉悟，如果你还没有达到财务自由，这些满足感都是暂时的，大部分时间还是去面对生活中的柴米油盐。 试想一下，如果你能在别人娱乐的时候去自己的金字塔添几块砖，起初可能很不起眼，但请相信时间的力量，坚持下去，一段时间之后，你就能明显的看出自己的金字塔比别人高了一层。 自己的金字塔比别人高了一层。自然就有了一丝优越感，或者满足感，为了保证这种满足不会消失，自然更加勤快的去添砖，然后的行成一个良性循环，金字塔也越来越高，慢慢的就变成了别人眼中的成功的人。 永远不要让自己失去目标，永远要坚持建造自己的金字塔，金字塔成了，在这个比较残酷的世界上，才有能力让自己和自己的亲人活的更好，才能活的更加有底气。","link":"/2019/03/04/life/夯实自己的金字塔/"},{"title":"娱乐和节制","text":"很多人都推荐《娱乐至死》这本书，听着名字也挺唬人的，也想看看怎么在娱乐中死去，于是找来这书读了。 虽然本书字数不多，不过看本书真的需要一点耐心，特别还是翻译的外国的书，每个人的名字都很长，各种引用，而且本书在1985年就写完了，比我还大。 文章主要讲了媒介的含义，从印刷术到电报在到电视，随着信息传递的多样化和成本的越来越低，人们各种娱乐活动越来越多，人类进入了娱乐时代，每天被一些简短的广告，各种娱乐节目包围着，这些广告和娱乐节目基本都没啥实质性的意义，却占据了人们的很多时间，各种文字图像和音乐不断刺激着人们，给人娱乐却没让人思考。作者很担心人们沉浸在娱乐中而导致退化。 很遗憾这本书1985年就写完了，如果这时候写完，作者肯定能写更多的东西 ，如今的社会随着网络的普及，电脑的普及，只能手机是普及，人类的娱乐方式比以前多了无数倍，而沉浸在娱乐中的人们比以前也更是多了很多，跟那时候相比，现在更是娱乐至死。 书中提到了躲猫猫的世界，我觉得很好，当我们沉浸在娱乐中的时候，在那个个世界里，一会这个一会那个突然进入我们的世界，然后又很快的消失，这是一个不连续也没有实际意义的世界，大多数时候我们只是一个看客，看着各种热点，各种广告，各种电视剧，各种小说，看完之后我们有能记得什么，大部分时候这些东西对我们都没大意义。 记得以前我特别爱看武侠小说，每当看到一本比较好的小说的时候，总是废寝忘食的看，真的很讽刺啊，学习没见过这么用功，沉浸在小说的剧情里无法自拔，当小说快要看完的时候，甚至感到点点的失落，因为马上要离开这个世界了，几天之后，可能又进入了另一个小说的世界。 一遍一遍的看着别人在别人的世界里打怪升级，成为一代强者，就像自己成功了一样，心里上也是有那么一丝丝的满足，可是那有怎么样呢，现实世界中的我们依然要面对自己的残酷。而那字数动辄几兆十几兆的小说只会浪费我们大量的时间，只有弱者才会去虚拟的世界里感受别人的成功。 我家老弟，平时学习成绩都不错，去年年底迷上了网络游戏吃鸡，天天玩，结果期末考试考得很差。抗拒不了诱惑就很难成功，现实中有很多上学的时候学习成绩很好，考了好大学，但是到了大学之后就不学习了各种娱乐，只求混个毕业证万事，大部分人都认为高考完就是人生的解放，终于可以肆无忌惮的娱乐了。而这些人真正毕业进入社会后混的却并不好。 人类天生就爱娱乐，有些人考上了好大学是自己想考上好大学想有出息，有些人是被老师家长逼着考上的，等到没人管之后，才真正的能看出一个人是否真的有前途。 很庆幸三十多年过去了，人类并没有娱乐至死，而且发展的更快更好，这是因为并不是所有的人都深陷享乐中无法自拔，世界上有很多极度自律的人，他们不断学习不断成长，最终成为大部分人眼中的成功人士。而本书的意义也是能让更多的普通人能意识到娱乐的真正含义，娱乐只是让我们轻松一下的工具，而我们却不能成为它的俘虏。 刷抖音两小时之后你会记得什么吗？只是在刷视频的那一瞬间咯咯笑了一下罢了，而学一个东西两个小时候之后呢，你又会了一个小技能，而它可能会在未来的某一次帮助你。请相信积累的力量，当二十个小时，两百个小时，两千个小时之后，刷抖音的你依然是啥也没记住，而学习的你肯定已经经历了蜕变。 总结一下，娱乐的东西一般都是很快的经过我们的脑子，娱乐不会让我们思考，可以说把各种好东西喂到我们嘴里。而学习呢，却需要我们无时无刻的都在思考，只有去思考，想明白了，那些东西才是我们自己的，然而人类天生懒惰拒绝思考，也就让娱乐比学习更受欢迎。可是世界很残酷啊，往小了将我们需要吃穿玩，需要买房，需要娶妻嫁人，需要赡养老人抚养儿女，往大了将人类需要不断的进步。这些都是那些虚拟的娱乐无法给我们的，想要过的更好，唯有控制住自己懒惰的欲望，不断学习增强自身。","link":"/2019/03/11/life/娱乐和节制/"},{"title":"意识到不足才有机会改","text":"焦虑有时候是好的，如果连焦虑都感受不到，那要么家里有矿，要么就是每天迷迷糊糊的过日子，过到哪算哪；感受到焦虑的人，有的去努力夯实自己，有的每天在娱乐中焦虑的煎熬 最近比较热的就是滴滴裁员啊，美团裁员啊，宜家裁员啊……，各大媒体争相报道，用各种言语表达寒冬的到来，表达中年危机的可怕，弄的我们也是各种焦虑，各种培训班也开始推出各种应对寒冬的课程，具体管不管事就不知道了。 这些事情都是事实，产生焦虑也是应该的，关键的是感受到焦虑的我们该怎么去做。 经常有人抱怨生活很难，日子真的很难过，然后你发现，他一边抱怨着一边躺在床上玩手机。有些人总闲自己很胖，你告诉他每天做做瑜伽，晚上别吃太多，然后发现他每天仍然是瘫在床上玩手机吃东西。 我们大多数人每天都在重复昨天的日子，即使有时候我们知道自己需要改变，需要去努力，知道什么应该做，什么不应该做，结果仍然是不愿动，甚至都没有那么一点点的改变。 现在的八零九零后，很多都是上有老，下有小，中间还有房贷，如果失业了，真的是很大的打击，还可能会意志消沉，妄自菲薄，那就真是雪上加霜了，工作总会找到的，在努力奋斗的同时，一定要相信自己。 所以一定要让焦虑变成自己努力的动力，而不是压垮自己的稻草。 有了动力之后，找到自己的生活目标，为什么不是人生目标而是生活目标呢，因为人生太长了，大多数人经不起等待，我们需要定的是一个一个的小目标，一个月，一季度，半年，一年就好。然后就是一个一个的去完成，完成的同时也能激励自己继续前进 比如做技术总有一天会遇到瓶颈的，因为它需要终身学习。也许是因为生活的原因你没时间学了，也许是因为做的时间长了厌倦了，也许你一直保持着热情，每天都在努力的深挖你的技能，但是因为年龄的原因被企业嫌弃了，无论什么原因，结果都是技术的路线干不动了。 所以，技术做到一定程度之后，业余时间多关注一下别的领域，比如产品啊，理财啊，写作啊，商业啊，就像在这个到处裁员的寒冬，股市却是开门红，从年初到现在，涨了不少，很多人都赚了。所以给自己定个学习计划，在不断精进自己技术的同时，也开始学习一个别的领域的知识，扩展自己的第二技能。 最后就是坚持，学习这东西见效比较慢，冰冻三尺非一日之寒，量变引起质变，不要被游戏，抖音，直播这类的的APP占据太多的时间。对于学习来说，因为大多数人的智力是差不多的，最终拼的就是坚持，如果你不能长期面对痛苦，不能长期等待，那么这个世界上大多数的美好都与你无缘。","link":"/2019/02/27/life/意识到不足才有机会改/"},{"title":"Android屏幕适配","text":"Android屏幕适配这个东西，真是每个Andorid开发者从入行开始就比较关注也比较头疼的问题 从多套dimens到百分比布局再到鸿神的AutoLayout还有smallestWidth最小宽度限定符适配，这些都能达到一些挺好的效果，不过也有不少bug存在，适配起来酣畅淋漓的感觉。后来有人想到了修改系统Density用起来比较爽，这篇文章非常不错，可惜知道的人比较少，直到今日头条在其公众号发表了一篇适配的文章一种极低成本的Android屏幕适配方式，核心思想跟上面是一样的，这种方式才迅速让更多的开发者知道，于是不少优秀的的框架出现AndroidAutoSize和AndroidUtilCode 本篇文章就把上面的原理在熟悉一下，记个笔记。如需源码请去上面开源库中寻找。 无论我们使用什么单位适配，除了px剩下的单位都会根据一定的规则进行转换，布局文件转换位置在android.util下的TypedValue#applyDimension。12345678910111213141516171819public static float applyDimension(int unit, float value, DisplayMetrics metrics) { switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); } return 0; } Bitmap的转换在 BitmapFactory#decodeResourceStream12345678public static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, Options opts) { ... if (opts.inTargetDensity == 0 &amp;&amp; res != null) { opts.inTargetDensity = res.getDisplayMetrics().densityDpi; } ... } 上面的代码可以看到，根据不同单位转换的时候，都用到了DisplayMetrics这个类，通过metrics.density，metrics.scaledDensity等值来转化。density就是屏幕的密度，scaledDensity是字体的缩放因子，正常情况下跟density值是相等的，当改变系统字体的大小的时候这个值会变。 如果我们是用dp，上面代码中的value就是我们的dp值，可以看到px=dp*density 所以，适配的时候，保持dp值不变，我们可以修改系统的density值让它跟我们的设计图中的density值相等就好了。 通常情况下，我们适配宽或者高中的一个就行了，因为每个设备的宽高比是不一样的，有的是16:9，有的是4:3等等，所以完全显示一直是不可能的。 下面使用宽度适配一下12345678910111213141516171819202122232425262728public class ScreenAdapter { /** * 参考设计图的宽 单位dp * 比如设计图是1920*1080 按360dp为基准 * 相同分辨率的手机，屏幕的尺寸不同也会导致最后的dp值不同。 * 比如1920*1080分辨率，屏幕尺寸为5，最后是392.7dp */ private static float WIDTH = 320; public static void adapter(Activity activity){ //系统的DisplayMetrics final DisplayMetrics systemDM = Resources.getSystem().getDisplayMetrics(); //根据设计图的WIDTH计算当前的density, scaleDensity, densityDpi float targetDensity = systemDM.widthPixels/WIDTH; float targetScaleDensity = targetDensity *(systemDM.scaledDensity/systemDM.density); //px = density * dp; density = dpi / 160; px = dp * (dpi / 160); int targetDensityDpi = (int) (targetDensity*160); //替换Activity的density, scaleDensity, densityDpi //Activity的DisplayMetrics final DisplayMetrics activityDM = activity.getResources().getDisplayMetrics(); activityDM.density = targetDensity; activityDM.scaledDensity = targetScaleDensity; activityDM.densityDpi = targetDensityDpi; }} 由于 API 26 及以上的 Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics() 是不同的引用，所以在 API 26 及以上适配是没有影响的，但在API26以下Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics()是相同的引用，导致适配有问题，而Resources#getSystem()#getDisplayMetrics() 没有这个问题所以使用它了。 如果使用Application#getResources()#getDisplayMetrics()，在手机的设置中改变字体的大小的时候，APP中无法改变，需要注册监听registerComponentCallbacks12345678910111213141516float appScaleDensity; //添加字体变化监听回调 application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { //字体发生更改，重新对scaleDensity进行赋值 if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0){ appScaleDensity = application.getResources().getDisplayMetrics().scaledDensity; } } @Override public void onLowMemory() { } }); 不过如果使用Resources#getSystem()#getDisplayMetrics()的话就没这个问题了，不需要注册上面的监听也能跟随系统改变。最后在Activity的setContentViw()方法之前调用上面类中的adapter方法就可以愉快的适配了。 缺点： 修改了系统的density值之后，所有的地方都适配了，比如第三方库中的dp值，系统库中的dp值，这就会出现一个问题,如果第三方库和系统库中的UI设计的尺寸跟我们的基准尺寸不一样，那适配肯定就会出问题了，比如AlertDialog，Toast的尺寸会变形。可以在调用这些控件的时候先取消适配。1234567public static void cancelAdapter(final Activity activity) { final DisplayMetrics systemDm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics activityDm = activity.getResources().getDisplayMetrics(); activityDm.density = systemDm.density; activityDm.scaledDensity = systemDm.scaledDensity; activityDm.densityDpi = systemDm.densityDpi;} 有时候系统会重置density的值，比如WebView初始化的时候会重置DisplayMetrics#density的值导致适配失效。可以重写VebView的setOverScrollMode方法12345@Overridepublic void setOverScrollMode(int mode) { super.setOverScrollMode(mode); //在这重新执行adapter的方法 } 还有一些其他的问题，可以去这两个框架的issue中查看。 从最开始的代码中可以看到除了dp,sp之外，还有一些别的单位，pt,in,mm,Android源代码和第三方库中一般都是使用的dp,sp来做单位，所以我们可以更改pt这个单位，pt，它表示一个点，是屏幕的物理尺寸，其大小为 1 英寸的 1 / 72，也就是 72pt 等于 1 英寸 123456//designWidth是我们设计图的px尺寸public static void adaptWidth(Activity activity, int designWidth) { DisplayMetrics dm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics activityDM = activity.getResources().getDisplayMetrics(); activityDM.xdpi= dm.xdpi = (dm.widthPixels * 72f) / designWidth; } 修改DisplayMetrics中的xdpi的值，在布局文件中使用pt做单位，这样我们的修改就不会对系统和第三方的控件的大小改变了。 当然是用这种偏门的单位，对代码的入侵性就有点大，如果以后有了更好的适配方式，更改起来比较麻烦，不过也有处理的方式 从最开始那个代码中我们可以看到，如果以pt为单位，返回的是return value * metrics.xdpi * (1.0f/72);，以dp为单位返回的是return value * metrics.density; 放到一块对比一下12return value * metrics.xdpi * (1.0f/72);return value * metrics.density; 从上面看，如果我们把metrics.xdpi * (1.0f/72)变成metrics.density，那么我们在布局文件中使用dp和pt的效果就一样了。 所以，假如真有更好的方式的时候，可以通过一个取消pt适配的方式，把上面给改了，到时候dp和pt效果一样，我们就不用去布局文件中一个一个的更改了。取消方式12345public static void cancelPtAdapter(final Activity activity) { final DisplayMetrics dm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics activityDm = activity.getResources().getDisplayMetrics(); activityDm.xdpi = dm.xdpi = dm.density * 72; }","link":"/2019/04/05/technology/Android屏幕适配/"},{"title":"粒子效果的实现","text":"想要实现一个图片的粒子效果，非常简单 效果图： 思路： 遍历图片的宽高，通过Bitmap.getPixel(row,cloum)这个方法，返回值我们可以拿到当前像素点的颜色值，我们也能拿到当前的坐标点，然后封装成一个一个的小球对象，保存在集合里面。 在onDraw里面遍历集合根据这些小球的坐标点和颜色值绘制圆圈。如果我们取的像素足够密，绘制出来的原点可以组成这个图片。 动画效果，通过属性动画，在onAnimationUpdate方法中根据一定的算法不断更新小球对象的x，y坐标点。这个算法可以自己定，比如通过自有落体的公式，或者随机数等。 在onTouchEvent方法中监听ACTION_DOWN事件开启动画 如果直接取图片的所有像素，如果图片很大的话，会非常卡，如果不取全部的，那绘制出来效果没原图清晰，我们可以通过一个标志位，开始绘制原图，点击之后在绘制小圆球。 创建一个Ball对象，用来保存将要绘制的每个点的坐标和当坐标更新时的变化速度。1234567891011121314151617181920public class Ball { public int color; //x坐标 public float x; //y坐标 public float y; //半径 public float r; //水平速度 public float vX; //垂直速度 public float vY; //水平加速度 public float aX; //垂直加速度 public float aY;} 创建一个bitmap,遍历它的宽高，获取像素值，和坐标值，封装成一个一个的小球并保存起来。为了提高效率这里的遍历每次+2，可根据实际情况更改。12345678910111213141516171819mBitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.shader);for (int i = 0; i &lt; mBitmap.getWidth()/d; i+=2) { for (int j = 0; j &lt; mBitmap.getHeight()/d; j+=2) { Ball ball = new Ball(); ball.color = mBitmap.getPixel(i,j); ball.x = i*d+d/2; ball.y = j*d+d/2; ball.r = d/2; //速度(-20,20) ball.vX = (float) (Math.pow(-1, Math.ceil(Math.random() * 100)) * 20 * Math.random()); ball.vY = rangInt(-15, 35); //加速度 ball.aX = 0; ball.aY = 0.98f; mBalls.add(ball); } } 开始绘制，判断是绘制原图还是绘制小圆圈。123456789101112protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.translate(getWidth()/2-mBitmap.getWidth()/2,getHeight()/2-mBitmap.getHeight()/2); if(isShowBitmap){ canvas.drawBitmap(mBitmap,0,0,null); }else { for (Ball ball : mBalls) { mPaint.setColor(ball.color); canvas.drawCircle(ball.x,ball.y,ball.r,mPaint); } }} 使用属性动画，动态的更新每个小球的坐标值然后重新绘制。1234567891011121314151617181920splitAnimator = ValueAnimator.ofFloat(0,1); splitAnimator.setRepeatCount(-1); splitAnimator.setDuration(2000); splitAnimator.setInterpolator(new LinearInterpolator()); splitAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { updateBall(); invalidate(); } }); private void updateBall() { for (Ball ball : mBalls) { ball.x += ball.vX; ball.y += ball.vY; ball.vX += ball.aX; ball.vY += ball.aY; }} OK完成，源码地址点击这里","link":"/2019/03/29/technology/粒子效果的实现/"},{"title":"RecycleView的缓存原理","text":"RecycleView的缓存原理 上一篇文章RecycleView的绘制流程，当我们走到子View的布局流程的layoutChunk方法的时候，通过View view = layoutState.next(recycler);方法获取将要布局的子View，然后进行后续操作，现在来看一下这个子View是怎么获取的。12345678View next(RecyclerView.Recycler recycler) { if (mScrapList != null) { return nextViewFromScrapList(); } final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view; } 可以看到是通过recycler.getViewForPosition这个方法获取的123456public View getViewForPosition(int position) { return getViewForPosition(position, false); }View getViewForPosition(int position, boolean dryRun) { return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView; } tryGetViewHolderForPositionByDeadline方法返回的是一个ViewHolder对象，然后直接返回ViewHolder的成员变量itemView，也就是当前将要布局的子view。 到这里还没有涉及到缓存的代码，我们也可以猜测，RecycleView的缓存，不只是对View缓存，是对ViewHolder的缓存。 tryGetViewHolderForPositionByDeadline这个方法是真正的缓存机制的入口，它是RecycleView.Recycler中的方法，按照我们正常的思维想想里面肯定是先从缓存中去，取不到在新建一个，那么这个缓存是啥呢，在进入tryGetViewHolderForPositionByDeadline方法之前我们先看几个Recycler中的成员变量方便看下面的代码123456789101112131415161718public final class Recycler { final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2; ...... 这几个就是用来缓存的List了 mAttachedScrap：不参与复用，只保存在重新布局的时候，从RecycleView中剥离的当前在显示的ViewHolder列表。比如当我们插入一条或者删除一条数据，这时候需要重新布局，怎么办呢，办法就是把当前屏幕上显示的view先拿下来保存到一个列表中，然后在重新布局上去。这个列表就是mAttachedScrap。所以它只是存储重新布局前从RecycleView上剥离出的ViewHolder，并不参与复用 mUnmodifiableAttachedScrap：通过Collections.unmodifiableList(mAttachedScrap)，把mAttachedScrap放进去，返回一个不可更改的列表，共外部获取 mChangedScrap：不参与复用 从新布局的时候要修改的放到这里面，其余的放到mAttachedScrap mCachedViews：从名字就能看出来这就是参与缓存的list mRecyclerPool：参与缓存，并且它里面的ViewHolder的信息都会被重置，相当于一个新建的ViewHolder，供后面使用 mViewCacheExtension：这个是让我们自己扩展自己的缓存策略，一般情况下我们不会自己写这东西的。 所以，mCachedViews ，mRecyclerPool ， mViewCacheExtension 这三个组成了一个三级缓存，当RecyclerView要拿一个复用的ViewHolder的时候，查找的顺序是mCachedViews-&gt;mViewCacheExtension-&gt;mRecyclerPool。因为一般情况下我们不会写mViewCacheExtension，所以一般情况就两级缓存mCachedViews-&gt;mRecyclerPool 实际上mCachedViews是不参与真正的回收的，mCachedViews的作用是保存最新被移除的ViewHolder，通过removeAndRecycleView(view, recycler)方法，它的作用是，当需要更新ViewHoder的时候，精确的匹配是不是刚才移除那个，如果是直接拿出来让RecycleView布局，如果不是，即使它中存在ViewHolder，也不会返回，而是去mRecyclerPool中找一个新的ViewHolder然后重新赋值。mAttachedScrap中也是精确匹配步骤跟mCachedViews一样。 OK下面我们进入tryGetViewHolderForPositionByDeadline方法中看看到底是怎么取的吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) { if (position &lt; 0 || position &gt;= mState.getItemCount()) { throw new IndexOutOfBoundsException(\"Invalid item position \" + position + \"(\" + position + \"). Item count:\" + mState.getItemCount() + exceptionLabel()); } boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) 是否处于布局前的状态 去mChangedScrap中找，布局前的状态也就是重新布局的时候 if (mState.isPreLayout()) { holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; } // 1) 先从mAttachedScrap中找，找不到在去mCachedViews中查找 if (holder == null) { holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) { if (!validateViewHolderForOffsetPosition(holder)) { // 检查是不是我们要查找的viewholder，如果不是移除 if (!dryRun) { // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) { removeDetachedView(holder.itemView, false); holder.unScrap(); } else if (holder.wasReturnedFromScrap()) { holder.clearReturnedFromScrapFlag(); } //回收这个holder 放到mCachedViews或者mRecyclerPool中 recycleViewHolderInternal(holder); } holder = null; } else { fromScrapOrHiddenOrCache = true; } } } if (holder == null) { final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) { throw new IndexOutOfBoundsException(\"Inconsistency detected. Invalid item \" + \"position \" + position + \"(offset:\" + offsetPosition + \").\" + \"state:\" + mState.getItemCount() + exceptionLabel()); } final int type = mAdapter.getItemViewType(offsetPosition); // 2)通过id精确的从mAttachedScrap中查找 if (mAdapter.hasStableIds()) { holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) { // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; } } //如果我们自定义了缓存策略 if (holder == null &amp;&amp; mViewCacheExtension != null) { // We are NOT sending the offsetPosition because LayoutManager does not // know it. final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) { holder = getChildViewHolder(view); if (holder == null) { throw new IllegalArgumentException(\"getViewForPositionAndType returned\" + \" a view which does not have a ViewHolder\" + exceptionLabel()); } else if (holder.shouldIgnore()) { throw new IllegalArgumentException(\"getViewForPositionAndType returned\" + \" a view that is ignored. You must call stopIgnoring before\" + \" returning this view.\" + exceptionLabel()); } } } if (holder == null) { // fallback to pool if (DEBUG) { Log.d(TAG, \"tryGetViewHolderForPositionByDeadline(\" + position + \") fetching from shared pool\"); } //去mRecyclerPool中查找 根据不同的type拿到不同的holder， //type就是我们在adapter中写的getItemViewType holder = getRecycledViewPool().getRecycledView(type); if (holder != null) { holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) { invalidateDisplayListInt(holder); } } } if (holder == null) { long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) { // abort - we have a deadline we can't meet return null; } //缓存中找不到调用createViewHolder创建 holder = mAdapter.createViewHolder(RecyclerView.this, type); if (ALLOW_THREAD_GAP_WORK) { // only bother finding nested RV if prefetching RecyclerView innerView = findNestedRecyclerView(holder.itemView); if (innerView != null) { holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView); } } long end = getNanoTime(); mRecyclerPool.factorInCreateTime(type, end - start); if (DEBUG) { Log.d(TAG, \"tryGetViewHolderForPositionByDeadline created new ViewHolder\"); } } } // This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM. if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) { holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (mState.mRunSimpleAnimations) { int changeFlags = ItemAnimator .buildAdapterChangeFlagsForAnimations(holder); changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState, holder, changeFlags, holder.getUnmodifiedPayloads()); recordAnimationInfoIfBouncedHiddenView(holder, info); } } boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) { // do not update unless we absolutely have to. holder.mPreLayoutPosition = position; } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {//如果没有绑定数据 if (DEBUG &amp;&amp; holder.isRemoved()) { throw new IllegalStateException(\"Removed holder should be bound and it should\" + \" come here only in pre-layout. Holder: \" + holder + exceptionLabel()); } final int offsetPosition = mAdapterHelper.findPositionOffset(position); //调用bindViewHolder bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); } //给holder中的itemView设置LayoutParams final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams(); final LayoutParams rvLayoutParams; if (lp == null) { rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams); } else if (!checkLayoutParams(lp)) { rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams); } else { rvLayoutParams = (LayoutParams) lp; } rvLayoutParams.mViewHolder = holder; rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound; return holder; } 从上面源码可以总结一下的流程，先去mAttachedScrap中找。是要是看看View是不是刚刚剥离的，如果是直接返回如果不是，去mCachedViews中查找，mCachedViews中是精确查找，如果找到返回，找不到或者匹配不上就去mRecyclerPool中查找，找到了返回一个全新的ViewHolder，找不到的话只能调用onCreateViewHolder新建一个了。 mAttachedScrap和mCachedViews都是精确查找，找到的ViewHolder都是已经绑定好数据的，不会再调用onBindViewHolder重新绑定数据，mRecyclerPool中的ViewHolder都是清理干净的空白的ViewHolder，找到之后需要调用onBindViewHolder重新绑定数据，这点我们可以从上面代码中的第二步那跟进去看看getScrapOrCachedViewForId方法1234567891011121314151617181920212223242526272829303132333435363738394041424344ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) { // Look in our attached views first final int count = mAttachedScrap.size(); for (int i = count - 1; i &gt;= 0; i--) { final ViewHolder holder = mAttachedScrap.get(i); //判断id是否一致 是不是从Scrap中返回 //是才返回，不是去mCachedViews中找 if (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) { if (type == holder.getItemViewType()) { holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); if (holder.isRemoved()) { if (!mState.isPreLayout()) { holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED); } } return holder; } else if (!dryRun) { mAttachedScrap.remove(i); removeDetachedView(holder.itemView, false); quickRecycleScrapView(holder.itemView); } } } // Search the first-level cache final int cacheSize = mCachedViews.size(); for (int i = cacheSize - 1; i &gt;= 0; i--) { final ViewHolder holder = mCachedViews.get(i); //判断id是否一致，是才返回不是放入mRecyclerPool中并从mCachedViews中移除 if (holder.getItemId() == id) { if (type == holder.getItemViewType()) { if (!dryRun) { mCachedViews.remove(i); } return holder; } else if (!dryRun) { recycleCachedViewAt(i); return null; } } } return null; } 可以看到上面的代码中，从对应的缓存中找到holder之后，都会判断一下是不是想要的那个holder，是的话才会返回。 那RecycleView到底是怎么复用的呢？入口很多比如通过Recycler中的recycleView方法（recycler.recycleView）进去看看1234567891011121314public void recycleView(View view) { // This public recycle method tries to make view recycle-able since layout manager // intended to recycle this view (e.g. even if it is in scrap or change cache) ViewHolder holder = getChildViewHolderInt(view); if (holder.isTmpDetached()) { removeDetachedView(view, false); } if (holder.isScrap()) { holder.unScrap(); } else if (holder.wasReturnedFromScrap()) { holder.clearReturnedFromScrapFlag(); } recycleViewHolderInternal(holder); } 这个方法用于回收分离的视图和把指定的视图放到缓存池中用于重新绑定和复用。最后调用了recycleViewHolderInternal方法，recycleViewHolderInternal这个方法时最终的回收方法，有的入口直接调用了这个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void recycleViewHolderInternal(ViewHolder holder) { ...... boolean cached = false; boolean recycled = false; if (DEBUG &amp;&amp; mCachedViews.contains(holder)) { throw new IllegalArgumentException(\"cached view received recycle internal? \" + holder + exceptionLabel()); } if (forceRecycle || holder.isRecyclable()) { if (mViewCacheMax &gt; 0 &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) { // Retire oldest cached view int cachedViewSize = mCachedViews.size(); //mViewCacheMax的值是2，所以mCachedViews中最多缓存两条数据 if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) { //根据先进先出原则，把最老的从mCachedViews中放到mRecyclerPool中 recycleCachedViewAt(0); cachedViewSize--; } int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK &amp;&amp; cachedViewSize &gt; 0 &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) { // when adding the view, skip past most recently prefetched views int cacheIndex = cachedViewSize - 1; while (cacheIndex &gt;= 0) { int cachedPos = mCachedViews.get(cacheIndex).mPosition; if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) { break; } cacheIndex--; } targetCacheIndex = cacheIndex + 1; } //将最近刚刚回收的ViewHolder放在mCachedViews里 mCachedViews.add(targetCacheIndex, holder); cached = true; } //如果不设置往mCachedViews中放，就放入mRecyclerPool if (!cached) { addViewHolderToRecycledViewPool(holder, true); recycled = true; } } else { // NOTE: A view can fail to be recycled when it is scrolled off while an animation // runs. In this case, the item is eventually recycled by // ItemAnimatorRestoreListener#onAnimationFinished. // TODO: consider cancelling an animation when an item is removed scrollBy, // to return it to the pool faster if (DEBUG) { Log.d(TAG, \"trying to recycle a non-recycleable holder. Hopefully, it will \" + \"re-visit here. We are still removing it from animation lists\" + exceptionLabel()); } } // even if the holder is not removed, we still call this method so that it is removed // from view holder lists. mViewInfoStore.removeViewHolder(holder); if (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) { holder.mOwnerRecyclerView = null; } } 从这里面我们看到了熟悉的mCachedViews和mRecyclerPool，这也说明了RecycleView的回收机制跟mAttachedScrap是没有关系的。 那这个回收到底是从哪里调用的呢？第一个地方就是在LayoutManager的onLayoutChildren方法中调用的detachAndScrapAttachedViews(recycler);，另一个就是Recyclerview滑动的时候调用removeAndRecycleView方法。 detachAndScrapAttachedViews仅用于布局之前，将所有的子view剥离，放在mAttachedScrap中供后面重新布局的时候使用。 removeAndRecycleView在滚动的时候，把ViewHolder标记为removed，先缓存在mCachedViews中，mCachedViews的最大容量为2，如果mCachedViews中存满了，把最先缓存进来的拿出来放到mRecyclerPool，mRecyclerPool中默认缓存5个。然后把最新的放入mCachedViews中缓存。 OK，结束。 参考： https://www.cnblogs.com/dasusu/p/7746946.html https://www.jianshu.com/p/504e87089589 https://blog.csdn.net/harvic880925/article/details/84866486","link":"/2019/04/05/technology/RecycleView的缓存原理/"},{"title":"UI绘制流程--View是如何被添加到屏幕上的","text":"我们平时打开一个activity的时候，设置我们的视图都是在onCreate的setContentView方法开始，那我们就从这个方法开始看源码。 这里我们继承的是AppCompatActivity 12345678910public void setContentView(@LayoutRes int layoutResID) { this.getDelegate().setContentView(layoutResID); }public void setContentView(View view) { this.getDelegate().setContentView(view); }public void setContentView(View view, LayoutParams params) { this.getDelegate().setContentView(view, params); } 这里有三个重载的方法，原理都一样，我们平时最常用的就是放入一个xml文件了，所以从第一个往下看。调用了getDelegate()的setContentView方法123456789public AppCompatDelegate getDelegate() { if (this.mDelegate == null) { this.mDelegate = AppCompatDelegate.create(this, this); } return this.mDelegate; }public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) { return new AppCompatDelegateImpl(activity, activity.getWindow(), callback); } 可以看到getDelegate最后返回了AppCompatDelegateImpl实例传入了activity window和callback，所以也就是调用了它的setContentView方法。12345678910public void setContentView(int resId) { //确保mSubDecor已经创建 this.ensureSubDecor(); //找到contentParent ViewGroup contentParent = (ViewGroup)this.mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); //把我们的view放入contentParent中 LayoutInflater.from(this.mContext).inflate(resId, contentParent); this.mOriginalWindowCallback.onContentChanged(); } 首先调用了ensureSubDecor()方法，从名字来看感觉是确保某个view已经创建。然后从mSubDecor这个ViewGroup中通过id找到contentParent,可以猜测这个mSubDecor应该就是从前面的方法中创建的。然后把我们的view放进去。先看ensureSubDecor()方法。123456789101112131415161718192021222324252627private void ensureSubDecor() { if (!this.mSubDecorInstalled) { //果然是从这里创建的 this.mSubDecor = this.createSubDecor(); CharSequence title = this.getTitle(); if (!TextUtils.isEmpty(title)) { if (this.mDecorContentParent != null) { this.mDecorContentParent.setWindowTitle(title); } else if (this.peekSupportActionBar() != null) { this.peekSupportActionBar().setWindowTitle(title); } else if (this.mTitleView != null) { this.mTitleView.setText(title); } } this.applyFixedSizeWindow(); //回调此view this.onSubDecorInstalled(this.mSubDecor); //标记已经创建完 this.mSubDecorInstalled = true; AppCompatDelegateImpl.PanelFeatureState st = this.getPanelState(0, false); if (!this.mIsDestroyed &amp;&amp; (st == null || st.menu == null)) { this.invalidatePanelMenu(108); } } } 上面这段代码主要就是调用了createSubDecor()方法创建了mSubDecor这个ViewGroup,并回调和标记已创建。所以createSubDecor()是个关键方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128private ViewGroup createSubDecor() { //获取属性 TypedArray a = this.mContext.obtainStyledAttributes(styleable.AppCompatTheme); if (!a.hasValue(styleable.AppCompatTheme_windowActionBar)) { a.recycle(); //如果不设置AppCompat相关的主题就报错 throw new IllegalStateException(\"You need to use a Theme.AppCompat theme (or descendant) with this activity.\"); } else { //根据拿到的主题属性来设置相应的主题风格 if (a.getBoolean(styleable.AppCompatTheme_windowNoTitle, false)) { this.requestWindowFeature(Window.FEATURE_NO_TITLE); } else if (a.getBoolean(styleable.AppCompatTheme_windowActionBar, false)) { this.requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR); } if (a.getBoolean(styleable.AppCompatTheme_windowActionBarOverlay, false)) { this.requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY); } if (a.getBoolean(styleable.AppCompatTheme_windowActionModeOverlay, false)) { this.requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY); } this.mIsFloating = a.getBoolean(styleable.AppCompatTheme_android_windowIsFloating, false); a.recycle(); //获取DecorView this.mWindow.getDecorView(); LayoutInflater inflater = LayoutInflater.from(this.mContext); // ViewGroup subDecor = null; //根据前面设置的不同的主题风格性创建出subDecor，比如FEATURE_NO_TITLE，FEATURE_SUPPORT_ACTION_BAR_OVERLAY if (!this.mWindowNoTitle) { if (this.mIsFloating) { subDecor = (ViewGroup)inflater.inflate(layout.abc_dialog_title_material, (ViewGroup)null); this.mHasActionBar = this.mOverlayActionBar = false; } else if (this.mHasActionBar) { TypedValue outValue = new TypedValue(); this.mContext.getTheme().resolveAttribute(attr.actionBarTheme, outValue, true); Object themedContext; if (outValue.resourceId != 0) { themedContext = new ContextThemeWrapper(this.mContext, outValue.resourceId); } else { themedContext = this.mContext; } subDecor = (ViewGroup)LayoutInflater.from((Context)themedContext).inflate(layout.abc_screen_toolbar, (ViewGroup)null); this.mDecorContentParent = (DecorContentParent)subDecor.findViewById(id.decor_content_parent); this.mDecorContentParent.setWindowCallback(this.getWindowCallback()); if (this.mOverlayActionBar) { this.mDecorContentParent.initFeature(109); } if (this.mFeatureProgress) { this.mDecorContentParent.initFeature(2); } if (this.mFeatureIndeterminateProgress) { this.mDecorContentParent.initFeature(5); } } } else { if (this.mOverlayActionMode) { subDecor = (ViewGroup)inflater.inflate(layout.abc_screen_simple_overlay_action_mode, (ViewGroup)null); } else { subDecor = (ViewGroup)inflater.inflate(layout.abc_screen_simple, (ViewGroup)null); } if (VERSION.SDK_INT &gt;= 21) { ViewCompat.setOnApplyWindowInsetsListener(subDecor, new OnApplyWindowInsetsListener() { public WindowInsetsCompat onApplyWindowInsets(View v, WindowInsetsCompat insets) { int top = insets.getSystemWindowInsetTop(); int newTop = AppCompatDelegateImpl.this.updateStatusGuard(top); if (top != newTop) { insets = insets.replaceSystemWindowInsets(insets.getSystemWindowInsetLeft(), newTop, insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom()); } return ViewCompat.onApplyWindowInsets(v, insets); } }); } else { ((FitWindowsViewGroup)subDecor).setOnFitSystemWindowsListener(new OnFitSystemWindowsListener() { public void onFitSystemWindows(Rect insets) { insets.top = AppCompatDelegateImpl.this.updateStatusGuard(insets.top); } }); } } if (subDecor == null) { throw new IllegalArgumentException(\"AppCompat does not support the current theme features: { windowActionBar: \" + this.mHasActionBar + \", windowActionBarOverlay: \" + this.mOverlayActionBar + \", android:windowIsFloating: \" + this.mIsFloating + \", windowActionModeOverlay: \" + this.mOverlayActionMode + \", windowNoTitle: \" + this.mWindowNoTitle + \" }\"); } else { if (this.mDecorContentParent == null) { this.mTitleView = (TextView)subDecor.findViewById(id.title); } //选择适合系统窗口的装饰 ViewUtils.makeOptionalFitsSystemWindows(subDecor); //获取布局的父容器中的ContentFrameLayout ContentFrameLayout contentView = (ContentFrameLayout)subDecor.findViewById( R.id.action_bar_activity_content); //找到PhoneWindow中的ContentView 如果看activity中的setContentView方法我们知道android.R.id.content就是我们设置的view的父view ViewGroup windowContentView = (ViewGroup)this.mWindow.findViewById(android.R.id.content); if (windowContentView != null) { while(windowContentView.getChildCount() &gt; 0) { View child = windowContentView.getChildAt(0); windowContentView.removeViewAt(0); contentView.addView(child); } //把PhoneWindow中的ContentView设置成没有id windowContentView.setId(View.NO_ID); //把从我们的主题xml中找到的contentView的id设置成android.R.id.content，其实就是以前的PhoneWindow中的ContentView中的id contentView.setId(android.R.id.content); if (windowContentView instanceof FrameLayout) { ((FrameLayout)windowContentView).setForeground((Drawable)null); } } //把subDecor设置给window，mWindow是个Window对象，它只有一个子类就是PhoneWindow this.mWindow.setContentView(subDecor); contentView.setAttachListener(new OnAttachListener() { public void onAttachedFromWindow() { } public void onDetachedFromWindow() { AppCompatDelegateImpl.this.dismissPopups(); } }); return subDecor; } } } 通过上面的源码我们可以知道，通过不同的主题创建出不同的subDecor这个ViewGroup容器，然后把从PhoneWindow中通过android.R.id.content找出原来的contentview然后把它设置成没有id，然后把subDecor中通过R.id.action_bar_activity_content找到的这个view的id重新设置为android.R.id.content来个偷天换日，最后把这个subDecor设置回PhoneWindow中。 我们知道subDecor是通过inflate一个布局文件创建出来的，下面先来看看这个subDecor的布局文件长啥样，源码位置 /frameworks/support/v7/appcompat/res/layout/abc_screen_simple.xml1234567891011121314151617181920212223242526272829&lt;androidx.appcompat.widget.FitWindowsLinearLayout18 xmlns:android=\"http://schemas.android.com/apk/res/android\"19 android:id=\"@+id/action_bar_root\"20 android:layout_width=\"match_parent\"21 android:layout_height=\"match_parent\"22 android:orientation=\"vertical\"23 android:fitsSystemWindows=\"true\"&gt;2425 &lt;androidx.appcompat.widget.ViewStubCompat26 android:id=\"@+id/action_mode_bar_stub\"27 android:inflatedId=\"@+id/action_mode_bar\"28 android:layout=\"@layout/abc_action_mode_bar\"29 android:layout_width=\"match_parent\"30 android:layout_height=\"wrap_content\" /&gt;3132 &lt;include layout=\"@layout/abc_screen_content_include\" /&gt;3334&lt;/androidx.appcompat.widget.FitWindowsLinearLayout&gt;//abc_screen_content_include&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;1819 &lt;androidx.appcompat.widget.ContentFrameLayout20 android:id=\"@id/action_bar_activity_content\"21 android:layout_width=\"match_parent\"22 android:layout_height=\"match_parent\"23 android:foregroundGravity=\"fill_horizontal|top\"24 android:foreground=\"?android:attr/windowContentOverlay\" /&gt;2526&lt;/merge&gt; 可以看到subDecor其实是个FitWindowsLinearLayout。 小插曲：requestWindowFeature，我们以前都用过这个方法， requestWindowFeature(Window.FEATURE_NO_TITLE);用的时候要求我们要放到setContentView()方法之前，为什么呢，前面的代码中我们看到了requestWindowFeature这个方法，跟进去之后，看到调用了this.throwFeatureRequestIfSubDecorInstalled();这个方法12345private void throwFeatureRequestIfSubDecorInstalled() { if (this.mSubDecorInstalled) { throw new AndroidRuntimeException(\"Window feature must be requested before adding content\"); } } 如果mSubDecorInstalled为true就报错，而mSubDecorInstalled这个标志位我们前面的ensureSubDecor()方法中就给他设置为true了。所以此方法要在setContentView()方法之前调用。 OK前面我们很多次提到了mWindow这个成员变量，最终subDecor也是被设置到mWindow中，前面createSubDecor()方法中有两个很重要的指令mWindow.getDecorView();和mWindow.setContentView(subDecor); 进入Window类，它是一个抽象类，看类上面的注释，可以知道它只有一个子类PhoneWindow，所以上面的两个方法都是在PhoneWindow中实现的。 123456public final View getDecorView() { if (mDecor == null || mForceDecorInstall) { installDecor(); } return mDecor; } 如果mDecor是空就创建一个，最后返回mDecor。123456789101112131415private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { mDecor = generateDecor(-1); ... } else { mDecor.setWindow(this); } if (mContentParent == null) { mContentParent = generateLayout(mDecor); ... } ... } 这个类很长，只看主要的，如果mDecor为null就调用generateDecor方法创建，否则就直接把当前window对象设置为mDecor，mDecor这个成员变量点过去可以看到是DecorView对象。mContentParent这个成员变量点过去可以看到它是一个ViewGroup，如果是null就创建，传入了mDecor。1234567891011121314151617protected DecorView generateDecor(int featureId) { Context context; if (mUseDecorContext) { Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) { context = getContext(); } else { context = new DecorContext(applicationContext, getContext()); if (mTheme != -1) { context.setTheme(mTheme); } } } else { context = getContext(); } return new DecorView(context, featureId, this, getAttributes()); } 下面看一下DecorView123public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { ...} 可以看到它就是一个FrameLayout，然后在看一下 generateLayout(mDecor)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected ViewGroup generateLayout(DecorView decor) { //获取属性数组 TypedArray a = getWindowStyle(); ... //是不是悬浮 mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); ... //设置一堆标志位，通过TypedArray获取各种属性 ... //给窗口充气 int layoutResource; int features = getLocalFeatures(); //根据不同的标志位选择不同的布局文件 //布局文件位置/frameworks/base/core/res/res/layout/ ... //开始更新decor mDecor.startChanging(); //加载 layoutResource 到 decor 中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //ID_ANDROID_CONTENT就是R.id.content ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... //getContainer()返回的是一个Window对象，它是父activity中的window if (getContainer() == null) { final Drawable background; if (mBackgroundResource != 0) { background = getContext().getDrawable(mBackgroundResource); } else { background = mBackgroundDrawable; } mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) { frame = getContext().getDrawable(mFrameResource); } else { frame = null; } mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) { setTitle(mTitle); } if (mTitleColor == 0) { mTitleColor = mTextColor; } setTitleColor(mTitleColor); } //结束更新 mDecor.finishChanging(); return contentParent;} 上面的代码中根据不同的风格加载不同的布局，这些布局中都有一个id为@android:id/content的控件，比如screen_simple.xml。布局源码位置在/frameworks/base/core/res/res/layout/。然后把加载出来的布局放到mDecor中。 OK到这里mWindow.getDecorView()我们就看完了，它就是创建一个DecorView，然后根据不同的风格加载不同的布局文件，把这些布局文件放到DecorView中。下面我们看一下mWindow.setContentView(subDecor)前面我们知道mWindow就是PhoneWindow所以调用了PhoneWindow中的setContentView方法1234567891011121314151617181920212223242526 public void setContentView(View view) { setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));} public void setContentView(View view, ViewGroup.LayoutParams params) { //mContentParent在mWindow.getDecorView()已经创建了 if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } //是否有转场动画 transitions if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); } else { // 把subDecor也就是前面的FitWindowsLinearLayout添加到mContentParent中 mContentParent.addView(view, params); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true;} mWindow.getDecorView()创建了DecorView和mContentParent，上面的代码吧subDecor放入mContentParent中。最后回到AppCompatDelegateImpl中，找到R.id.content这个容器，把我们的view放到这个容器中。这时候我们可以知道整个activity的布局从外到内：AppCompatActivity-&gt;PhoneWindow-&gt;DecorView-&gt;LinearLayout-&gt;FitWindowLinearLayout-&gt;ViewStubCompat-&gt;ConentFramLayout-&gt;我们的view。 最后一张奇丑无比的图来镇楼","link":"/2019/03/22/technology/UI绘制流程-View-是如何被添加到屏幕上的/"},{"title":"Xfermode实现刮刮卡","text":"想要实现一个刮刮卡的效果，其中的一种方法就是使用图层混合模式Xfermode，想要很好的理解Xfermode，我们需要先结合着谷歌的例子来。 官方的源码我们可以在这里获得 https://github.com/THEONE10211024/ApiDemos/blob/master/app/src/main/java/com/example/android/apis/graphics/Xfermodes.java 将这里面的源码拿到自己的项目中运行我们就可以看到下面这张图片。 先绘制Dst在绘制Src，我们需要知道一点，使用Xfermode混合模式绘制后，受影响的区域永远是我们的src原图像区域。下面我们来看一下这16中混合模式的具体意思12345678910111213141516171819202122232425262728293031323334private static final Xfermode[] sModes = { //所绘制的不会提交到画布上 new PorterDuffXfermode(PorterDuff.Mode.CLEAR), //显示上层绘制的图片 new PorterDuffXfermode(PorterDuff.Mode.SRC), //显示下层绘制的图片 new PorterDuffXfermode(PorterDuff.Mode.DST), //上下层都显示，上层层居上 new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER), //上下层都显示，下层居上 new PorterDuffXfermode(PorterDuff.Mode.DST_OVER), //取两层绘制的交集，显示上层 new PorterDuffXfermode(PorterDuff.Mode.SRC_IN), //取两层绘制的交集，显示下层 new PorterDuffXfermode(PorterDuff.Mode.DST_IN), //取上层绘制的非交集部分，其余部分变成透明 new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT), //取下层绘制的非交集部分，其余部分变成透明 new PorterDuffXfermode(PorterDuff.Mode.DST_OUT), //取上层的交集部分和下层的非交集部分 new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP), //取下层交集部分和上层非交集部分 new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP), //除去两层的交集部分 new PorterDuffXfermode(PorterDuff.Mode.XOR), //取全部区域，交集部分颜色加深 new PorterDuffXfermode(PorterDuff.Mode.DARKEN), //取两图层全部区域，交集部分颜色点亮 new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN), //取两层交集部分，颜色加深 new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY), //取两图层全部区域，交集部分变为透明色 new PorterDuffXfermode(PorterDuff.Mode.SCREEN), }; 知道了上面的属性的意思，我们来想一下我们刮刮卡的思路一个图片上面蒙上一层，手指划过的区域让上层变成透明，就显示出下层的图片了。 我们去上面属性中找，就可以找到DST_OUT这个属性，它的意思是取下层绘制的非交集部分，交集部分变成透明 所以我们可以先绘制一个刮奖层，为dst层，手指一动的路径为src层。设置为DST_OUT属性，那么两者交集的地方就会变成透明了。 当然也可以是用SRC_OUT，使用SRC_OUT就是遮罩层绘制在path上面。使用DST_OUT就是遮罩层绘制在path下面 1234567891011121314151617private void init() { mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(30); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeCap(Paint.Cap.ROUND); //禁止硬件加速 setLayerType(LAYER_TYPE_SOFTWARE,null); //结果图片 mBitmapRes = BitmapFactory.decodeResource(getResources(), R.mipmap.guagua); //遮罩层图片 mSrcBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.gua); //创建一个可绘制path的bitmap mDstBitmap = Bitmap.createBitmap(mSrcBitmap.getWidth(),mSrcBitmap.getHeight(), Bitmap.Config.ARGB_8888); mCanvas = new Canvas(mDstBitmap); } 首先禁止硬件加速，有些手机不支持，然后初始化结果图片，遮罩层图片和一个可绘制path的bitmap 下面分别使用DST_OUT和SRC_OUT两种方式来实现绘制12345678910111213141516171819202122232425 protected void onDraw(Canvas canvas) { super.onDraw(canvas); //绘制结果图片 canvas.drawBitmap(mBitmapRes,0,0,null);// //第一种 先绘制遮罩层在绘制path,path的画笔使用DST_OUT模式// mCanvas.drawBitmap(mSrcBitmap,0,0,null);// mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));// mCanvas.drawPath(mPath,mPaint);// //绘制目标图像// canvas.drawBitmap(mDstBitmap,0,0,null); //第二种//遮罩层绘制在path上面，遮罩层的画笔使用SRC_OUT模式 //新建一个图层，不然会把原始图层也当成dst层了。上面的方法之所以不用起一个新图层，因为遮罩层和path都是绘制在新new的canvas中了。 int layerId = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); //绘制路径 mCanvas.drawPath(mPath,mPaint); //绘制目标图像 canvas.drawBitmap(mDstBitmap,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(mSrcBitmap,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); } 第一种先绘制遮罩层在绘制path,path的画笔使用DST_OUT模式，第二种遮罩层绘制在path上面，遮罩层的画笔使用SRC_OUT模式。 第二种方法使用canvas.saveLayer新建了一个图层，是因为如果不新建一个图层，就会把原始图层当成dst层了。第一种方式，因为我们先new了一个自己的Canvas，然后把遮罩层绘制在了new出来的画布上了，path也是绘制在这个画布上。 最后就是path的路径了，很简单通过onTouchEvent获得123456789101112131415161718192021 public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); switch (event.getAction()){ case MotionEvent.ACTION_DOWN: mEventX = event.getX(); mEventY = event.getY(); mPath.moveTo(mEventX,mEventY); break; case MotionEvent.ACTION_MOVE: float endX = (mEventX+event.getX())/2; float endY = (mEventY+event.getY())/2; //可以用lineTo也可以用quadTo一个是直线一个是以阶贝塞尔曲线 mPath.quadTo(mEventX,mEventY,endX,endY);// mPath.lineTo(event.getX(),event.getY()); mEventX = event.getX(); mEventY = event.getY(); invalidate(); break; } return true; } 如果有需求，当擦除一半的遮罩层后，抬起手自动全部消除，参考鸿洋的博客我们可以统计mDstBitmap的像素数据，被清除的像素变成0。统计为0的像素点跟总的像素点相除，大于某个值之后比如0.5就不绘制遮罩层了。 由于图片可能会很大，所以在子线程中处理统计的操作。在MotionEvent.ACTION_UP中启动线程计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243private Runnable mRunnable = new Runnable() { private int[] mPixels; @Override public void run() { int w = mDstBitmap.getWidth(); int h = mDstBitmap.getHeight(); float wipeArea = 0; float totalArea = w * h; Bitmap bitmap = mDstBitmap; mPixels = new int[w * h]; //拿到所有的像素信息 bitmap.getPixels(mPixels, 0, w, 0, 0, w, h); //遍历统计擦除的区域 for (int i = 0; i &lt; w; i++) { for (int j = 0; j &lt; h; j++) { int index = i + j * w; if (mPixels[index] == 0) { wipeArea++; } } } //根据所占百分比，进行一些操作 if (wipeArea &gt; 0 &amp;&amp; totalArea &gt; 0) { int percent = (int) (wipeArea * 100 / totalArea); if (percent &gt; 50) { isComplete = true; postInvalidate(); } } } }; 最后我们可以在OnMeasure方法中，将我们整个view的大小设置为我们背景图片的大小,就可以在布局文件中愉快的玩耍啦。不然在布局文件中总是已match_parent的形式存在。12345678910111213141516171819202122232425protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 宽的测量规格 int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); // 宽的测量尺寸 int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); // 高度的测量规格 int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); // 高度的测量尺寸 int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); //根据View的逻辑得到，比如TextView根据设置的文字计算wrap_content时的大小。 //这两个数据根据实现需求计算。 int wrapWidth = mBitmapRes.getWidth(); int wrapHeight = mBitmapRes.getHeight(); // 如果是是AT_MOST则对哪个进行特殊处理 if(widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, wrapHeight); }else if(widthSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, heightSpecSize); }else if(heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(widthSpecSize, wrapHeight); }} 最终效果图和源码： 源码位置","link":"/2019/03/27/technology/Xfermode实现刮刮卡/"},{"title":"RecycleView的绘制流程","text":"RecycleView的绘制流程 RecycleView继承自ViewGroup，绘制流程肯定也是遵循View的，测量(onMeasure),布局(onLayout),绘制(onDdraw)三大流程。所以从这三个地方开始查看，本篇是27.1.1版本的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182protected void onMeasure(int widthSpec, int heightSpec) { //mLayout是LayoutManager如果为null，就走默认测量然后返回 if (mLayout == null) { defaultOnMeasure(widthSpec, heightSpec); return; } //是否自动测量，比如常用的LinearLayoutManager和GridLayoutManager中默认直接返回true if (mLayout.isAutoMeasureEnabled()) { //获取长宽的测量规格 final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //内部还是调用了mRecyclerView.defaultOnMeasure走默认测量 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); //判断宽高的测量模式是不是精确测量 final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //如果测量模式是精确值比如match_partent，写死的值或者adapter是null，结束测量 if (measureSpecModeIsExactly || mAdapter == null) { return; } 如果测量步骤是开始 if (mState.mLayoutStep == State.STEP_START) { //布局的第一步，更新适配器，决定运行哪个动画，保存有关当前视图的信息，如果有必要，运行预测布局并保存其信息。 dispatchLayoutStep1(); } // 在第二步设置尺寸，预布局和旧尺寸要一致 mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; dispatchLayoutStep2(); //现在可以从子元素中得到宽和高 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); // 如果RecyclerView 没有精确的高度和宽度，并且只有一个孩子 // 我们需要重新测量 if (mLayout.shouldMeasureTwice()) { mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); } } else { //如果子view的大小不影响recycleview的大小 if (mHasFixedSize) { mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); return; } // 自定义测量 if (mAdapterUpdateDuringMeasure) { startInterceptRequestLayout(); onEnterLayoutOrScroll(); processAdapterUpdatesAndSetAnimationFlags(); onExitLayoutOrScroll(); if (mState.mRunPredictiveAnimations) { mState.mInPreLayout = true; } else { // consume remaining updates to provide a consistent state with the layout pass. mAdapterHelper.consumeUpdatesInOnePass(); mState.mInPreLayout = false; } mAdapterUpdateDuringMeasure = false; stopInterceptRequestLayout(false); } else if (mState.mRunPredictiveAnimations) { setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); return; } if (mAdapter != null) { mState.mItemCount = mAdapter.getItemCount(); } else { mState.mItemCount = 0; } startInterceptRequestLayout(); mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); stopInterceptRequestLayout(false); mState.mInPreLayout = false; // clear } } 从上面的代码来看，先判断LayoutManager是否为null，如果是结束测量，然后判断测量模式是不是精确模式，也就是布局文件中设置match_parent和写死固定值，如果是结束测量。如果是wrap_content继续执行下面的方法。 如果是刚开始测量的状态，执行 dispatchLayoutStep1()方法，如果判断不是精准模式，在执行dispatchLayoutStep2()方法。dispatchLayoutStep1()主要是做一些清空和初始化操作，dispatchLayoutStep2()是真正的测量子view的宽高来决定recycleview的宽高。 初始化操作的代码就不看了，从dispatchLayoutStep1()的注释来看主要做了以下步骤：1. adapter的更新 2.决定应该运行哪个动画 3. 保存视图当前的信息 4. 如果需要，运行预测布局并保存信息。 下面来看dispatchLayoutStep2()方法 1234567891011121314151617181920212223private void dispatchLayoutStep2() { //开始中断布局请求 startInterceptRequestLayout(); onEnterLayoutOrScroll(); //设置状态为 布局和动画状态 mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; // 开始布局 mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; mPendingSavedState = null; // 是否禁用动画 mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; mState.mLayoutStep = State.STEP_ANIMATIONS; onExitLayoutOrScroll(); stopInterceptRequestLayout(false);} 从上面代码可以看到，开始布局那mLayout是LayoutManager对象，调用了LayoutManager中的onLayoutChildren方法，所以从这里我们可以知道，最终的布局是交给LayoutManager来完成的，系统提供了三个LayoutManager，线性的，网格的和瀑布流的，我们也可以自己继承LayoutManager来实现我们自己的LayoutManager。 所有item的布局都是在onLayoutChildren中实现，下面看LinearLayoutManager中的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { // layout algorithm: // 1) 通过检子view和其他变量找到一个锚点坐标和锚点位置 // 2) 从底部开始填充 // 3) 从顶部开始填充 // 4) 处理2和3两种方式的滚动 ...... final View focused = getFocusedChild(); if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) { mAnchorInfo.reset(); mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // 计算锚点的位置 updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; }else{......} ...... //一般情况下会选取最上（反向布局则是最下）的子View作为锚点参考 if (mAnchorInfo.mLayoutFromEnd) { // 更新锚点坐标 updateLayoutStateToFillStart(mAnchorInfo); //设置开始位置 mLayoutState.mExtra = extraForStart; //开始填充 fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; final int firstElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) { extraForEnd += mLayoutState.mAvailable; } // 更新锚点坐标 updateLayoutStateToFillEnd(mAnchorInfo); //设置结束位置 mLayoutState.mExtra = extraForEnd; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; //开始填充 fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) { // end could not consume all. add more items towards start extraForStart = mLayoutState.mAvailable; updateLayoutStateToFillStart(firstElement, startOffset); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; } }else{ ...... } ......} 这段代码比较多，本篇省略缓存的部分，只看绘制，主要是通过子view和其他变量找到锚点信息，通过锚点信息判断出是从下往上填充还是从上往下填充，updateLayoutStateToFillStart和updateLayoutStateToFillEnd不断更新锚点的值，其实就是计算屏幕的上方或者下方是否还有剩余的空间，在调用fill方法填充的时候，如果空间不足就不会执行填充的方法。然后在fill(recycler, mLayoutState, state, false)方法中填充View。 mAnchorInfo是AnchorInfo类用来保存锚点的信息，它有三个主要变量 int mPosition;//锚点参考view在整个布局中的位置，是第几个 int mCoordinate; //锚点的起始坐标 boolean mLayoutFromEnd; 是否从尾部开始布局默认是false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /** * 填充由layoutState给定的布局，它独立于LinearLayoutManager之外，稍微改一下可以用于我们的自定义的LayoutManager * @param recycler 当前的回收对象 * @param layoutState 记录如何填充空间 * @param state 控制滚动的步骤 * @param stopOnFocusable 如果为true，则在第一个可聚焦的新子元素中停止填充 * @return 它添加的像素数。适用于滚动函数 */int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) { // 我们应该设置最大偏移量是 mFastScroll + available final int start = layoutState.mAvailable; if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) { // TODO ugly bug fix. should not happen if (layoutState.mAvailable &lt; 0) { layoutState.mScrollingOffset += layoutState.mAvailable; } //回收掉已经滑出屏幕的View recycleByLayoutState(recycler, layoutState); } int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; //循环填充：进入条件有足够的空白空间和有更多数据 while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) { layoutChunkResult.resetInternal(); if (VERBOSE_TRACING) { TraceCompat.beginSection(\"LLM LayoutChunk\"); } //向屏幕上填充一个View layoutChunk(recycler, state, layoutState, layoutChunkResult); if (VERBOSE_TRACING) { TraceCompat.endSection(); } if (layoutChunkResult.mFinished) { break; } layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; /** * Consume the available space if: * * layoutChunk did not request to be ignored * * OR we are laying out scrap children * * OR we are not doing pre-layout */ if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null || !state.isPreLayout()) { //如果进行了填充，减去填充使用的空间 layoutState.mAvailable -= layoutChunkResult.mConsumed; // 保留一个单独的剩余空间，因为mAvailable对于回收非常重要 remainingSpace -= layoutChunkResult.mConsumed; } if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) { layoutState.mScrollingOffset += layoutChunkResult.mConsumed; if (layoutState.mAvailable &lt; 0) { layoutState.mScrollingOffset += layoutState.mAvailable; } recycleByLayoutState(recycler, layoutState); } if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) { break; } } if (DEBUG) { validateChildOrder(); } return start - layoutState.mAvailable; } fill()方法中回收移除不可见的View，在屏幕上堆叠出可见的Viw，堆叠的原理就是看看当前界面有没有剩余的空间，如果有就拿一个新的View填充上去，填充工作使用layoutChunk(recycler, state, layoutState, layoutChunkResult)方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) { //找到将要布局的View,先从缓存中找找不到在创建 View view = layoutState.next(recycler); ...... LayoutParams params = (LayoutParams) view.getLayoutParams(); //如果ViewHolder的列表不为null if (layoutState.mScrapList == null) { if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) { //添加view，最终调用ViewGroup的addView方法 addView(view); } else { //添加view， 最终调用ViewGroup的addView方法 addView(view, 0); } } else { if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) { //将要消失的view addDisappearingView(view); } else { //将要消失的view addDisappearingView(view, 0); } } //测量子view measureChildWithMargins(view, 0, 0); result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; //横排和竖排不同模式下 子view的四个边的边距 if (mOrientation == VERTICAL) { if (isLayoutRTL()) { right = getWidth() - getPaddingRight(); left = right - mOrientationHelper.getDecoratedMeasurementInOther(view); } else { left = getPaddingLeft(); right = left + mOrientationHelper.getDecoratedMeasurementInOther(view); } if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) { bottom = layoutState.mOffset; top = layoutState.mOffset - result.mConsumed; } else { top = layoutState.mOffset; bottom = layoutState.mOffset + result.mConsumed; } } else { top = getPaddingTop(); bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view); if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) { right = layoutState.mOffset; left = layoutState.mOffset - result.mConsumed; } else { left = layoutState.mOffset; right = layoutState.mOffset + result.mConsumed; } } //布局这个子view layoutDecoratedWithMargins(view, left, top, right, bottom); ...... } layoutChunk方法就是找到一个子view，寻找子view是先去缓存中寻找找不到在通过调用createViewHolder()创建一个新的，缓存的逻辑此篇不往下看，只看绘制流程 找到view之后，通过addView方法，加入到ViewGroup中 通过measureChildWithMargins方法测量一个子view，会把我们通过recycleview.addItemDecoration方法设置的分割线的大小也计算进去，之后计算子view的四个边的边距 最后通过layoutDecoratedWithMargins方法布局一个子view。layoutDecoratedWithMargins中调用就是view的layout方法。 到此dispatchLayoutStep2()这个方法算是看完了，到此所有子view的测量（measure）和布局（layout），然后执行dispatchLayoutStep2()这个方法后面的方法 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec) 根据子view的大小来设置自身（RecycleView）的大小。 RecycleView的onMeasure方法看完了，下面来看一下它的onLayout方法。123456protected void onLayout(boolean changed, int l, int t, int r, int b) { TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true; } 里面调用了 dispatchLayout()方法12345678910111213141516171819202122232425262728void dispatchLayout() { if (mAdapter == null) { Log.e(TAG, &quot;No adapter attached; skipping layout&quot;); // leave the state in START return; } if (mLayout == null) { Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;); // leave the state in START return; } mState.mIsMeasuring = false; //如果状态还是开始状态，那么从新走一遍dispatchLayoutStep1();和dispatchLayoutStep2(); if (mState.mLayoutStep == State.STEP_START) { dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) { // 数据更改后重新执行dispatchLayoutStep2(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); } else { // 确保是精准模式 mLayout.setExactMeasureSpecsFrom(this); } dispatchLayoutStep3(); } 在onMeasure的源码中我们知道，如果RecycleView设置的是精准模式（比如match_partent，写死的值）就直接返回了，那么它的状态还是State.STEP_START，到了onLayout方法后还是会执行dispatchLayoutStep1()和dispatchLayoutStep2()方法。 也就是说如果RecycleView设置的wrap_content，那么就先去测量和布局子view，根据子view的宽高来确定自身的宽高，反之如果RecycleView设置的是精准模式，就在onLayou中去测量和布局子veiw。 这里有出来一个dispatchLayoutStep3()，第三步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private void dispatchLayoutStep3() { mState.assertLayoutStep(State.STEP_ANIMATIONS); startInterceptRequestLayout();//开始中断布局 onEnterLayoutOrScroll(); mState.mLayoutStep = State.STEP_START; if (mState.mRunSimpleAnimations) { // 找到当前的位置，并处理更改动画 for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) { ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore()) { continue; } long key = getChangedHolderKey(holder); final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) { //运行一个变更动画 final boolean oldDisappearing = mViewInfoStore.isDisappearing( oldChangeViewHolder); final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) { // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); } else { final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( oldChangeViewHolder); // we add and remove so that any post info is merged. mViewInfoStore.addToPostLayout(holder, animationInfo); ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); if (preInfo == null) { handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); } else { animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); } } } else { mViewInfoStore.addToPostLayout(holder, animationInfo); } } // 触发动画 mViewInfoStore.process(mViewInfoProcessCallback); } mLayout.removeAndRecycleScrapInt(mRecycler); mState.mPreviousLayoutItemCount = mState.mItemCount; mDataSetHasChangedAfterLayout = false; mDispatchItemsChangedEvent = false; mState.mRunSimpleAnimations = false; mState.mRunPredictiveAnimations = false; mLayout.mRequestedSimpleAnimations = false; if (mRecycler.mChangedScrap != null) { mRecycler.mChangedScrap.clear(); } if (mLayout.mPrefetchMaxObservedInInitialPrefetch) { // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); } //布局完成 mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) { dispatchOnScrolled(0, 0); } recoverFocusFromState(); resetFocusInfo(); } 可以看到，dispatchLayoutStep3()主要做了一些收尾的工作，这是布局的最后一步，保存视图和动画的信息，并做一些清理的工作。 onLayout方法就完了，最后看onDraw()方法12345678public void onDraw(Canvas c) { super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) { mItemDecorations.get(i).onDraw(c, this, mState); }} onDraw方法很简单，就是绘制分割线，我们通过recycleview.addItemDecoration方法设置的分割线就在这里开始绘制，调用的是我们自定义分割线的时候里面写的onDraw方法。绘制的区域就是我们在自定义分割线的时候重写的getItemOffsets方法中的设置的偏移。这部分的测量工作在dispatchLayoutStep2()-&gt;onLayoutChildren-&gt;fill-&gt;layoutChunk-&gt;measureChildWithMargins这个方法中。12345678910111213141516171819public void measureChildWithMargins(View child, int widthUsed, int heightUsed) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //获取装饰线条 就是我们添加的分割线 final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child); widthUsed += insets.left + insets.right; heightUsed += insets.top + insets.bottom; //计算长和宽的测量模式 加上margin，padding 和 分隔线的长宽 final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, canScrollHorizontally()); final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, canScrollVertically()); if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) { child.measure(widthSpec, heightSpec); } } 上面代码中就是获取线条的长宽，然后子veiw的可使用的宽高要减去这部分的值。 OK到这里RecycleView的绘制流程查看完成。 参考文章 https://www.jianshu.com/p/f91b41c8f487 https://www.jianshu.com/p/0c41bf63072a https://www.jianshu.com/p/616ca453aa17 https://www.jianshu.com/p/8fa71076179d","link":"/2019/04/05/technology/RecycleView的绘制流程/"},{"title":"Android事件分发机制","text":"Android事件分发机制 想要了解Android的事件分发机制，首先需要知道事件是从哪里开始的。从之前的一篇文章View是如何被添加到屏幕上的的最后一幅图，可以知道，我们打开一个界面后，界面的层级从顶层开始是 Activity-&gt;PhoneWindow-&gt;DecorView-&gt;… 所以当我们手指点击到屏幕上之后，事件的分发也是在Activity中开始。执行Activity中的dispatchTouchEvent方法那就从这里开始看1234567891011121314public boolean dispatchTouchEvent(MotionEvent ev) { //如果是DOWN事件 if (ev.getAction() == MotionEvent.ACTION_DOWN) { //此方法里面是空的，可以重写此方法 onUserInteraction(); } //如果getWindow().superDispatchTouchEvent(ev)返回true //那么dispatchTouchEvent方法就返回true //反之就执行activity的onTouchEvent方法 if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev);} 首先判断是不是DOWN事件，如果是执行onUserInteraction()，这个方法里面啥也没有，我们可以重写这个方法来实现我们的关于DOWN事件的逻辑。 然后调用getWindow().superDispatchTouchEvent(ev)，如果它返回true，那么dispatchTouchEvent就返回true。如果返回false，就执行activity的onTouchEvent方法。 Activity的onTouchEvent方法很简单，如果一个事件没有被Activity下的任何一个veiw接受就结束返回true，只有点击到Window外面才会返回true，一般情况下都返回false。12345678public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 下面来看看getWindow().superDispatchTouchEvent(ev)这个方法，getWindow()方法返回一个Window对象，它是一个抽象类，只有一个子类那就是PhoneWindow，所以无PhoneWindow中查看superDispatchTouchEvent(ev)方法123public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } mDecor是一个DecorView对象，public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks,DecorView继承自FrameLayout，所以它也是一个ViewGroup它是我们一个页面的最顶级的View。点进DecorView中可以看到123public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } 它直接调用了其父类的dispatchTouchEvent方法，继续跟进就进入到了ViewGroup中的dispatchTouchEvent方法了。 现在我们知道，当我们点击屏幕的时候，事件通过Activity传递到PhoneWindow在传递到ViewGroup中开始真正的分发。下面开始查看ViewGroup中的dispatchTouchEvent方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; //安全验证 if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //开始处理一个DOWN事件 if (actionMasked == MotionEvent.ACTION_DOWN) { //当开始处理一个DOWN事件的时候，清除掉之前的所有的事件和标志位 cancelAndClearTouchTargets(ev); resetTouchState(); } //定义一个boolean类型的变量记录是否拦截事件 final boolean intercepted; //如果是DOWN事件并且当前触摸的对象mFirstTouchTarget不为空 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //disallowIntercept可以拦截除了Down事件以外的事件，因为前面的DOWN中清空了所有标志位 //FLAG_DISALLOW_INTERCEPT可以通过requestDisallowInterceptTouchEvent方法来更改。一般是子view调用这个方法。 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { //onInterceptTouchEvent默认返回false，不拦截事件 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { //没有触摸目标或者不是DOWN事件，说明拦截 intercepted = true; } // 如果拦截了，就进行正常的事件分发 // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // 检查是否取消 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; //定义一个新的触摸对象 TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //如果没取消，并且不拦截事件 if (!canceled &amp;&amp; !intercepted) { View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; //清理指针id防止不同步 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; //如果新的触摸对象为空并且子view个数大于0 if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); //找到一个可以接收事件的子节点 // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //倒叙遍历子view for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); //如果view是可获取焦点的 if (childWithAccessibilityFocus != null) { //当前view不可获取焦点 if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //如果view是不可见状态或者在执行动画，或者触摸范围不是在view的范围之内，就跳出循环继续循环下面的 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } //找到当前触摸的view newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { //子view在触摸范围内，在给它一个标志位 newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //dispatchTransformedTouchEvent分发事件，如果child不为null,就调用child的dispatchTouchEvent方法， //child为null就调用父类的dispatchTouchEvent方法。 //返回值就是子veiw是否处理事件 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //addTouchTarget方法给mFirstTouchTarget赋值，addTouchTarget指向当前的子view。 //所以如果所有子view都不消耗事件，mFirstTouchTarget就为null newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // mFirstTouchTarget == null表示没有子veiw消耗事件 if (mFirstTouchTarget == null) { // 就把它当成一个普通的veiw来执行dispatchTransformedTouchEvent方法 //第三个参数传null，进去后会调用父类的dispatchTouchEvent方法， //最终调用onTouchEvent方法来处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; //如果DOWN事件处理完毕 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; 除了DOWN事件的其余事件分发给子view处理 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 上面就是ViewGroup的事件分发的流程，重要部分都做了注释，总结一下就是，dispatchTouchEvent方法中，onInterceptTouchEvent方法是否拦截事件，默认不拦截，想要拦截我们需要重写此方法。如果拦截就通过dispatchTransformedTouchEvent方法调用自身的onTouchvent()方法，否则就还是通过dispatchTransformedTouchEvent方法调用子view的dispatchTouchEvent方法。如果子view还是ViewGroup，那么重复上面的调用流程，如果子view是View，那么执行View的dispatchTouchEvent方法。下面去看一下View的dispatchTouchEvent方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) { //焦点的判断 if (event.isTargetAccessibilityFocus()) { // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) { return false; } // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); } boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); //5.0以后的嵌套滑动 if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture stopNestedScroll(); } //安全判断 if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //我们是否设置了mOnTouchListener，如果设置了执行它的onTouch方法 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } //执行onTouchEvent方法。到这里我们知道没如果我们设置了一个view的 //mOnTouchListener方法，那么先执行它的onTouch方法，返回false才执行onTouchEvent if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result; } View的dispatchTouchEvent方法就简单多了，首先判断我们有没有设置OnTouchListener方法，如果设置了就执行它的Touch方法，只有Touch方法返回false的时候，才会继续去执行View的onTouchEvent方法。所以我们知道OnTouchListener的优先级高于onTouchEvent。 OK事件分发看完了，下面去View的onTouchEvent看一下事件的处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //是否是可点击的 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //如果一个vew设置了点击事件或者长按事件，即使它是DISABLED的， //也会消费这个事件，只是不响应。也就是这里直接返回true，但是下面的代码都不执行了。 return clickable; } //如果view设置了代理执行下面的方法 if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //如果是可点击的，就开始处理ACTION_UP，ACTION_DOWN，ACTION_CANCEL，ACTION_MOVE事件。 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // 按钮在我们之前就被释放了 // 按下显示。让它显示被压的 // 现在状态(在调度单击之前)以确保用户可以看到它。 setPressed(true, x, y); } //如果没有处理长按事件或者长按事件返回了false //mHasPerformedLongPress在DOWN的时候置为false,在DOWN中 //监测是否有长按事件，如果有长按事件mHasPerformedLongPress会置为true if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // 如果没有长按事件，移除掉长按的回调 removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { //使用Runnable来执行一个点击事件，而不是直接执行 if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } //是否处理长按事件 mHasPerformedLongPress = false; if (!clickable) { //监测长按事件 checkForLongClick(0, x, y); break; } if (performButtonActionOnTouchDown(event)) { break; } // 是否在一个滚动容器中 boolean isInScrollingContainer = isInScrollingContainer(); // 如果是在容器中，发送一个100毫秒的延时post //在其run方法中监测长按事件 if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // 如果不在容器中，直接检查长按事件 //长按事件的监测，发送一个500毫秒的延时post， //在run方法中如果检测到是长按就给上面的mHasPerformedLongPress标志位赋值为true setPressed(true, x, y); checkForLongClick(0, x, y); } break; case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; } break; } return true; } return false; } onTouchEvent方法中，只要CLICKABLE和LONG_CLICKABLE有一个为true就消费这个事件，在DOWN方法中处理长按事件，在UP方法中处理点击事件。LONG_CLICKABLE默认为false,CLICKABLE的值跟具体的view有关，比如Button默认是true,TextView默认是false。通过setClickable和setLongClickable可以改变这两个值。setOnClickListener和setOnLongClickListener会把这两个值设置为true。 OK，View的事件分发的源码查看完毕，看一下流程图 总结一下： 一个事件序列是从手指按下屏幕(ACTION_DOWN)开始，到手指离开屏幕(ACTION_UP)结束，中间有一系列的(ACTION_MOVE)事件，非人为的结束事件会走到ACTION_CANCEL中 正常情况下一个事件序列只能由一个View拦截消耗，因为某一个View一旦决定拦截事件，那么这个事件就只能由它来处理。并且它的onInterceptTouchEvent方法不会在被调用。 一旦一个View开始处理事件，如果它不消耗ACTION_DOWN事件，也就是onTouchEvent返回了false，那么同一个事件序列中的其他事件都不会再交给他处理，并且把事件重新交给它的父容器来处理。父容器的onTouchEvent方法会被调用。 事件的分发过程是由外到内的，事件总是先传递到父容器，在由父容器分发给子View,子View可以通过requestDisallowInterceptTouchEvent方法来干预父容器的执行，ACTION_DOWN事件除外，因为它会在ACTION_DOWN事件中清空标志位。 ViewGroup中的onInterceptTouchEvent方法默认返回false，所有ViewGroup默认不拦截任何事件。而View中没有onInterceptTouchEvent方法，一旦有事件传递给它，它的onTouchEvent方法就会被调用。 View的onTouchEvent方法默认返回true，也就是默认处理事件，除非它是不可点击的(clickable和longClickable都为false)。LONG_CLICKABLE默认为false,CLICKABLE的值跟具体的view有关，比如Button默认是true,TextView默认是false。通过setClickable和setLongClickable可以改变这两个值。setOnClickListener和setOnLongClickListener会把这两个值设置为true。 View的enable属性不会影响onTouchEvent的默认返回值，即使它是enable状态，clickable和longClickable只要有一个为true，那么它的onTouchEvent就返回true。 onClick会响应的前提是，View是可点击的，并且收到了ACTION_DOWN和ACTION_UP事件，当长按事件返回true的时候，onClick是不会响应的。 onLongClick是在ACTION_DOWN中判断的，想要执行长按事件，longClickable需要为true。","link":"/2019/03/31/technology/Android事件分发机制/"},{"title":"QQ红点拖拽效果","text":"今天来做一下QQ列表上的红点拖拽效果 思路：首先我们得给小圆点定义一些状态，默认状态，手指点上去的状态，手指一动时的状态，手指松开时的状态。在onTouchEvent方法中更新状态值，最后在onDraw中根据不同的状态值绘制圆和path。思路很简单，就是绘制的时候我们需要把中学时候学的几何数学拿来用一下啦。 先定义一些成员变量,把状态啊，画笔啊，半径啊，原点等都初始化好然后在开始，具体可以到最下面点击源码查看 先看onDraw方法 首先，只要不是爆炸状态，我们都需要绘制移动的圆点和上面的数字。123456//只要不是爆炸的情况都要绘制圆和字 if (mState != BUBBLE_STATE_BLAST) { canvas.drawCircle(mMovePoint.x, mMovePoint.y, mMoveRadius, mBubblePaint); mTextPaint.getTextBounds(mText, 0, mText.length(), mTextRect); canvas.drawText(mText, mMovePoint.x - mTextRect.width() / 2, mMovePoint.y + mTextRect.height() / 2, mTextPaint); } 然后就是当我们手指点到圆上开始拖拽的的状态，这时候我们需要绘制一个静止的圆和一个移动的圆，当两个圆小于一定的距离的时候，我们需要在他们之间绘制一个黏性的效果，其实就是绘制两条二街贝塞尔曲线。 绘制贝塞尔曲线的时候，需要求曲线的起始点，结束点和控制点的坐标，这时候会用到中学几何数学的小知识 计算角度 在直角三角形中,非直角的sin值等于对边长比斜边长.使用勾股定理计算即可。sinA=对边/斜边 cosB=邻边/斜边 tanA=对边/邻边 看着下面的图绘制会更清晰 123456789101112131415161718192021222324252627282930313233343536//链接状态绘制静止的圆和赛贝尔曲线 if (mState == BUBBLE_STATE_CLICK) { //绘制静止的圆 canvas.drawCircle(mQuitPoint.x, mQuitPoint.y, mQuitRadius, mBubblePaint); //绘制贝塞尔曲线 //找到控制点 float controlX = (mMovePoint.x + mQuitPoint.x) / 2; float controlY = (mMovePoint.y + mQuitPoint.y) / 2; //计算角度 在直角三角形中,非直角的sin值等于对边长比斜边长.使用勾股定理计算即可 //sinA=对边/斜边 cosB=邻边/斜边 tanA=对边/邻边 float sinThet = (mMovePoint.y - mQuitPoint.y) / mDist; float cosThet = (mMovePoint.x - mQuitPoint.x) / mDist; //A点 float ax = mQuitPoint.x - mQuitRadius * sinThet; float ay = mQuitPoint.y + mQuitRadius * cosThet; //B点 float bx = mMovePoint.x - mMoveRadius * sinThet; float by = mMovePoint.y + mMoveRadius * cosThet; //C点 float cx = mMovePoint.x + mMoveRadius * sinThet; float cy = mMovePoint.y - mMoveRadius * cosThet; //D点 float dx = mQuitPoint.x + mQuitRadius * sinThet; float dy = mQuitPoint.y - mQuitRadius * cosThet; //设置path的路径 mBezierPath.reset(); mBezierPath.moveTo(ax, ay); mBezierPath.quadTo(controlX, controlY, bx, by); mBezierPath.lineTo(cx, cy); mBezierPath.quadTo(controlX, controlY, dx, dy); mBezierPath.close(); canvas.drawPath(mBezierPath, mBubblePaint); } 找到各个点之后就简单了，使用path的api将各个点连接起来，最后绘制就ok。 最后是爆炸状态,我们在初始化的时候定义一个有5张爆炸小图片的bitmap数组，使用属性动画控制数组的下标，然后循环绘制这几张图片。12345678//爆炸状态绘制爆炸图片 if (mState == BUBBLE_STATE_BLAST &amp;&amp; mBlastIndex &lt; mBlastDrawablesArray.length) { mBlastRect.left = mMovePoint.x - mMoveRadius; mBlastRect.top = mMovePoint.y - mMoveRadius; mBlastRect.right = mMovePoint.x + mMoveRadius; mBlastRect.bottom = mMovePoint.y + mMoveRadius; canvas.drawBitmap(mBlastBitmapsArray[mBlastIndex], null, mBlastRect, mBlastPaint); } OK 下面是onTouchEvent中，我们需要根据手指的各种事件来切换当前的状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean onTouchEvent(MotionEvent event) { float x = event.getRawX(); float y = event.getRawY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: //勾股定理算出点击位置和静止圆的圆心距离 mDist = (float) Math.hypot(x - mQuitPoint.x, y - mQuitPoint.y); if (mState == BUBBLE_STATE_DEFAULT) { //如果手指点击到了圆上或者圆的附近 if (mDist &lt; mMoveRadius + MOVE_OFFSET) { mState = BUBBLE_STATE_CLICK; } } break; case MotionEvent.ACTION_MOVE: if (mState != BUBBLE_STATE_DEFAULT) { //勾股定理算出点击位置和静止圆的圆心距离,也就是手指一动的距离 mDist = (float) Math.hypot(x - mQuitPoint.x, y - mQuitPoint.y); mMovePoint.x = event.getRawX(); mMovePoint.y = event.getRawY(); //如果手指点击到了圆上或者圆的附近 if (mState == BUBBLE_STATE_CLICK) { //手指一动的距离小于我们定义的一个最大的距离，就绘制贝塞尔曲线，反之就是分离状态 if (mDist &lt; mMaxDist - MOVE_OFFSET) { mQuitRadius = (mMoveRadius - mDist / 8); } else { mState = BUBBLE_STATE_BREAK; } } } invalidate(); break; case MotionEvent.ACTION_UP: //如果还没断开直接返回原状 if (mState == BUBBLE_STATE_CLICK) { //执行回弹动画 startBackAnim(); } //断开了 else if (mState == BUBBLE_STATE_BREAK) { //如果断开了，小球的位置移动到距离2倍移动小球的距离以内也返回原状 if (mDist &lt; mMoveRadius * 2) { //执行回弹动画 startBackAnim(); } else { mState = BUBBLE_STATE_BLAST; //执行爆炸动画 startBlastAnim(); } } break; default: } return true; } DOWN事件，如果我们的手指点击到圆上或者圆的附近(附近使用一个偏移量MOVE_OFFSET来定义)，就把状态改成点击连接的状态 MOVE事件，判断手指移动动的距离小于我们定义的一个最大的距离，就绘制贝塞尔曲线和静止的圆，反之就定义为分离状态。 UP事件，如果静止圆和移动圆还没断开直接返回原状，执行回弹动画，如果已经断开了，在判断如果移动的圆这时候移动到了原来的点的一定范围内，就还需要回到原点，执行回弹动画，反之就执行爆炸动画。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//爆炸动画private void startBlastAnim() { ValueAnimator animator = ValueAnimator.ofInt(0, 5); animator.setDuration(500); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mBlastIndex = (int) animation.getAnimatedValue(); invalidate(); } }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); if(mOnExecuteFinishListener!=null){ mOnExecuteFinishListener.onFinish(EXECUTE_STATE_BLAST); } } }); animator.start(); } //回弹动画 private void startBackAnim() { PointF start = new PointF(mMovePoint.x, mMovePoint.y); PointF end = new PointF(mQuitPoint.x, mQuitPoint.y); //系统的PointFEvaluator只能支持21以上的,编译不通过。所以自己弄了一个把它代码抄过来就行啦 ValueAnimator animator = ValueAnimator.ofObject(new MyPointFEvaluator(), start, end); animator.setDuration(200); animator.setInterpolator(new OvershootInterpolator(5f)); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mMovePoint = (PointF) animation.getAnimatedValue(); invalidate(); } }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); mState = BUBBLE_STATE_DEFAULT; if(mOnExecuteFinishListener!=null){ mOnExecuteFinishListener.onFinish(EXECUTE_STATE_BACK); } } }); animator.start(); } 最后就是两个简单的属性动画，爆炸动画用来控制我们的bitmap数组的index值。回弹动画来控制两个点的移动，使用系统默认的插值器OvershootInterpolator(运动到终点后，冲过终点后再回弹)。 这里的PointFEvaluator这个估值器系统有提供，但是只支持5.0以上，所以自定了一个PointFEvaluator，把系统的源码抄一下即可。 OK到这里效果就出来了可以看下图 效果出来了，那怎么用呢，现在是在我们自定义的view中可以全屏拖动绘制，但是如果把这个veiw放到列表中怎么办呢，只能在列表的那一条区域中拖拽吗，当然不符合我们的预期 思路就是，当我们点击列表中的红点的时候，通过当前的Window对象拿到我们的跟布局DecorView，然后把我们自定义的view放到跟布局中，把当前的textview设置隐藏，然后在我们的自定义view的手指点击的地方开始绘制圆就可以了 这里需要注意onTouchEvent获取坐标使用event.getRawX()和event.getRawY()，不能使用event.getX()和event.getY()了，因为我们现在的自定义veiw和点击的textveiw不在一个布局中。getRawX()是相对于屏幕来说的而getX()是相对于父布局来说的。 所以我们在textvew的onTouchListener中，找到DecorView，然后把我们的自定义view放进去，最后把事件传递到我们的自定义view中就好了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class QQViewListenter implements View.OnTouchListener , QQBubbleView.OnExecuteFinishListener { private Context mContext; private ViewGroup mViewGroup; private QQBubbleView mQQBubbleView; private View currentClickView; public QQViewListenter(Context context) { mContext = context; Window window = ((Activity) context).getWindow(); mViewGroup = (ViewGroup) window.getDecorView(); mQQBubbleView = new QQBubbleView(context); } @Override public boolean onTouch(View v, MotionEvent event) { currentClickView = v; Log.e(\"onTouch\",\"x--\"+event.getRawX()+\"y--\"+event.getRawY()+\"--event\"+event.getAction()); if (event.getAction() == MotionEvent.ACTION_DOWN) { if(mViewGroup!=null){ mViewGroup.addView(mQQBubbleView); } ViewParent parent = v.getParent(); if (parent == null) { return false; } if(v instanceof TextView){ String text = ((TextView) v).getText().toString(); mQQBubbleView.setText(text); } //防止父容器消费事件 parent.requestDisallowInterceptTouchEvent(true); int width = v.getWidth(); mQQBubbleView.setCenter(event.getRawX(),event.getRawY(),width/2); mQQBubbleView.setOnDismissListener(this); currentClickView.setVisibility(View.INVISIBLE); } //事件传递 mQQBubbleView.onTouchEvent(event); return true; } @Override public void onFinish(int type) { if(mViewGroup!=null&amp;&amp;mQQBubbleView!=null){ mViewGroup.removeView(mQQBubbleView); } if(type == EXECUTE_STATE_BACK){ currentClickView.setVisibility(View.VISIBLE); }else { currentClickView.setVisibility(View.GONE); } }} OnExecuteFinishListener是我们自顶一个view中定义的一个接口，用来监听手指抬起之后的的状态结果，因为完事后我们需要移除我们添加到DecorView中的我们自己的veiw。 使用的时候，我们在Adapter中的textveiw设置setOnTouchListener监听传入我们上面写的QQViewListenter即可。 最终效果： 源码位置","link":"/2019/03/30/technology/QQ红点拖拽效果/"},{"title":"UI绘制流程--View的绘制流程","text":"上一篇UI绘制流程–View是如何被添加到屏幕上的我们学习了View是怎么添加到屏幕上的，这一片来学习View绘制流程，它的入口在入口ActivityThread.handleResumeActivity()。 本篇基于9.0的源码以前的一篇文章 Activity启动流程，最后我Activity启动的最后走到了ActivityThread中执行handleResumeActivity方法并里面执行了activity的onResume方法我们在来看这个方法1234567891011121314151617181920212223242526public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... final Activity a = r.activity; ... final Activity a = r.activity; ... //获取Window也就是PhoneWindow r.window = r.activity.getWindow(); //获取PhoneWindow中的DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); //获取PhoneWindow的参数 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ... a.mWindowAdded = true; wm.addView(decor, l); ... Looper.myQueue().addIdleHandler(new Idler()); } 代码中performResumeActivity就是去执行activity的onResume方法，之后创建了一个ViewManager ，然后拿到WindowManager的LayoutParams，最后通过addView方法把DecorView和LayoutParams放入ViewManager中。那ViewManager是什么呢 从这里我们可以知道，view的添加和绘制是onResume之后才开始的，所以onResume的时候我们是拿不到View的宽和高的 我们看到它是通过a.getWindowManager()获得，a是activity，那就去activity中找一下这个方法123public WindowManager getWindowManager() { return mWindowManager; } 这里直接返回了activity的一个成员变量mWindowManager，那我们去找一下这个成员变量的赋值的地方，可以找到一个set方法1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 可以看到是调用了WindowManagerImpl中的createLocalWindowManager方法来创建的123public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mContext, parentWindow); } 结果返回了一个WindowManagerImpl对象，所以上面的ViewManager其实就是一个WindowManagerImpl对象。所以呢最后调用的就是它的addView方法1234public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } 它又调用了mGlobal的addView方法，mGlobal是个WindowManagerGlobal对象在成员变量中直接通过单例创建WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();去看它的addView方法12345678910111213141516171819202122232425public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ... ViewRootImpl root; View panelParentView = null; ... //创建一个ViewRootImpl并设置参数 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); //保存传过来的view,ViewRootImpl,LayoutParams mViews.add(view); mRoots.add(root); mParams.add(wparams); ... root.setView(view, wparams, panelParentView); ... } 看到这里创建了一个ViewRootImpl，给传过来的DecorView置LayoutParams参数，然后放到对应的集合中缓存，最后调用root.setView方法将他们关联起来。1234567public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized (this) { ... requestLayout(); ... view.assignParent(this); } 里面代码太多了，我们只关注里面的 requestLayout()方法就行1234567891011121314public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { //判断是不是主线程 checkThread(); mLayoutRequested = true; scheduleTraversals(); }}void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); }} 判断是不是在当前线程，当前activity的启动时在主线程，这就是为什么不能再子线程中更新UI，不过这里我们知道上面的方法时在onResume之后执行的，所以如果我们在onResume之前的子线程中执行一个很快的更新UI的操作，如果没有执行到这里就不会报错 首先判断是不是在主线程然后调用了scheduleTraversals方法。12345678910111213void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); }} 我们看到mChoreographer.postCallback方法中传了一个mTraversalRunnable参数到队列中去执行，mTraversalRunnable是TraversalRunnable对象，TraversalRunnable其实是一个Runnable对象，所以真正的的执行的代码在其run方法中。123456789101112131415final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } void doTraversal() { ... //真正的开始执行绘制 performTraversals(); ... } } 又调用了performTraversals方法12345678910111213141516private void performTraversals() { //DecorView final View host = mView; ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... //measure过程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... //layout过程 performLayout(lp, mWidth, mHeight); ... //绘制过程 performDraw();} 代码比较多，只提取出3个主要的方法，这几个方法主要执行View的主要绘制流程：测量，布局和绘制。 以上代码其实就是将我们的顶级view-&gt;DecorView添加到窗口上，关联到ViewRootImpl中，并调用requestLayout(); 方法请求绘制，最后到了performTraversals方法中执行performMeasure，performLayout，performDraw真正的开始绘制。 下面就分别来看一下这三个方法。1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { if (mView == null) { return; } Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 可以看到这里调用了mView的measure方法，这个mView就是我们的前面add进来的DecorView。它是一个FrameLayout。点进去查看123456789101112131415161718192021public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ...}protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } 首先我们看到点进来之后到了View这个类中，measure这个方法时final类型的，所以不能被重写，因此就算他是FrameLayout最终也是在View类中执行measure的方法。 measure方法中又调用了onMeasure方法，然后直接调用setMeasuredDimension方法，最后调用了setMeasuredDimensionRaw方法。这些方法时干什么的呢， 首先我们先找到传入的参数widthMeasureSpec和heightMeasureSpec了解这两个参数的作用。 这两个参数是怎么来的呢，回到我们上面的performTraversals()方法，可以看到int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 第一个参数表示窗口的宽度，第二个参数表示当前view也就是DectorView的LayoutParams12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec;} 可以看到根据我们View设置的MATCH_PARENT还是WRAP_CONTENT等返回了一个通过MeasureSpec.makeMeasureSpec方法返回了一个int类型的值measureSpec，那它代表什么呢? 我们在测量View的时候需要知道两点： 第一点View的测量模式 第二点View的尺寸 measureSpec表示一个32的整数值，其高两位代表测量模式SpecMode,底30位表示该测量模式下的尺寸SpecSize。 我们进入MeasureSpace类可以看到3个常量123456789101112131415/** * 表示父容器不对子容器进行限制，子容器可以是任意大小， * 一般是系统内部使用 */public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;/** * 精准测量模式，当view的layout_width 或者 layout_height指定为固定值值 * 或者为match_parent的时候生效，这时候view的测量值就是SpecSize */public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;/** * 父容器指定一个固定的大小，子容器可以使不超过这个值的任意大小 * 对应我们的wrap_content */public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; 对于DecorView这个顶级View来说，它的MeasureSpec 由窗口的尺寸和其自身的LayoutParams决定。 我们在回到measure方法中查看onMeasure方法，我们知道measure方法是个final方法不能被子类重写，不过onMeasure方法就没这个限制了，DecorView继承自FrameLayout,所以我们进入FrameLayout中查看它的onMeasure方法1234567891011121314151617181920212223242526272829303132333435363738394041protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { ... for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { //循环测量子view measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } ... // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } //设置自身的宽高 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); } 这里找出所有的子View，然后循环调用measureChildWithMargins方法测量子view的宽高，之后调用setMeasuredDimension确定自己的宽高1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //获取子控件的测量规格 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);} 先获取子控件的宽高的测量规格，然后调用子控件的measure方法传入测量规格，子控件的测量规格是怎么获取的呢,点进去看到getChildMeasureSpec这个方法是在ViewGroup类中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 /** * @param spec 父控件的测量规格 * @param padding 父控件已经占用的大小（减去padding和margin） * @param childDimension 子控件LayoutParams中的尺寸 * @return a MeasureSpec integer for the child */public static int getChildMeasureSpec(int spec, int padding, int childDimension) { //父控件的测量模式 int specMode = MeasureSpec.getMode(spec); //父控件的尺寸 int specSize = MeasureSpec.getSize(spec); //子容器可用大小要减去父view的padding和子view的margin int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // 如果父控件是精准尺寸，也就是父控件知道自己的大小 case MeasureSpec.EXACTLY: //如果子view设置了尺寸比如100dp,那么测量大小就是100dp if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //如果子view设置的MATCH_PAREN想要沾满父view //父view是精准模式，那么把父view的size给它 resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //如果子view设置的WRAP_CONTENT，那么它想随意决定自己的大小 //你可以随意玩，但是不能大于父控件的大小， //那么暂时把父view的size给它 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 如果父控件是最大模式，也就是父控件也不知道自己的大小 case MeasureSpec.AT_MOST: //子控件设定了具体值 if (childDimension &gt;= 0) { //那就返回这个具体值 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //子view想和父view一样大，但是父view也不知道自己多大 //把暂时父view的size给它，约束它不能超过父view resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //子view想要自己确定尺寸 //不能大于父view的size resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父view是不确定的，一般是系统调用开发中不用 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 对于普通的view来说它的MeasureSpec由其父view的MeasureSpec和自身的LayoutParams来决定 parentSpecMode/childLayoutParams EXACTLY AT_MOST UNSPECIFIED dp/px EXACTLY / chileSize EXACTLY / chileSize EXACTLY / chileSize match_parent EXACTLY / parentSize AT_MOST /parentSize 0 wrap_content AT_MOST/ parentSize AT_MOST /parentSize 0 当view采用固定宽高的时候，不管父容器是什么模式，子view的MeasureSpec都是精确模式，并且大小就是其LayoutParams中设置的大小 当view的宽或高是match_parent的时候，如果父容器是精准模式，那么子view的也是精准模式，其大小是父view的剩余空间，如果父容器是最大模式，那么子view也是最大模式，其大小暂时设为父view的大小并不能超过父view的大小。 当view的宽或高是wrap_content的时候，不管父容器是什么模式，子view总是最大化，并且不超过父容器的剩余空间。 OK总结一下 ViewGroup执行measure方法-&gt;里面通过onMeasure方法递归测量子控件的宽高，测量完后通过setMeasuredDimension调用setMeasuredDimensionRaw方法最终保存自己的宽高。 View执行measure-&gt;onMeasure测量自己-&gt;测量完后通过setMeasuredDimension调用setMeasuredDimensionRaw方法最终保存自己的宽高 我们回到view的onMeasure方法1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 可以看到它在调用setMeasuredDimension传参的的时候调用了getDefaultSize方法12345678910111213141516public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result; } 这个逻辑很简单，首先UNSPECIFIED我们不用管一般系统用，然后我们看到AT_MOST和EXACTLY最后的结果是一样的都赋值为specSize，这个specSize就是view测量后的大小。也就是getSuggestedMinimumWidth和getSuggestedMinimumHeight两个方法返回的值。123protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); } 从上面可以看出如果view没有设置背景，则返回mMinWidth，反之则宽度为mMinWidth和背景宽度的最大值。mMinWidth对应我们xml中设置的android:minWidth属性值，如果没设置则为0，mBackground.getMinimumWidth()则是返回的Drawable的原始宽度。 从上面的getDefaultSize方法我们可以得出一个结论，当我们直接继承view自定义控件的时候，需要重写其onMeasure方法，然后设置其wrap_content时候的大小，否则即便我们在布局中使用wrap_content，实际情况也相当于match_parent。原因可以从上面的表中看到，如果一个view设置了wrap_content，那么其测量模式是AT_MOST,在这种模式下view的宽高都等于父容器的剩余空间大小。 那怎么解决上面的问题呢？看一个重写onMeasure的例子123456789101112131415161718192021222324protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 宽的测量规格 int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); // 宽的测量尺寸 int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); // 高度的测量规格 int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); // 高度的测量尺寸 int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); //根据View的逻辑得到，比如TextView根据设置的文字计算wrap_content时的大小。 //这两个数据根据实现需求计算。 int wrapWidth,wrapHeight; // 如果是是AT_MOST则对哪个进行特殊处理 if(widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, wrapHeight); }else if(widthSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, heightSpecSize); }else if(heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(widthSpecSize, wrapHeight); }} 我们只需给view指定一个默认的宽高，并在AT_MOST的时候设置宽高即可，默认宽高的大小根据实际情况来 OK，measure的方法就看完了下面来看layout的流程，这个比measure简单多了12345678//lp顶层布局的布局属性，顶层布局的宽和高private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { ... final View host = mView; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); } 这里吧mView赋值给host然后调用了其layout方法，我们知道mView其实就是DecorView。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame来确定4个顶点的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { //父容器确定子view的位置 onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) { if(mRoundScrollbarRenderer == null) { mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); } } else { mRoundScrollbarRenderer = null; } mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } final boolean wasLayoutValid = isLayoutValid(); mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; if (!wasLayoutValid &amp;&amp; isFocused()) { mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS; if (canTakeFocus()) { // We have a robust focus, so parents should no longer be wanting focus. clearParentsWantFocus(); } else if (getViewRootImpl() == null || !getViewRootImpl().isInLayout()) { clearFocusInternal(null, /* propagate */ true, /* refocus */ false); clearParentsWantFocus(); } else if (!hasParentWantsFocus()) { // original requestFocus was likely on this view directly, so just clear focus clearFocusInternal(null, /* propagate */ true, /* refocus */ false); } } else if ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) != 0) { mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS; View focused = findFocus(); if (focused != null) { if (!restoreDefaultFocus() &amp;&amp; !hasParentWantsFocus()) { focused.clearFocusInternal(null, /* propagate */ true, /* refocus */ false); } } } if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) { mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT; notifyEnterOrExitForAutoFillIfNeeded(true); } } layout的流程首先通过setFrame方法设定view的4个顶点的位置，4个顶点确定了，view在父容器中的位置也就确定了，然后调用onLayout方法来确定子元素的位置。onLayout需要不同的ViewGroup去自己实现比如LinearLayout和RelativeLayout的实现是不同的。 OK，layout也看完了下面看最后一步Draw的流程1234567891011121314151617private void performDraw() { ... boolean canUseAsync = draw(fullRedrawNeeded); ...}private boolean draw(boolean fullRedrawNeeded) { ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) { ...} private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets) { ... mView.draw(canvas); ... } 通过一系列的跳转，我们终于找到关键方法mView.draw(canvas)，从这里就进入了view中的draw方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; //绘制背景 if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // 绘制自己 if (!dirtyOpaque) onDraw(canvas); // 绘制子view dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // 绘制装饰 前景滚动条(foreground, scrollbars) onDrawForeground(canvas); // 绘制默认的焦点突出显示 drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we're done... return; } ... view的绘制过程上面注释已经写清楚了 绘制背景 (background.draw(canvas)) 绘制自己 (onDrow) 绘制子view（dispatchDrow） 绘制装饰（前景、滚动条） 如果我们是自定义view，就去实现onDraw方法，如果我们是自定义ViewGroup,那就去实现dispatchDraw方法，dispatchDraw方法中会遍历子view调用子view的draw方法。 到这里draw方法就看完了，view的绘制流程也执行完毕！ ps: view中有个特殊的方法setWillNotDraw12345678910111213/** * If this view doesn't do any drawing on its own, set this flag to * allow further optimizations. By default, this flag is not set on * View, but could be set on some View subclasses such as ViewGroup. * * Typically, if you override {@link #onDraw(android.graphics.Canvas)} * you should clear this flag. * * @param willNotDraw whether or not this View draw on its own */ public void setWillNotDraw(boolean willNotDraw) { setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); } 从注释中看出来，如果一个view不需要绘制任何东西，这个标志位设置为true之后，系统会进行相应的优化。 默认情况下，view没有启动这个标志位，但是ViewGroup是会默认启动这个标志位的。所以当我们继承ViewGroup的时候并且明确知道需要通过onDraw来绘制内容的时候，我们需要显示的关闭这个标志位。","link":"/2019/03/24/technology/UI绘制流程-View的绘制流程/"},{"title":"Activity启动流程(上)","text":"Android看源码的两个网站： Android看源码的两个网站： https://www.androidos.net.cn/ http://androidxref.com/ Activity启动部分的代码真的很多，断断续续看了一个多星期，而且看这种frameworks层的代码不像在AndroidStudio中看代码方便可以直接点一个方法或者类逃过去，只能通过上面的网站看代码，用到哪个类只能一个一个的去找，所以一定要有耐心，等看完之后对启动流程这块有一个宏观的认识之后也挺有成就感的，由于篇幅太长分成两篇。 OK从我们最熟悉的startActivity(intent)开始1234567public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { startActivityForResult(intent, -1); } } 不管有没有传参数最终都调用了startActivityForResult方法12345678910111213141516171819202122232425public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { mParent.startActivityFromChild(this, intent, requestCode); } } } 首先判断mParent == null，mParent 是当前Activity的父类，第一次启动的时候mParent为空，所以走上面为空的逻辑可以看到调用了mInstrumentation.execStartActivity 这里传入参数有两个比较重要 mMainThread.getApplicationThread()是ApplicationThread的本地IBinder对象，用来进程间通讯。 mToken是Binder的代理对象，指向ActivityManagerService，告诉系统谁要启动这个activity Instrumentation中文翻译为仪表器，每个Activity都持有一个Instrumentation对象，用来监控应用程序和系统的交互，每个进程中只有一个Instrumentation实例。 继续查看Instrumentation中的execStartActivity方法。源码位置在/frameworks/base/core/java/android/app/Instrumentation.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) { intent.putExtra(Intent.EXTRA_REFERRER, referrer); } if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) { result = am.onStartActivity(intent); } if (result != null) { am.mHits++; return result; } else if (am.match(who, null, intent)) { am.mHits++; if (am.isBlocking()) { return requestCode &gt;= 0 ? am.getResult() : null; } break; } } } } try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(\"Failure from system\", e); } return null; } ActivityMonitor，Activity监视器，监视的特定意图类型的信息不用管，然后走到ActivityManager.getService().startActivity，看一下ActivityManager.getService()位置在frameworks/base/core/java/android/app/ActivityManager.java12345678910111213public static IActivityManager getService() { return IActivityManagerSingleton.get(); } private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; AMS 全称 ActivityManagerService 服务端对象，负责管理系统中所有的activity，系统创建的时候就创建了 getService调用了IActivityManagerSingleton.get()方法，getService调用了IActivityManagerSingleton是一个Singleton类，从系统中获取AMS这个binder对象，然后转换为其代理对象IActivityManager返回。这里是使用了AIDL实现的。 回到Instrumentation的execStartActivity方法，最终调用了IActivityManager的startActivity方法。IActivityManager是AMS在本地的代理，所以其实是调用了ActivityManagerService的startActivity方法. 源码位置在frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId()); } @Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/); } public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) { enforceNotIsolatedCaller(\"startActivity\"); //检查调用者的权限 userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\"); // TODO: Switch to user app stacks here. return mActivityStartController.obtainStarter(intent, \"startActivityAsUser\") .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute(); } 这里一连串的调用，startActivityAsUser方法比startActivity多了一个参数userId,AMS会根据这个UserId来确定调用者的权限，最终通过ActivityStartController.obtainStarter这个方法获得一个包含activity所有信息的ActivityStarter对象并调用其execute方法。 ActivityStarter，搜集逻辑并决定如何把intent和flag转换成activity。 进入execute方法位置 /frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456789101112131415161718192021222324252627//根据前面提供的参数来启动activity int execute() { try { if (mRequest.mayWait) { return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup); } else { return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup); } } finally { onExecutionComplete(); } } 上面startActivityAsUser方法中调用了setMayWait方法，所以 mRequest.mayWait是true的,所以我们走startActivityMayWait方法。12345ActivityStarter setMayWait(int userId) { mRequest.mayWait = true; mRequest.userId = userId; return this; } startActivityMayWait方法非常长，只看主要部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup) { ...... int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason, allowPendingRemoteAnimationRegistryLookup); ...... mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[0]); return res; } } private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) { ...... //获取进程记录 if (caller != null) { callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) { //获取进程的pid和uid并赋值 callingPid = callerApp.pid; callingUid = callerApp.info.uid; } else { Slog.w(TAG, \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting: \" + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; } } ...... //创建将要启动的activity的记录类 ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, checkedOptions, sourceRecord); if (outActivity != null) { outActivity[0] = r; } ...... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity); } 判断传过来的IApplicationThread是不是null,然后通过AMS的getRecordForAppLocked方法得到一个ProcessRecord对象callerApp，ProcessRecord用于描述一个应用程序进程。 创建ActivityRecord类，ActivityRecord用来描述一个activity，然后赋值给outActivity数组的第0位，最后继续调用重载的startActivity，并传入outActivity数组 123456789101112131415161718192021222324private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { int result = START_CANCELED; try { mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); } finally { // If we are not able to proceed, disassociate the activity from the task. Leaving an // activity in an incomplete state can lead to issues, such as performing operations // without a window container. final ActivityStack stack = mStartActivity.getStack(); if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) { stack.finishActivityLocked(mStartActivity, RESULT_CANCELED, null /* intentResultData */, \"startActivity\", true /* oomAdj */); } mService.mWindowManager.continueSurfaceLayout(); } postStartActivityProcessing(r, result, mTargetStack); return result; } 这个startActivity方法调用了startActivityUnchecked方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); //处理Activity的启动模式，确定Activity的启动模式 computeLaunchingTaskFlags(); computeSourceStack(); mIntent.setFlags(mLaunchFlags); ActivityRecord reusedActivity = getReusableIntentActivity(); int preferredWindowingMode = WINDOWING_MODE_UNDEFINED; int preferredLaunchDisplayId = DEFAULT_DISPLAY; if (mOptions != null) { preferredWindowingMode = mOptions.getLaunchWindowingMode(); preferredLaunchDisplayId = mOptions.getLaunchDisplayId(); } // windowing mode and preferred launch display values from {@link LaunchParams} take // priority over those specified in {@link ActivityOptions}. if (!mLaunchParams.isEmpty()) { if (mLaunchParams.hasPreferredDisplay()) { preferredLaunchDisplayId = mLaunchParams.mPreferredDisplayId; } if (mLaunchParams.hasWindowingMode()) { preferredWindowingMode = mLaunchParams.mWindowingMode; } } if (reusedActivity != null) { //当设置NEW_TASK或者CLEAR_TASK模式的时候将重用任务 //但是仍然违反锁定模式任务，因为该任务将要被清除 // 该设备将要离开锁定任务 if (mService.getLockTaskController().isLockTaskModeViolation(reusedActivity.getTask(), (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) { Slog.e(TAG, \"startActivityUnchecked: Attempt to violate Lock Task Mode\"); return START_RETURN_LOCK_TASK_MODE_VIOLATION; } //如果我们清除顶部并重新设定为默认启动模式 // ({@code LAUNCH_MULTIPLE}) activity. The existing activity will be finished. final boolean clearTopAndResetStandardLaunchMode = (mLaunchFlags &amp; (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)) == (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) &amp;&amp; mLaunchMode == LAUNCH_MULTIPLE; //根据Activity启动模式来设置栈 if (mStartActivity.getTask() == null &amp;&amp; !clearTopAndResetStandardLaunchMode) { mStartActivity.setTask(reusedActivity.getTask()); } if (reusedActivity.getTask().intent == null) { // This task was started because of movement of the activity based on affinity... // Now that we are actually launching it, we can assign the base intent. reusedActivity.getTask().setIntent(mStartActivity); } // 这将交付一个新的intent if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || isDocumentLaunchesIntoExisting(mLaunchFlags) || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) { final TaskRecord task = reusedActivity.getTask(); //FLAG_ACTIVITY_CLEAR_TOP模式下把所有activity移除 final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity, mLaunchFlags); if (reusedActivity.getTask() == null) { reusedActivity.setTask(task); } if (top != null) { if (top.frontOfTask) { // Activity aliases may mean we use different intents for the top activity, // so make sure the task now has the identity of the new intent. top.getTask().setIntent(mStartActivity); } //当栈顶activity可以服用时，传入当前栈顶的activity deliverNewIntent(top); } } mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity); reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity); final ActivityRecord outResult = outActivity != null &amp;&amp; outActivity.length &gt; 0 ? outActivity[0] : null; // 如果当前重用的activity不为null,并且是活的，就把它设为结果 if (outResult != null &amp;&amp; (outResult.finishing || outResult.noDisplay)) { outActivity[0] = reusedActivity; } if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) { // We don't need to start a new activity, and the client said not to do anything // if that is the case, so this is it! And for paranoia, make sure we have // 正确恢复顶部的 activity. resumeTargetStackIfNeeded(); return START_RETURN_INTENT_TO_CALLER; } if (reusedActivity != null) { setTaskFromIntentActivity(reusedActivity); if (!mAddingToTask &amp;&amp; mReuseTask == null) { // We didn't do anything... but it was needed (a.k.a., client don't use that // intent!) And for paranoia, make sure we have correctly resumed the top activity. resumeTargetStackIfNeeded(); if (outActivity != null &amp;&amp; outActivity.length &gt; 0) { outActivity[0] = reusedActivity; } return mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP; } } } if (mStartActivity.packageName == null) { final ActivityStack sourceStack = mStartActivity.resultTo != null ? mStartActivity.resultTo.getStack() : null; if (sourceStack != null) { sourceStack.sendActivityResultLocked(-1 /* callingUid */, mStartActivity.resultTo, mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED, null /* data */); } ActivityOptions.abort(mOptions); return START_CLASS_NOT_FOUND; } // 如果即将启动的activity跟栈顶的activity相同，我们需要确定它的启动模式. final ActivityStack topStack = mSupervisor.mFocusedStack; final ActivityRecord topFocused = topStack.getTopActivity(); final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop); final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null &amp;&amp; top.realActivity.equals(mStartActivity.realActivity) &amp;&amp; top.userId == mStartActivity.userId &amp;&amp; top.app != null &amp;&amp; top.app.thread != null &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0 || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)); if (dontStart) { // For paranoia, make sure we have correctly resumed the top activity. topStack.mLastPausedActivity = null; if (mDoResume) { mSupervisor.resumeFocusedStackTopActivityLocked(); } ActivityOptions.abort(mOptions); if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) { // We don't need to start a new activity, and the client said not to do // anything if that is the case, so this is it! return START_RETURN_INTENT_TO_CALLER; } deliverNewIntent(top); // Don't use mStartActivity.task to show the toast. We're not starting a new activity // but reusing 'top'. Fields in mStartActivity may not be fully initialized. mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredWindowingMode, preferredLaunchDisplayId, topStack); return START_DELIVERED_TO_TOP; } boolean newTask = false; final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTask() : null; // Should this be considered a new task? int result = START_SUCCESS; if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) { newTask = true; result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, topStack); } else if (mSourceRecord != null) { result = setTaskFromSourceRecord(); } else if (mInTask != null) { result = setTaskFromInTask(); } else { // This not being started from an existing activity, and not part of a new task... // just put it in the top task, though these days this case should never happen. setTaskToCurrentTopOrCreateNewTask(); } if (result != START_SUCCESS) { return result; } mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName, mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId); mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent, mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid)); if (newTask) { EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, mStartActivity.userId, mStartActivity.getTask().taskId); } ActivityStack.logStartActivity( EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask()); mTargetStack.mLastPausedActivity = null; mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, mStartActivity); mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions); //根据Activity的启动模式来判断是直接插入已存在的栈顶还是新开栈插入 //判断是否需要activity可见 if (mDoResume) { final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) { //如果activity还没有聚焦就不能让它成为resume可以让它成为start mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mService.mWindowManager.executeAppTransition(); } else { //如果是聚焦的就移到前台 if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) { mTargetStack.moveToFront(\"startActivityUnchecked\"); } mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); } } else if (mStartActivity != null) { mSupervisor.mRecentTasks.add(mStartActivity.getTask()); } mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack); mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode, preferredLaunchDisplayId, mTargetStack); return START_SUCCESS; } startActivityUnchecked方法主要用来管理栈相关的逻辑，计算activity的启动模式有关的flag，将目标activity置于栈顶，执行目标activity的resume流程，经过一系列的判断，最后都会走入mSupervisor.resumeFocusedStackTopActivityLocked这个方法。位置在/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123456789101112131415161718192021boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) { if (!readyToResume()) { return false; } //传入的当前栈不为null并且是获取焦点 if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) { return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); } //获取要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || !r.isState(RESUMED)) { mFocusedStack.resumeTopActivityUncheckedLocked(null, null); } else if (r.isState(RESUMED)) { // Kick off any lingering app transitions form the MoveTaskToFront operation. mFocusedStack.executeAppTransition(targetOptions); } return false; } 如果传入的targetStack不为null，并且是获取焦点的，就调用它的resumeTopActivityUncheckedLocked方法，如果是null,并且能拿到要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord就调用mFocusedStack的resumeTopActivityUncheckedLocked方法。总之最后进入resumeTopActivityUncheckedLocked方法。 位置/frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011121314151617181920212223boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // 避免递归调用 mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); //当恢复顶部activity时，它可能需要暂停 final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) { checkReadyForSleep(); } } finally { mStackSupervisor.inResumeTopActivity = false; } return result; } 上面的方法中返回的结果是调用了resumeTopActivityInnerLocked方法,这个方法代码太多，只看主要的123456789101112131415161718192021222324252627private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { ...... //获取需要启动的activity final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); ...... //暂停栈中所有的activity boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false); //让现在正在显示的activity进入暂停状态，虽然这里传入的是next，跟进去后里面暂停的activity还是通过mResumedActivity获得的 if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Pausing \" + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, next, false); } ...... //next.app和next.app.thread分别代表ProcessRecord和IApplicationThread对象， //如果这两个都不为null说明目标activity所属进程已经存在 //可以直接执行resume流程 if (next.app != null &amp;&amp; next.app.thread != null) { ... mStackSupervisor.scheduleResumeTopActivities(); }else{ //当进程不存在的时候执行下面方法启动activity mStackSupervisor.startSpecificActivityLocked(next, true, true); } } resumeTopActivityInnerLocked这个方法就是把现在正在显示的activity暂停，把将要启动的activity变成可见。既正在显示的pause，将要启动的resume。 所以现在分成两部分看，先看旧的activity暂停在看新的activity显示 12345678910111213141516171819202122232425262728293031323334 final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean pauseImmediately) { ...... //当前前台的activity ActivityRecord prev = mResumedActivity; ...... //检测prev所对应的进程是否创建，正常情况下是是肯定存在的 if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Enqueueing pending pause: \" + prev); try { EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev), prev.shortComponentName, \"userLeaving=\" + userLeaving); mService.updateUsageStats(prev, false); //mService是ActivityManagerService //PauseActivityItem封装了Activity的pause请求，它继承自ActivityLifecycleItem //ActivityLifecycleItem继承自ClientTransactionItem mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately)); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, \"Exception thrown during pause\", e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ......} 上面的代码中mService是ActivityManagerService，它的getLifecycleManager()返回一个ClientLifecycleManager对象，这个类是android9.0新加入的工具类，用来辅助管理activity的生命周期，它会发从EXECUTE_TRANSACTION到ActivityThread.H里面继续处理。 /frameworks/base/services/core/java/com/android/server/am/ClientLifecycleManager.java 1234567891011121314151617 void scheduleTransaction(@NonNull IApplicationThread client, @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest) throws RemoteException { final ClientTransaction clientTransaction = transactionWithState(client, activityToken, stateRequest); scheduleTransaction(clientTransaction); } void scheduleTransaction(ClientTransaction transaction) throws RemoteException { final IApplicationThread client = transaction.getClient(); transaction.schedule(); if (!(client instanceof Binder)) { transaction.recycle(); } }/frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java public void schedule() throws RemoteException { mClient.scheduleTransaction(this); } mClient是IApplicationThread，这里使用了Binder通信，从源码的位置我们也能看出来从/frameworks/base/services到/frameworks/base/core/从服务进程到了应用程序进程。 ApplicationThread是ActivityThread的内部类1234567891011public final class ActivityThread extends ClientTransactionHandler { ...... private class ApplicationThread extends IApplicationThread.Stub { ...... public void scheduleTransaction(ClientTransaction transaction) throws RemoteException { ActivityThread.this.scheduleTransaction(transaction); } ...... } } ...... ApplicationThread继承了IApplicationThread.Stub，也就是IApplicationThread这个AIDL接口在service端（也就是应用端）的实现类，同时它是ActivityThread的内部类，然后调用了 ActivityThread中的scheduleTransaction(transaction)方法。ActivityThread继承了ClientTransactionHandler这个方法在ClientTransactionHandler中 /frameworks/base/core/java/android/app/ClientTransactionHandler.java 1234void scheduleTransaction(ClientTransaction transaction) { transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); } 上面的方法将transaction进行预处理，然后封装成一个消息发从出去，sendMessage是个抽象方法，实现类在其子类ActivityThread中 1234567891011121314151617181920212223242526void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } private void sendMessage(int what, Object obj, int arg1) { sendMessage(what, obj, arg1, 0, false); } private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } mH是一个H类class H extends Handler {...}H类是继承自Handler，所以它也是个Handler，那么具体实现就是在其handleMessage方法中了 123456789101112131415public void handleMessage(Message msg) { ... switch (msg.what) { ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); if (isSystem()) { //系统流程中的客户端事务在客户端回收 // instead of ClientLifecycleManager to avoid being cleared before this transaction.recycle(); } break; ... } 执行了mTransactionExecutor的execute方法，mTransactionExecutor是一个TransactionExecutor 类型的成员变量，用来执行多步骤事物。 /frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java12345678910public void execute(ClientTransaction transaction) { final IBinder token = transaction.getActivityToken(); log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); log(\"End resolving transaction\"); } 前面看过的ClientLifecycleManager类中在封装ClientTransaction 的时候，有transactionWithState和transactionWithCallback两个方法，我们当时追的代码是执行的transactionWithState这个方法，所以此处executeCallbacks是没法执行回调的，executeLifecycleState会处理activity的pause请求1234567891011121314151617181920212223242526272829303132333435 private void executeLifecycleState(ClientTransaction transaction) { //从前面代码中知道lifecycleItem就是PauseActivityItem final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest(); if (lifecycleItem == null) { // No lifecycle request, return early. return; } log(\"Resolving lifecycle state: \" + lifecycleItem); final IBinder token = transaction.getActivityToken(); //通过token获取activity的信息 final ActivityClientRecord r = mTransactionHandler.getActivityClient(token); if (r == null) { // Ignore requests for non-existent client records for now. return; } // 检查activity的当前状态是否直接切换到transaction请求状态， //如果存在中间状态，需要完成这些中间状态的切换 //这里是resume状态到pause状态，中间没有别的状态，所以其实没执行什么 cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */); //lifecycleItem是PauseActivityItem lifecycleItem.execute(mTransactionHandler, token, mPendingActions); lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions); } //r和finish是一样的private void cycleToPath(ActivityClientRecord r, int finish, boolean excludeLastState) { final int start = r.getLifecycleState(); log(\"Cycle from: \" + start + \" to: \" + finish + \" excludeLastState:\" + excludeLastState); final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState); performLifecycleSequence(r, path); } 因为lifecycleItem是PauseActivityItem，所以execute方法是在PauseActivityItem中执行/frameworks/base/core/java/android/app/servertransaction/PauseActivityItem.java1234567public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions, \"PAUSE_ACTIVITY_ITEM\"); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); } 上面调用了ClientTransactionHandler中的handlePauseActivity方法public abstract void handlePauseActivity这个方法是个抽象方法，所以由它的子类ActivityThread类来实现123456789101112131415161718public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, PendingTransactionActions pendingActions, String reason) { ActivityClientRecord r = mActivities.get(token); if (r != null) { if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(r, finished, reason, pendingActions); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } mSomeActivitiesChanged = true; } } ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;()mActivities是一个ArrayMap，键是匿名实体列ActivityRecord.Token，主要用来记录一个activity在AMS进程中的ActivityClientRecord对象。可以看出它是维护了一个activity在AMS进程和应用进程之间的映射关系12345678910111213141516private Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason, PendingTransactionActions pendingActions) { ... performPauseActivityIfNeeded(r, reason); ... }private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) { if (r.paused) { return; } ... //当不是pause状态时委托 mInstrumentation执行pause mInstrumentation.callActivityOnPause(r.activity); ...} /frameworks/base/core/java/android/app/Instrumentation.java123public void callActivityOnPause(Activity activity) { activity.performPause(); } frameworks/base/core/java/android/app/Activity.java1234567891011121314final void performPause() { mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); writeEventLog(LOG_AM_ON_PAUSE_CALLED, \"performPause\"); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) { throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); }} 这里我们看到了我们熟悉是 onPause() 方法，到此旧的activity就暂停了，下一篇在看新的activity的启动流程。","link":"/2019/03/06/technology/Activity启动流程-上/"},{"title":"Activity启动流程(下)","text":"继续上一篇Activity启动流程（上）下面继续新activity的启动流程mStackSupervisor.startSpecificActivityLocked(next, true, true); /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java123456789101112131415161718192021222324252627void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // 获取要启动activity的进程信息 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); getLaunchTimeTracker().setLaunchTime(r); //判断进程是否是null if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) { app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode, mService.mProcessStats); } realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); } } //如果进程是null，告诉AMS启动进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true); } 上面代码：判断要启动的activity的进程是否存在，如果存在就执行realStartActivityLocked方法，如果不存在就调用AMS的startProcessLocked方法创建新的进程。也就是说我们的app是否已经启动，如果启动了就执行realStartActivityLocked方法，如果没启动比如点击应手机用图标后，就执行startProcessLocked创建应用的进程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); }final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) { app = getProcessRecordLocked(processName, info.uid, keepIfLarge); ... final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride); ... return success ? app : null; }private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) { startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */); } @GuardedBy(\"this\")private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride) { return startProcessLocked(app, hostingType, hostingNameStr, false /* disableHiddenApiChecks */, abiOverride); }private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) { ...... final String entryPoint = \"android.app.ActivityThread\"; return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); }private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) { //新进程的启动过程是否需要异步执行（默认值为true） if (mConstants.FLAG_PROCESS_START_ASYNC) { ... final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime); synchronized (ActivityManagerService.this) { handleProcessStartedLocked(app, startResult, startSeq); } ... }else{ ... final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false); ... } return app.pid &gt; 0; } 上面的代码经过一系列的startProcessLocked的重载方法的调用，最后调用到startProcess方法12345678910111213141516171819202122232425262728private ProcessStartResult startProcess(String hostingType, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) { try { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); final ProcessStartResult startResult; if (hostingType.equals(\"webview_service\")) { startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, new String[] {PROC_START_SEQ_IDENT + app.startSeq}); } else { startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, new String[] {PROC_START_SEQ_IDENT + app.startSeq}); } checkTime(startTime, \"startProcess: returned from zygote!\"); return startResult; } finally { Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } } hostingType代表我们是使用何种方式启动的，我们这里不是webview_service，所以走else中的方法Process.start /frameworks/base/core/java/android/os/Process.java123456789101112131415public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) { return zygoteProcess.start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs); } start方法通过Socket通信，把新进程的创建请求交给zygote进程处理。zygoteProcess是ZygoteProcess对象/frameworks/base/core/java/android/os/ZygoteProcess.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); } } private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean startChildZygote, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(mLock) { ...... //计算并配置启动进程的各种参数，之后调用下面方法 //第一个参数根据abi来选择跟32位的zygote还是64位的zygote进程通信 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); }private static Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { //如果有任何格式的参数错误尽早抛出异常 int sz = args.size(); for (int i = 0; i &lt; sz; i++) { if (args.get(i).indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); } } final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? Process.ProcessStartResult result = new Process.ProcessStartResult(); result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(\"fork() failed\"); } return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } }} 到这里result.pid = inputStream.readInt() 新进程创建成功并返回该进程就有了它自己的pid，下面就是这个新的应用进程启动activity 上面的方法我们知道了最终创建了一个新的进程并返回了新进程的pid,那么这个新的进程到底是怎么创建的呢 看一下上面startViaZygote这个方法调用zygoteSendArgsAndGetResult方法传入的第一个参数openZygoteSocketIfNeeded(abi)，这里是根据不同的cpu开启socket通信。也就是说AMS是通过socket跟zygote进程通信的。 看一下Process类的几个成员变量/frameworks/base/core/java/android/os/Process.java1234567891011121314public class Process { ... public static final String ZYGOTE_SOCKET = \"zygote\"; public static final String SECONDARY_ZYGOTE_SOCKET = \"zygote_secondary\"; ... public static final ZygoteProcess zygoteProcess = new ZygoteProcess(ZYGOTE_SOCKET, SECONDARY_ZYGOTE_SOCKET); ....} public ZygoteProcess(LocalSocketAddress primarySocket, LocalSocketAddress secondarySocket) { mSocket = primarySocket; mSecondarySocket = secondarySocket; } 上面是两个socket服务，先连接第一个连不上在连接第二个尽可能保证服务正常然后看openZygoteSocketIfNeeded(abi)是怎连接socket的12345678private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx { ... primaryZygoteState = ZygoteState.connect(mSocket); ... secondaryZygoteState = ZygoteState.connect(mSecondarySocket);} ZygoteState是ZygoteProcess的一个内部类/frameworks/base/core/java/android/os/ZygoteProcess.java 看起静态连接方法123456789101112131415161718192021222324252627public static ZygoteState connect(LocalSocketAddress address) throws IOException { DataInputStream zygoteInputStream = null; BufferedWriter zygoteWriter = null; final LocalSocket zygoteSocket = new LocalSocket(); try { zygoteSocket.connect(address); zygoteInputStream = new DataInputStream(zygoteSocket.getInputStream()); zygoteWriter = new BufferedWriter(new OutputStreamWriter( zygoteSocket.getOutputStream()), 256); } catch (IOException ex) { try { zygoteSocket.close(); } catch (IOException ignore) { } throw ex; } String abiListString = getAbiList(zygoteWriter, zygoteInputStream); Log.i(\"Zygote\", \"Process: zygote socket \" + address.getNamespace() + \"/\" + address.getName() + \" opened, supported ABIS: \" + abiListString); return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter, Arrays.asList(abiListString.split(\",\"))); 通过LocalSocket来连接zygote或者zygote_secondary进程，写出流zygoteWriter 然后回到前面的zygoteSendArgsAndGetResult方法，通过写出流将要创建的信息发送给zygote进程。 那zygote进程是怎么接收这个信息的呢，在Android系统中，所有的应用程序进程以及系统服务进程SystemServer都是由Zygote进程孕育（fork）出来的 /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java Zygote进程在启动的时候，在其main方法中会调用其forkSystemServer方法1234567891011121314151617181920212223public static void main(String argv[]) { ZygoteServer zygoteServer = new ZygoteServer(); ... final Runnable caller; ... Runnable r = forkSystemServer(abiList, socketName, zygoteServer); ... caller = zygoteServer.runSelectLoop(abiList); if (caller != null) { caller.run(); }}private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) { ... if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); } 在创建system_sever的时候会执行waitForSecondaryZygote方法12345678910111213141516171819202122232425 private static void waitForSecondaryZygote(String socketName) { String otherZygoteName = Process.ZYGOTE_SOCKET.equals(socketName) ? Process.SECONDARY_ZYGOTE_SOCKET : Process.ZYGOTE_SOCKET; ZygoteProcess.waitForConnectionToZygote(otherZygoteName); }/frameworks/base/core/java/android/os/ZygoteProcess.javapublic static void waitForConnectionToZygote(String socketName) { final LocalSocketAddress address = new LocalSocketAddress(socketName, LocalSocketAddress.Namespace.RESERVED); waitForConnectionToZygote(address); } //尝试连接Zygote 进程直到超时public static void waitForConnectionToZygote(LocalSocketAddress address) { for (int n = 20; n &gt;= 0; n--) { try { final ZygoteState zs = ZygoteState.connect(address); zs.close(); return; } catch (IOException ioe) {} try { Thread.sleep(1000); } catch (InterruptedException ie) { } } } 可以看到它也会连接到这个socket上，这样就可以跟客户端通信了，在回到上面的main方法中，caller = zygoteServer.runSelectLoop(abiList)caller是一个Runnable，执行它的run方法。其实就是在一个子线程中等待接收客户端发来的信息。 123456789101112131415161718192021222324252627282930313233343536Runnable runSelectLoop(String abiList) { ... ZygoteConnection connection = peers.get(i); final Runnable command = connection.processOneCommand(this); ...}/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.javaRunnable processOneCommand(ZygoteServer zygoteServer) { ... int pid = -1; ... //创建新进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote, parsedArgs.instructionSet, parsedArgs.appDataDir); ... if (pid == 0) { // 我们要创建activity的子进程 zygoteServer.setForkChild(); zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.startChildZygote); } else { // In the parent. A pid &lt; 0 indicates a failure and will be handled in // handleParentProc. IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, descriptors, serverPipeFd); return null; }} 当pid=0的时候，就是在当前新建的进程中执行12345678910111213141516171819202122private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, boolean isZygote) { ... if (parsedArgs.invokeWith != null) { WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); // Should not get here. throw new IllegalStateException(\"WrapperInit.execApplication unexpectedly returned\"); } else { if (!isZygote) {//是否启动zygote的子进程这里是false return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); } else { return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); } } ... } 这里没有传入没有传入–invoke-with，所以走else，是否启动zygote的子进程这里是false所以走ZygoteInit.zygoteInit123456789101112public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) { if (RuntimeInit.DEBUG) { Slog.d(RuntimeInit.TAG, \"RuntimeInit: Starting application from zygote\"); } Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ZygoteInit\"); RuntimeInit.redirectLogStreams(); RuntimeInit.commonInit(); ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); } 返回了RuntimeInit.applicationInit方法，传入sdk的版本，各种参数和类加载器classloader123456789101112131415161718192021222324252627282930313233343536373839404142434445protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) { nativeSetExitWithoutCleanup(true); VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args = new Arguments(argv); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); return findStaticMain(args.startClass, args.startArgs, classLoader); } protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class&lt;?&gt; cl; try { cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); } Method m; try { m = cl.getMethod(\"main\", new Class[] { String[].class }); } catch (NoSuchMethodException ex) { throw new RuntimeException( \"Missing static main on \" + className, ex); } catch (SecurityException ex) { throw new RuntimeException( \"Problem getting static main on \" + className, ex); } int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( \"Main method is not public and static on \" + className); } return new MethodAndArgsCaller(m, argv); } 这里的className是在上面的ActivityManagerService中的startProcessLocked方法entryPoint一步一步传过来的final String entryPoint = &quot;android.app.ActivityThread&quot;; 所以这里通过反射创建了ActivityThread类并执行其main方法 /frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); ... //为主线程创建一个消息循环对象 Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); //绑定应用程序 thread.attach(false, startSeq); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } ... Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //启动消息循环 Looper.loop();} 创建主线程的Looper对象，绑定应用程序，启动Looper12345678private void attach(boolean system, long startSeq) { ... final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); } ...} ActivityManager.getService()返回的是IActivityManager的binder代理对象，用于应用进程向AMS通信 mgr这个代理对象通过AIDL调用AMS中的attachApplication方法，mAppThread就是需要为应用绑定的ApplicationThread对象 /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 public final void attachApplication(IApplicationThread thread, long startSeq) { synchronized (this) { int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); } }private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) { ... if (app.isolatedEntryPoint != null) { thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs); } else if (app.instr != null) { thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); } else { thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); } ... //检查当前栈顶的activity是否满足要启动的activity if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e); badApp = true; } } ... } app.isolatedEntryPoint很明显我们不是一个隔离的进程，我们是为了创建activity所有走else方法，最终都会进入 thread.bindApplication thread是IApplicationThread的binder对象，也就是AMS通过AIDL调用应用进程的ApplicationThread方法。所以说AMS不直接参与Application的初始化流程，而是配置一些参数之后交给应用自己处理 mStackSupervisor.attachApplicationLocked(app)检查当前栈顶的activity是否是要启动的activity 先看bindApplication方法，这个就是初始化Application/frameworks/base/core/java/android/app/ActivityThread.java12345678910111213141516171819202122232425public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, boolean autofillCompatibilityEnabled) { ... sendMessage(H.BIND_APPLICATION, data); } class H extends Handler { public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) { case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... } } 这里跟前面暂停一个activity一样，发从一个消息，然后去H这个Handler中执行 123456789101112private void handleBindApplication(AppBindData data) { //设置进程名 Process.setArgV0(data.processName); ... app = data.info.makeApplication(data.restrictedBackupMode, null); ... mInstrumentation.callApplicationOnCreate(app); ...}public void callApplicationOnCreate(Application app) { app.onCreate(); } 上面最终执行了Application的onCreate方法 在回到attachApplicationLocked中看mStackSupervisor.attachApplicationLocked(app)方法/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java1234567891011121314151617181920212223242526boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { ... stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList); final ActivityRecord top = stack.topRunningActivityLocked(); ... //需要启动的Activity final ActivityRecord top = stack.topRunningActivityLocked(); final int size = mTmpActivityList.size(); //遍历所有的activity for (int i = 0; i &lt; size; i++) { final ActivityRecord activity = mTmpActivityList.get(i); //如果未启动并且属于当前线程 if (activity.app == null &amp;&amp; app.uid == activity.info.applicationInfo.uid &amp;&amp; processName.equals(activity.processName)) { try { if (realStartActivityLocked(activity, app, top == activity /* andResume */, true /* checkConfig */)) { didSomething = true; } } catch (RemoteException e) { throw e; } } } ...} 这里又看到了realStartActivityLocked这个方法，很熟悉吧，我们在前面startSpecificActivityLocked方法中判断要启动的activity的进程是否存在，如果存在就执行realStartActivityLocked方法，如果不存在就调用AMS的startProcessLocked方法创建新的进程，所以这里我们转了一圈启动了进程之后又回到realStartActivityLocked这个方法来真正的启动一个activity。 /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java12345678910111213141516171819202122232425262728final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ...... // 为Activity的launch创建 transaction final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread, r.appToken); //创建一个LaunchActivityItem对象，并传添加到事物中 clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, mService.isNextTransitionForward(), profilerInfo)); //设置Activity的最终状态 final ActivityLifecycleItem lifecycleItem; if (andResume) { lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward()); } else { lifecycleItem = PauseActivityItem.obtain(); } clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. mService.getLifecycleManager().scheduleTransaction(clientTransaction); ......} 创建一个LaunchActivityItem对象，并传添加到事物中，这里跟前面的pause的流程一样，添加到事物中后，通过ClientLifecycleManager 执行事物。通过ClientLifecycleManager中的scheduleTransaction方法跟前面pause中的是一样的，就不贴出来了。 大体流程就是最后执行到IApplicationThread中的scheduleTransaction方法，又回到ActivityThread中，也就是AMS交给应用进程自己创建activity自己创建，scheduleTransaction中发从了一个message交给H这个handler处理。最终执行到TransactionExecutor中的execute方法 上面代码中clientTransaction.addCallback中传入的是LaunchActivityItem.obtain方法，它返回了一个addCallback中传入的是LaunchActivityItem对象 /frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java12345678910public void execute(ClientTransaction transaction) { final IBinder token = transaction.getActivityToken(); log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); log(\"End resolving transaction\"); } 因为前面代码是addCallback，所以这里执行executeCallbacks方法12345678910111213141516171819202122public void executeCallbacks(ClientTransaction transaction) {//通过前面传的我们知道ClientTransactionItem就是是LaunchActivityItem final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null) { return; } .... final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) { final ClientTransactionItem item = callbacks.get(i); final int postExecutionState = item.getPostExecutionState(); final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r, item.getPostExecutionState()); if (closestPreExecutionState != UNDEFINED) { cycleToPath(r, closestPreExecutionState); } item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ...... }} 首先获得callback然后执行callback的execute方法。这里的callback是LaunchActivityItem对象，LaunchActivityItem只实现了ClientTransactionItem中的execute方法，所以不执行postExecute /frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java12345678910public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client); client.handleLaunchActivity(r, pendingActions, null /* customIntent */); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); } 可以看到这里封装了一个activity客户端记录类，然后执行ClientTransactionHandler中的handleLaunchActivity方法，ClientTransactionHandler 是一个抽象类，ActivityThread继承了它，所以其实又回到了ActivityThread中 1234567public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) { ...... WindowManagerGlobal.initialize(); final Activity a = performLaunchActivity(r, customIntent); ...... } 这里初始化窗口管理器WindowManagerService之后，执行performLaunchActivity方法创建一个activity12345678910111213141516171819202122232425262728293031323334353637private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... //ContextImpl类继承自Context抽象类, ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) {...} ... //检查Application是否存在如果不存在尝试创建 Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... //把ContextImpl的成员变量mOuterContext赋值成activity appContext.setOuterContext(activity); //完成activity大部分成员变量的初始化 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... //要启动的activity是不是持久的，对应Manifest中Application标签的android:persistent属性 if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } //设置 Activity 当前状态为 ON_CREATE r.setState(ON_CREATE);} 拿到类加载器ClassLoader然后委托给mInstrumentation去创建activity，然后初始化成员变量，最后走到mInstrumentation.callActivityOnCreate方法12345public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 执行activity的performCreate方法/frameworks/base/core/java/android/app/Activity.java123456789101112final void performCreate(Bundle icicle) { performCreate(icicle, null); }final void performCreate(Bundle icicle, PersistableBundle persistentState) { ... if (persistentState != null) { onCreate(icicle, persistentState); } else { onCreate(icicle); } ...} 到这里终于看到了我们熟悉的onCreate方法啦！！！别着急还没完呢 回到上面realStartActivityLocked方法中，我们传入的第二个参数是top == activity，很明显最顶层的就是我们要启动的activity，所以这里是true，所以lifecycleItem = ResumeActivityItem.obtain，然后执行了 clientTransaction.setLifecycleStateRequest(lifecycleItem);方法。所以我们上面TransactionExecutor类中的execute方法中的executeLifecycleState(transaction)方法也会执行12345678910public void executeCallbacks(ClientTransaction transaction) { final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null) { return; } ... item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ...} 最终会执行ResumeActivityItem中的execute方法1234567public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\"); client.handleResumeActivity(token, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\"); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); } 跟上面思路一样一样回到ActivityThread中执行handleResumeActivity方法123456789101112131415161718public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... final Activity a = r.activity; ... ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ... a.mWindowAdded = true; wm.addView(decor, l); ... Looper.myQueue().addIdleHandler(new Idler()); } performResumeActivity就是去执行activity的onResume方法，然后创建WindowManager，把DecorView方法WindowManager中。123456789101112131415161718192021222324 public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest, String reason) { ... r.activity.performResume(r.startsNotResumed, reason); r.state = null; r.persistentState = null; r.setState(ON_RESUME); ... }/frameworks/base/core/java/android/app/Activity.java final void performResume(boolean followedByPause, String reason) { //判断是不是restart performRestart(true /* start */, reason); ... mInstrumentation.callActivityOnResume(this); ... } /frameworks/base/core/java/android/app/Instrumentation.java public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); ... } 看到了onResume，至此activity终于启动完成。 下面总结一下： 在我们调用startActivity或者startActityForResult方法的时候，通过Binder通信向ActivityManagerService发送Activity的启动请求 ActivityManagerService收到请求之后，进行合法检测和根据activity的启动模式进行一系列的初始化和准备工作 ActivityManagerService判断当前栈顶的activity是否能够复用，如果能复用并且启动模式为复用栈顶，就通知栈顶activity所在进程回调onNewIntent() 如果不能复用，那么通过Binder通知栈顶的activity执行onPause操作 栈顶的activity执行完onPause之后，开始启动将目标activity，判断目标activity所在进程是否已经启动，如果已经启动，则去执行目标activity的生命周期方法 如果目标activity所在进程没有启动，则通过Socket通知Zygote进程fork出一个新的进程，然后通过传过去的“android.app.ActivityThread”字符串反射出ActivityThread对象，并执行它的main方法初始化主线程。 新进程中的activity依次调用onCreate-&gt;onStart-&gt;onResume方法来完成activity的启动流程。 参考连接： https://blog.csdn.net/hongchi110/article/details/82890180#ch2-5https://blog.csdn.net/cjh_android/article/details/82533321https://blog.csdn.net/lj19851227/article/details/82562115","link":"/2019/03/06/technology/Activity启动流程-下/"},{"title":"Android资料","text":"Anroid学习平时收集的一些资料，方便查找。 学习 安卓资料 BeesAndroid项目旨在通过提供一系列的工具与方法，降低阅读系统源码的门槛，帮助更多的Android工程师理解Andriod系统，掌握Android系统。 算法 为了进阶高级 Android，定下了刷 LeetCode 的计划 计算机速成课 | Crash Course 字幕组 (全40集 2018-5-1 精校完成) 笔试面试知识整理 安卓学习资料 android开发诀窍 tips java算法 数据结构 通用流行框架大全 android 面试资料 亲爱的面试官，这个我可没看过！ 面试 非常全面 掘金翻译计划，翻译掘金上优质的英文文章 Android 开源项目分类汇总 自学Android编程，你需要的都在这里 有哪些 Android 大牛的 blog 值得推荐？ 一些国内 Android 开发者信息，欢迎提交修改 安卓学习自资料(安卓同道总结) 常用Github项目类库(安卓同道总结) Android 开源项目分类汇总(好多好多项目非常全) GitHub Top 100的Android开源库 &gt;AndroidStudyDemo(里面包含很多Android开发中经常用的功能的demo) Android Tips - 填坑手册 史上最全WebView使用 android开源项目分析、学习、仿写，最终理解 android sdk 源码解析——旨在帮助Android开发者更好的学习Android！ Android开发技巧的集合 正在成为史上最全分类 Android 开源代码大全~~~~ 安卓学习笔记 安卓最新源码总汇 stackoverflow上Java相关回答整理翻译 整理的android学习技巧 Android 学习资料收集 带动画的顶部导航栏 Android 开源项目源码解析 Android 史上最全WebView使用，附送Html5Activity一份 Fragment全解析系列（一）：那些年踩过的坑 Android Tips 8 Android N多窗口支持 一个清华研究生的博客站 android多主题之坑 android多主题之坑 学习 React Native 必看的几个开源项目 (第一波) 三次贝塞尔曲线练习之弹性的圆 android滤镜 屏幕上的悬图标 看，这个工具栏能伸缩折叠——AndroidCollapsingToolbarLayout使用介绍 Android App支付系列（一）：微信支付接入详细指南 App 不死之路 进程保活 Android去除烦人的默认闪退DialogAndroid去除烦人的默认闪退Dialog 手把手教你逆向分析 Android 程序 Android WebView 上传文件支持全解析 收集Android相关blog 有许多语言的视频教程的网站 系统学习Android从Activity的原理，biander,ClassLoader说起 牛人博客有okhttp retrofit等源码解析 GitHub优秀源码分类 android产品研发过程中常用的技术，技巧，实践等 Android架构集合文章 技术知识点索引，每日一读 15 个 Android 通用流行框架大全 安卓学习资料 Android高工必备技能！ 2017android 面试资料 前端资料大全 Android 技能总结，各种基础和进阶内容的资料收集 android 面试资料 Android常见的问题 国外著名 Android 开发者及公司信息 Android代码规范，可在组内推行 安卓开发规范 各种开源的书籍 真棒Android完整参考 安卓学习资料 这个项目的目标是提供一个精心挑选的Android图书馆，工具，开源项目，图书，博客，教程等等。 安卓相关博客 数据结构与算法 Android 一些重要知识点解析整理 Android百大框架排行榜 GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频 安卓面试题 面试宝典 正则表达式学习 混淆手册 AndResGuard是一个帮助你缩小APK大小的工具 工具 开发工具总结（1）之图文并茂全面总结上百个AS好用的插件 App安全（一） Android防止升级过程被劫持和换包 远离手机 / 百度网盘 下载器 适用于Android的安全，简单的键值存储 保存 缓存 翻墙 翻墙软件 翻墙！科学上网，免费ss帐号分享、ssr订阅源，免费VPN下载，获取及使用教程请看 UETool 是一个各方人员（设计师、程序员、测试）都可以使用的调试工具 百度网盘不限速下载 支持Windows和Mac 2018年1月16日更新 Android开发人员不得不收集的工具类集合 utils 使用GitHub的信息生成的简历 博客生成器 免费翻墙镜像和工具 ［Android Studio 权威教程］AS中配置强大的版本管理系统(Git、SVN、等) Android Studio详细教程汇总 如何把你的App加入白名单 MarkDown在线简历工具，可在线预览、编辑和生成PDF AndroidStudio 优秀插件汇总 Android开发中的工具类 Android内存检测工具 10个免费高逼格的icon网站 下一代Android渠道打包工具 各种Utils keystore密码找回 阿里巴巴矢量图库 Android开发人员不得不收集的工具代码 分享能增大你工作效率的工具 最新可用hosts镜像 适用于Java和Android的快速、低内存占用的汉字转拼音库 AES-256 encrypted SharedPreferences for Android. FaceBook加密技术ConCeal的一个Demo. 音频格式转换 A crash recovery framework! 崩溃恢复框架 DiffUtils是Google官方在support-v7-24.2.0新出的一个工具类，本工程为一个讲解它使用的Demo,RecyclerView刷新时 5.0 SnackbarUtils 加密库 pdf 一个Java ePub读者和解析器框架为Android。阅读 PDF Reader in JavaScript 程序员如何优雅的挣零花钱 赚钱 JSON Editor ZIP - convenience methods 硬盘缓存 代码作图 Show Vector Drawable usage in Android 2.1+ log工具 安卓逆向 反编译工具 更换icon图标 拦截手机短信验证码 打不死的小强,永不crash的Android 一个能让你了解所有函数调用顺序的Android库（无需侵入式代码） googlesamples 处理png压缩图片 Guetzli是一种JPEG编码器，旨在在高视觉质量下实现出色的压缩密度 Application Crash Reports for Android 崩溃收集 基于Android系统Api封装常用工具类 各种开发的工具 facebook UI构建框架 不用root就可以查看数据库 仿茄子快传的一款文件传输应用， 涉及到Socket通信，包括TCP，UDP通信。 http调试工具 记录主线程中执行的所有方法和它们的执行时间，当app卡顿时，将所有耗时方法直接展示给开发者，节省开发者定位卡顿问题的时间。 PDMan是一款开源免费的数据库模型建模工具 崩溃日志手机端显示 ，测试妹妹的最爱，开发哥哥的小棉袄 Transforming SVG to android VectorDrawable 根据年份统计各个版本的android手机的占有率 UC 浏览器复制，剪切 无需权限提示悬浮窗实现 Android Studio 在线查看 Android 和 Java 指定版本源码插件 Android WiFi ADB 婚礼大屏互动，微信请柬一站式解决方案 翻墙 梯子翻墙 基于腾讯浏览服务Tbs,使用X5Webkit内核,实现文件的展示功能，支持多种文件格式 doc、excel、ppt、excel、pdf 快速开发工具类收集，史上最全的开发工具类 util 免费api 免费API接口 免费api 免费API 通知工具类 git忽略文件 studio 翻译插件 studio 插件 可以查看color的引用个数 判断App位于前台或者后台的6种方法 一个超轻超薄的Android工具库，阻止三方SDK中常见的有害行为，而不影响应用自身的功能。（例如严重影响用户体验的『链式唤醒』） 记录主线程中执行的所有方法和它们的执行时间，当app卡顿时，将所有耗时方法直接展示给开发者，节省开发者定位卡顿问题的时间。 此项目基于 BlockCanary。 SharedPreferences a SharedPreferences replacement for Android with multiprocess support 监听网络的变化 帮助Android开发者，让项目在崩溃时从异常堆栈中，自动寻找Stack Overflow的回答。 Android App监听自身卸载，反馈统计 Python 资源大全中文版 [ Python frameworks](https://github.com/vinta/awesome-python Android 网络和数据库 OKHttp源码解析(一)–初阶 深入解析http和https那点事 可靠，灵活，高性能以及强大的下载引擎。 本库是一款基于RxJava2+Retrofit2实现简单易用的网络请求框架 主要是封装有Http网络隔离框架、日志、缓存、加载等待、toast、页面状态布局管理、权限、自定义view等常用的集合框架，减少开发成本，提高软件体验！ Retrofit分析-漂亮的解耦套路 Retrofit分析-经典设计模式案例 Retrofit2完全教程 你真的会用Retrofit2吗?Retrofit2完全教程 封装了okhttp的网络框架 android平台ssl单双向验证 支持HTTP/HTTPS, 自动维持Cookie, 异步/同步请求, 大文件/多文件上传, 文件下载; 支持304缓存, 302/303重定向, 支持代理服务器 从HTTP到HTTPS OKHttp源码浅析与最佳实践 HTTP响应头信息和请求头信息详解 AndroidHttpCapture网络诊断工具 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能 断点上传 网络开发框架 基于 ViewModel + LiveData + Retrofit + RxJava 封装的网络请求框架 RxJava + Retrofit封装，包含对相同格式请求数据、相同格式返回数据处理，显示Material Design加载dialog，文件上传下载进度展示、全局异常捕捉。 安卓下载库 Android高性能数据库框架 Android另一个高性能数据库框架 轻量但功能强大的ORM和SQL查询生成 微信的数据库 LiteOrm Android 进阶 Android的Context Manager（服务管理器）源码剖析 Android应用程序启动过程源代码分析 JVM结构、GC工作机制详解 JVM结构、GC工作机制详解 一种进程保活的方法 使用EventBus进程间通讯 android framework层源码解析，不定时更新哈 RxJava Essentials 中文翻译版 Rx和RxJava文档中文翻译项目 RxJava-Android-Samples RxJava的调试器 RxJava Javadoc Android 适配 Android屏幕适配全攻略 巧用dimens适配多个分辨率 显示gif图片 android各版本分辨率适配 今日头条屏幕适配方案终极版，一个极低成本的 Android 屏幕适配方案 Android UI适配方案 一行代码搞定安卓全屏幕适配——简单粗暴-低入侵，无继承，简单高效 一种粗暴快速的Android全屏幕适配方案 Android 插件化和更新 滴滴的热更新 Android插件框架，免安装运行插件APK ，支持独立插件和非独立插件 阿里巴巴 强大的Android动态组件框架 美团热修复 Robust是具有高兼容性和高稳定性的Android HotFix解决方案.Robust可以立即修复错误，而无需发布apk。 Dex分包之旅 Sample app to demonstrate multidex 当你准备开发一个热修复框架的时候，你需要了解的一切 Android中的动态加载机制 深入理解插件化 插件化 AndFix 可以快速开发电商应用中既要求体验又要求灵活性的页面功能 实现Android App多apk插件化和动态加载 Alibaba-AndFix Bug热修复框架原理及源码解析 Nuwa, pure java implementation, can hotfix your android application 热修复，没你想的那么难 Android 插件化原理解析——Service的插件化 Android 热修复其实很简单 为什么我说Android插件化从入门到放弃？ Android热修复实践应用–AndFix 掌阅Android App插件补丁实践 热修复框架 最简单易懂的Android插件补丁框架 Android应用增量更新 腾讯的热更新 微信tinker补丁管理，后端代码+客户端sdk Android应用增量更新 Android app 增量更新 增量更新Demo和Library 跨平台插件化方案 android app自动检测更新库 TinkerPatch 接入指南 万能更新库，修改只要一点点 增量更新等 美丽说的 热修复方案 Android 版本更新 支持强制更新 安卓应用自动更新 热修复——深入浅出原理与实现 Android 混合开发 CacheWebView是Android WebView 缓存的自定义实现 android java和javascript桥梁 超完整的React Native项目，功能丰富，适合学习和日常使用 Android基于腾讯X5内核的WebView(超级浏览器)，拥有文件上传、下载、浏览（支持PDF/PPT/DOC/EXCEL/TXT格式）、Android与JS的交互、视频播放、自定义进度条、下拉回弹等功能 腾讯的Hybrid 方案 H5框架 轻量可扩展 Android WebView 和 Javascript 双向交互框架 .从浏览器中打开客户端 2.实现在客户端内部与h5混编 WebView Android WebView 混合应用基础架构 跨平台热更新方案 Js双向通信 基础WebView AgentWeb 是基于 Android WebView 一个功能完善小型浏览器库 。 使用很方便 ， 集成进你应用 ，只需几行代码 。 React Native 官方文档。 a collection of simple demos of React.js 为WebView中的Java与JavaScript提供【安全可靠】的多样互通方案 React Native 实例 - BBC新闻客户端 React Native开发技术周报 React Native 高质量学习资料汇总 Android 项目中嵌入 ReactNative 模块 React Native新建项目 这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。 React Native 研究与实践 React Native 学习资源精选仓库(汇聚知识，分享精华) React Native优秀博客，以及优秀的Github库列表 React-Native学习指南 致力于帮助Android开发者转react-native开发 react-native 热更新 react-native掘金客户端 react-native 底部菜单 一个基于 React Native 的 Android 企业级应用。 基于React-Native、Redux实现的「漫画书」App，兼容Android移动端 Native navigation library for React Native applications react-native wrapper for android BottomSheetBehavior React Native 二维码扫描 高仿美团客户端 React-Native版，支持iOS、Android kotlin kotlin 官方文档翻译 Kotlin项目 Kotlin 视频教程 组件化 + MVP + Retrofit + RxKotlin + Dagger2实现的一款用Kotlin语言编写的多媒体类应用 一个用Kotlin写的简单漫画APP Kotlin 资源大全，包括教程文章、开源库和框架、Demo 等，由掘金技术社区整理和维护。 精彩的Kotlin相关的东西 kotlin 例子 kotlin 官方例子 kotlin 协程 第一本 PWA 中文书 kotlin 协程 Kotlin for android developers in chinese. Kotlin 开发框架 使用Kotlin撸一款Eyepetizer，学习Kotlin语言 超完整的Android Kotlin 项目，功能丰富，适合学习和日常使用。 KOIN - Kotlin的一个实用的轻量级依赖注入框架 kotlin文件选择器 Λrrow是Kotlin中的类型化函数式编程库。它包括最流行的数据类型 kotlin android 例子 一个支持多种场景的Android换肤框架 Android应用程序开发的一套Kotlin扩展。 用Kotlin去提高生产力 Flutter flutter 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档 Flutter完整项目，玩Android-Flutter版客户端。 Flutter完整项目，WanAndroid客户端，BLoC、RxDart 、国际化、主题色、启动页、引导页，拥有较好的项目结构&amp;比较规范的代码！ 超完整的Flutter项目，功能丰富 基于Google Flutter的开源中国客户端，支持Android和iOS。 Android 音视频开发 视频播放器 直播推拉流 音视频，直播SDK，rtmp推流，录制视频，滤镜。百万用户，线上迭代半年，已经稳定。 Android上基于FFmpeg开发的视频处理框架 包含美颜等40余种实时滤镜相机，可拍照、录像、图片修改 仿微信拍照Android控件（轻触拍照，长按摄像）微信拍视频 Easily integrate Camera features into your Android app Android播放器基础库，专注于播放视图组件的高复用性和组件间的低耦合，轻松处理复杂业务。 安卓平台下，图片或视频转化为ascii，合并视频用到ffmpeg库。后期会加入带色彩的ascii码图片或视频 音乐播放器，可播放本地音乐，百度音乐，qq音乐，虾米音乐，网易云音乐 是七牛推出的一款适用于 Android 平台的短视频 SDK，提供了包括美颜、滤镜、水印、断点录制、分段回删、视频编辑、混音特效、视频剪辑、本地转码、视频上传在内的多种功能，支持高度定制以及二次开发 视频播放器（IJKplayer），HTTPS支持，支持弹幕，支持基本的拖动，声音、亮度调节，支持边播边缓存，支持视频本身自带rotation的旋转（90,270之类） 最新版ffmpeg3.3-android，并通过CMake方式移植到Android中,并实现编解码，转码，推拉流，滤镜等各种功能 支持直播的播放器 ，支持手势 亮度，音量，快进，等手势 ，广告视频预览 ，视频清晰度切换 Android录屏框架，目的是使用system uid实现（内录）submix的录制。 大牛直播，跨平台(windows/android/iOS)推送(rtmp)、播放器(rtmp/rtsp)，支持录像、导播、动态视频合成、实时快照、水印、音频混音、互动等，国内外为数不多不依赖开源框架，业界真正靠谱的超低延迟(1秒左右)。 添加 视频录制 音频 混合器 仿网易云音乐 安卓版，netease android，音乐播放器 在线 下载 视频录制 视频压缩（使用FFMpeg）Android Video Recorder/Video Compressor 音乐播放器 视频观看 bilibili非官方客户端 一款优雅的遵循 Material Design 的开源音乐播放器 A material designed music player for Android 材料设计的 音乐播放器 recyclelerview中自动播放/暂停来自网址的视频。视频中自动播放视频。 利用FFmpeg视频录制微信小视频与其压缩处理 即时通讯 视频进度 【VLC-Android】vlc-android简例 Android视频录制 Android上定义播放器控件UniversalVideoView 安卓视频播放器 全屏 播放器列表全屏 仿今日头条UI 控制视频播放 VCL-Android VCL-Android 直播解决方案 Android/iOS video player based on FFmpeg n3.0, with MediaCodec, VideoToolbox support. android platform. multirmedia Player. play video 视频的最小化 一个面向Android设备的互联网免费视频播放客户端 android video player base on ijkplayer 视频剪辑 一个视频播放列表demo，视频播放使用的ijkplayer,正在播放视频拖动到不可见区域小窗口播放，可全屏切换一个视频播放列表demo，视频播放使用的ijkplayer,正在播放视频拖动到不可见区域小窗口播放，可全屏切换 一个可扩展的媒体播放器 goole的 Lollipop (5.0) 屏幕录制实现 Android中直播视频技术探究之—基础知识大纲介绍 微信小视频+秒拍,FFmpeg库封装 滑动时自动播放/停止的功能 PLDroidPlayer 是一个适用于 Android 平台的音视频播放器 SDK，可高度定制化和二次开发，为 Android 开发者提供了简单、快捷的接口，帮助开发者在 Android 平台上快速开发播放器应用。 基于RTMP协议的直播sdk Android录音的demo 基于IjkPlayer的控制器，支持手势操作，滑动快进，快退，支持，上滑音量亮度的变化，支持指点位置播放，播放源的切换 音乐播放器 XMPP开源项目 仿微信录制视频 仿泰捷视频最新TV版 Metro UI效果. 2、仿腾讯视频TV版(云视听·极光) 列表页 一款用集成多人视频通话，群聊功能应用，多达4同时实现通话，多人群聊 直播技术 视频直播技术 基于RTMP和RTC混合引擎的在线视频连麦互动直播 Android TV直播电视节目 ,包含各央视频道及卫视频道 RTMP 推流器，RTMP播放器（秒开），跨平台（Win,IOS,Android）开源代码 仿爱奇艺视频，腾讯视频，搜狐视频首页推荐位轮播图 可以拖拽的视频播放器 很好的一个音乐客户端 视频播放器 可移动的视频 图像 视频项目 FFmpeg Android 好看的效果和牛逼的功能 RxJava 2 和 Retrofit 结合使用的几个最常见使用方式举例 一款仿miui，仿小米，日历，周日历，月日历，月视图、周视图滑动切换，农历,Andriod Calendar , MIUI Calendar,小米日历 Andorid 任意界面悬浮窗，实现悬浮窗如此简单 支持异步弹出软键盘，实时弹出软键盘，关闭软键盘，软键盘弹出不遮挡指定区域 iSparta 是一款 APNG 和 Webp 转换工具。 分享 GitHub 上好玩、容易上手的项目，帮你找到编程的乐趣。欢迎推荐、自荐项目，让更多人知道你的项目 eventbus3插件 使用ionic3/ag4编写模仿京东商城的demo 用RecyclerView实现无限轮播图，有普通版和3d版 一款android自动生成表格框架 Excel excel 切换不同的数据状态布局，包含加载中、空数据和出错状态，可自定义状态布局。 跟miui一样的自动滚动截屏 Excel excel 表格 手势浏览器 Android全手势浏览器 使用Snake，Android也可以轻松实现类iOS滑动关闭效果 滑动退出 Android 股票图表库 高颜值、好用、易扩展的微信小程序 UI 库，Powered by 有赞 简洁优雅可点击的toast控件，仿手机百度9.0，无BadTokenException风险。 Android下WIFI隔空apk安装 年会抽奖项目 Good looking curved Android SeekBar 监控日志并区分日志类型. Android上一个优雅、万能自定义UI、支持周视图、性能高效的日历控件 一个自定义的轮播控件 一个高仿闲鱼键自定义数字键盘特效 自定义下拉刷新和上拉加载框架 Android应用内展示word、excel、pdf、ppt等文件 [开源] Android InDoorView 室内选位控件 该库使用OpenGL着色器在运行时对ExoPlayer视频应用效果 在线制作sorry 为所欲为的gif https://sorry.xuty.tk/ TextPathView是一个把文字转化为路径动画然后展现出来的自定义控件 可以使任何一个View or layout展示出不同形状，并且代替重复创建不同shape文件 Android TreeView is used to display data in tree structures.树形 可以定制一些简单的路径，按想要的绘制顺序添加，SimpleLineView会依次展现路径动画。path 线性图 表情 一个支持多种场景的Android换肤框架 Android 主题换肤的开源库（插件化换肤） k线图 图表 Android开发专业k线图表组件，支持JDK,MACD,MA，VOL等指标，后续指标陆续更新 Android拼图支持库，想法来自Layout for Instagram。2.0发布了，支持超级酷炫的斜线拼图，圆角模式 地图点 一款万能遥控器的交互效果 Android平台下的富文本解析器，支持Html和Markdown A tool to edit colors in Lottie animations Android动画 KChart for Android ；股票k线图 字母，符号，数字&amp;自定义安全键盘 直播间礼物动画控件 小程序生成图片库，轻松通过 json 方式绘制一张可以发到朋友圈的图片 停车王车牌键盘-Android Android 仿钉钉、微信 群聊组合头像 各种自定义图表库，使用简单，支持扩展 一个android插件，允许你轻松地改变你的设备语言。 一个扩展Android toast框架的库。 Android Sku属性选择器, 类似于淘宝，天猫，京东，支持MVVM，直接使用 loading动画 A powerful library that manage Fragment for Android! Android integration of multiple icon providers such as FontAwesome, Entypo, Typicons,… 一起来撸个朋友圈吧 打造通用的popupwindow MediaUtils : a demo of record audio and video.一个在 Android 上实现录像和录音功能的小例子。 漂亮的区间选择器，贝塞尔曲线优雅实现 轻松实现Android ShareElement动画 堆叠头像的点赞Layout 随机布满屏幕的文字，飞入飞出动画效果的控件 自定义组织机构图 &amp; 层次图 一个顺滑的、高度自定义的滚轮控件和选择器，支持类似 iOS 的 3D 效果 Android优秀开源框架汇总 高仿抖音照片电影功能 Android 微信自动回复功能，使用的知识为 AccessibilityService。 沉浸式 RecyclerView 分割线 Android物料设计文件管理器 RecyclerView最顶部的itemView，会随着手指滑动实现收缩隐藏与放大显示，并伴随recycler的回收与复用 编译时注解 自动生成注册文件 dialog google api可一个统计应用的使用 微信个人号接口、微信机器人及命令行微信，三十行即可自定义个人号机器人。 五种实现activity动画切换的方式 可展开的TextView 一款支持复数运算和解方程等功能的计算器 星期选择 安卓页面编辑 A rich text editor sample 类似魅族清除内存的卡片效果 加载失败 一个带渐变层叠动画的左右滑动效果（类似于探探、tinder） 卡片 在任何非 MIUI 设备上体验小米系统级推送。 类似滴滴地图上汽车移动路线 带动画的启动页面 The Google I/O 2017 Android App 简单易用的第三方可扩展支付框架。 用于调试自适应图标的Android应用程序。 文本编辑器的破解 一款基于Android开发的纵版飞行射击游戏 一个可以让自己子视图滚动起来的控件(仿[淘宝头条])。 可以展开的LinearLayout A library that manages state using RxJava 2.状态管理 柱状图 自定义控件 刻度尺 自定义控件有备选词的完形填空，无备选词完形填空 Android歌词控件，支持上下拖动歌词，歌词自动换行，自定义属性。 进度按钮自 自定义view实现的滚动刻度尺 一个小巧且高效的线性图表组件。 那些你应该知道却不一定知道的——View坐标分析汇总 Andorid自定义圆形渐变色进度条的从实现到开源 Android自定义控件三部曲文章索引 Android自定义密码输入框控件 一步一步教你 150 行代码实现简书滑动返回效果 一步一步教你 150 行代码实现简书滑动返回效果 android 自定义键盘，在页面嵌入的。使用还算简单 自定义view3步的视频讲解 仪表盘开源项目 Android Canvas练习 下载进度动画 模仿掌上英雄联盟能力分析效果 仪表盘 蜘蛛图标 网状图 可旋转的扇形图，可以更改样式。 在 Android端app上，自定义View，仿一个斗鱼web端滑动验证码。 可以展开的textview 自定义圆形菜单 Switch View开关按钮 利用三阶贝塞尔曲线模仿QQ空间直播时右下角的礼物冒泡特效 数字增加动画的 TextView 类似股票实时联动效果 自定义view下雪效果 圆形进度条 Android-Charts 图表 一个可以自由定制外观、支持拖拽消除的MaterialDesign风格Android BadgeView 小红点提示 水波纹效果加载动画 加载动画 水波纹效果的选择器 手势解锁 android 4.4以上沉浸式状态栏和沉浸式导航栏管理，一句代码轻松实现，以及对bar的其他设置 A draggable PointView for Android. qq红点拖拽效果 查看pdf 基于Glide V4.0封装的图片加载库，可以监听加载图片时的进度 权限管理 夜间模式 强大的下拉刷新库，定制任意Header。比官方SwipRefrehLayout处理更加友好(Kotlin、Java双版本) Making Camera for Android more friendly. 📸 相机 一个强大的下拉刷新框架 引导页 点亮 高亮 文件管理器 文件夹 各种开源框架的demo 优雅地处理加载中，重试，无数据等) 引导界面滑动导航 + 大于等于1页时无限轮播 + 各种切换动画轮播效果 安卓选择器类库，包括日期选择器、时间选择器、单项选择器、城市地址选择器、车牌号选择器、数字选择器、星座选择器、生肖选择器、颜色选择器、文件选择器、目录选择器等，可自定义顶部及底部界面，可自定义窗口动画…… 可以读取，编辑和写入CSV文件。 Android 检索手机目录方式的文件选择器，轻量且界面友好，定制性高 由RxJava提供的Android运行时权限 为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来） Custom status view for Android.顶部状态加载 Android 富文本编辑器 Android runtime theme library 主题更换 Android-skin-support: 一款用心去做的Android 换肤框架, 极低的学习成本, 极好的用户体验. 只需要两行代码, 就可以实现换肤, 你值得拥有!!! 可拖拽的流式布局 机票座位选择 一个用于app指向性功能高亮的库 引导页 github上的安卓开源库汇总 Android源码大放送之material design类型 消息提示AppMsg代替系统Toast Android显示gif图片 桌面渲染可显示带根号的数字运算 Android聊天界面 Android图表 股票实时查询联动列表 股票实时查询联动列表2 主题换肤 完全仿微信的图片选择，并且提供了多种图片加载接口，选择图片后可以旋转，可以裁剪成矩形或圆形，可以配置各种其他的参数 Android Dynamic Action，简称DA，是一种简便、可变Action的实现方案。你可以像访问网页一样地访问Activity。 谷歌材料设计风格的日历控件 有与微信相同的下级activity联动效果 带动画的顶部导航 一个强大并且灵活的RecyclerViewAdapter tv常用效果控件，包括焦点、边框处理等 一个Android自定义粘性控件(跟qq气泡相似) 正弦波浪 一个安卓中处理图片的各种形状库 安卓快速开发框架易维护 给EditText添加Tag 下拉刷新A custom view can pull up and down,support ScrollView,ListView,RecyclerView,WebView and all another views, easy to use MaterialDrawer 抽屉 代码家的veiw的各种动画库 Android端的Bootstrap 点击指示动画 可以让子View展开的动画 recyclerview的动画 Android Design library 仿UC天气下拉和微信下拉眼睛 TLint for 虎扑体育 基于Dagger2+RxJava+Retrofit开发，采用MVP模式 一个漂亮的弹出框 弹出提示气泡 这是一个圆形的小部件,可以用来显示倒计时定时器或计数定时器 在状态栏显示toast 提示 Android库来简化检测手势 可以简单的获取设备的信息 可以拖动滑动图片 谷歌风格的语音识别动画 小点可旋转 EditText in Material Design 单页显示3个Item的ViewPager炫酷切换效果，适用于Banner等 自定义toast 这是Android一个雷达扫描显示的扫描图，超高仿QQ附近的人搜索展示 切换页面的圆形动画效果 android 悬浮窗菜单，可在launcher或app中使用 android 动画库 android Material下拉刷新库 android 模糊效果 一个android密码视图看起来像支付宝支付密码在微信应用程序和应用程序 一个圆形梯度Android进度条 Android开源弹幕引擎·烈焰弹幕使 谷歌开源的响应式编程库 类似RxJava 很棒的音频部件 一个Android部件为选择项,旋转轮 Android键盘面板冲突 布局闪动处理方案 AndroidImageEdit 安卓设备上图形编辑开源控件，支持自定义贴图 图片滤镜 图片旋转 以及图片剪裁操作 贴纸标签相机,功能:拍照,相片裁剪,给图片贴贴纸,打标签 单手操作图片控件 镜像、置顶、缩放、移动 一款加载动画，不同的物体加速下落砸到了文字上，文字逞阻尼效果，向下弯曲并像橡皮筋一样弹动回去的效果 各种加载动画 谷歌的MVP MVP例子 一个开放的学习项目基于材料设计支持库 一个通过动态加载本地皮肤包进行换肤的皮肤框架 3d旋转切换view，类似旋转木马效果。可以自动切换！ 仿微信小视频录制，基于GitHub上的javacv 导航标签栏和丰富多彩的交互 一个很酷的搜索视图动画库 音频软件中可以跟着声音跳动的wave 一个Android拼图的demo，类似于Layout，Moldiv，美图秀秀的拼图功能 可以展开的按钮 也许是最良心的开源表情键盘解决方案 设置状态栏样式在Android应用程序 沉浸式状态栏 高仿微信手势滑动返回 在ListView中实现日历视图 可翻转的view Android流式布局，支持点击、单选、多选等，适合用于产品标签等 富文本编辑 底部的菜单 减少APP被杀死的机率 材料设计的底部导航栏material design 用于学习RxJava操作符的APP 通过RecyclerView实现的联系人 这是一个基于Flux架构,使用Retrofit RxJava Dagger2创建的示例 可以张开的viewpager 垂直的viewpager 各种各样的recycleview 100多种UI效果，加载动画，viewpager翻，各种菜单等等转等等 下拉刷新的ExpandableListView 可以添加头部的ScrollView 类似UC 非常全的RxJava学习资料 下拉刷新库，非常牛掰 点赞的动画效果 Andorid屏幕截图类库 基于Theme的Android动态换肤库，无需重启Activity、无需自定义View，方便的实现日间、夜间模式 viewpager翻转效果 屏幕手势锁 实用的下拉菜单 带动画的ExpandableListView 各种Material Design 效果 多线程下载 微信抢红包插件, 帮助你在微信群聊抢红包时战无不胜 图表库 牛逼的图表库 又一个牛逼的图表库 简单的图标库 recycleview加头部 弹出菜单 Android分屏开发 Android富文本编辑器edittext textview高级用法 Android字体库 高仿网易新闻首页Tabs添加，删除，排序 一个非常全的沉浸式顶栏的例子 用于展示注册进度的view 垂直跑马灯；学名：垂直翻页公告 带动画的类似 PIN 的 EditText 基于Android系统Api封装常用工具类 可以读取SD卡，asset文件夹，或者网络下载的pdf文件的widget 手势滑动返回的Fragment 一种可根据展开是否超出屏幕来判断父控件是否自动滚动的ExpandableLayout 一个支持多种状态的自定义View,可以方便的切换到：加载中视图、错误视图、空数据视图、网络异常视图、内容视图 锁屏 截屏 Animated SVG Drawing for Android 一个类似支付宝、微信输入支付密码的控件 那些酷炫的RecyclerView开源库整理 能够快速的为一个Activity里的任何一个View控件创建一个遮罩式的导航页 流程只是示意图 Android 多主题框架 Android 多主题框架又一个 ProgressBar 顶部进度条 解析XML 图片裁剪 旋转 动画的插值器 手势返回 Lifecycle handling APIs for Android apps using RxJava这里提供的实用程序允许基于Activity或Fragment 生命周期事件自动完成序列 安卓手势控制 控制图片 材料设计的日历 终端系统监控仪表板 Material Design 系列控件samples,讲了Material Design 系列新控件的使用方法和一些场景示例，使用详情请看对应博客，持续更新中… 表情 抛物线的UI绘制教程 按钮点击状态 一个强大的selector注入器，它可以让view自动产生selector状态，免去了写selector文件的麻烦。 可伸缩布局方案 一个用粒子动画显示文字的 Android 自定义 View textview 一个帮助您完成从缩略图到原图无缝过渡转变的神奇组件 安卓平面图 布局图 A periodic text updating library 广告轮训效果textview 安卓微信防撤回神器 ! 新闻加载效果 图片放大效果 列表多类型布局方案 Image Cropping Library for Android 图片裁剪 图片切换 旋转木马效果 android 自定义日历控件 支持左右无限滑动 周月切换 标记日期显示 跳转到指定日期 利用RecyclerView.ItemDecoration实现顶部悬浮效果 沉浸栏 瀑布流式的时间轴 优雅地刷新Recyclerview(可配合大多数Adapter ； 一行代码刷新相应viewType ； 支持facebook的shimmer加载效果 ； 仿美团城市选择界面，可直接用在实际项目中 动画 一个支持 AOP、栈控制、跨页面带信、和动态变更映射的 URL 路由库。 DialogFragment 的封装 Android 快速实现新手引导层的库 在QQ登录界面上加点特效 动态主题 A Markdown parser for javascript 解析Markdown 一行代码实现Android软键盘和EditText各种交互 提高 Android UI 开发效率的 UI 库 Groupie helps you display and manage complex RecyclerView layouts. 说话按钮变化 Google ARCore SDK for Android Studio 通过手势滑动关闭Activity的库 下拉刷新demo 照相机 悬浮的activity Android RichText 富文本解析器，支持网络图片，图片和链接点击事件 点击阴影效果 横向进度条 伸缩的布局 缩放 知乎 x RxJava Meetup 点击查看动画 viewpager with parallax pages, together with vertical sliding (or click) and activity transition Android三种姿势带你玩转360度全景图功能 A simple library to add Emoji support to your Android app. 表情 仿小米运动的运动记录界面 动态背景界面 How to create instagram like Gradient color transition in android. 自动, can be selected to auto generator findViewById code in Activity or etc, 圆形 圆角图片 点击浮动动画 泡椒网游戏SDK Float View(悬浮窗) 简单的下拉刷新框架 RecyclerView高仿效果合集 用RecyclerView实现无限轮播图，有普通版和3d版 各种金融类的自定义View,在不断完善中…. Android 分页 安卓饼状图 TextView 点击链接到某处 自定义安全键盘 可以在Android上运行仪器测试时生成快速确定性的屏幕截图。 Android OpenGL ES从零开始的Demo TextView 滚动显示 可展开的RecyclerView 一个简洁而优雅的Android原生UI框架，解放你的双手 Android 一键加入侧滑返回 (类似“小米MIX”和新版“即刻”滑动返回) Aurora IMUI 是个通用的即时通讯（IM）UI 库，不特定于任何 IM SDK。 描边/内间距/四个角不同弧度（包括圆角）ImageView 一个通用的Android端弹窗管理框架,内部维护弹窗优先级队列 具备弹窗管理扩展功能 类似淘宝的商品详情页，继续拖动查看详情，其中拖动增加了阻尼 仿斗鱼直播送礼物和连击效果动画 Android复杂红包雨实现，带点击事件处理 垂直纵向的TabLayout、轻松创建纵向导航 散列图效果 雪花飘落效果，可以实现自定义 Android 室内场景构建组件，帮你快速的完成室内场景 View 的展示 多边形的绘制 绘制多边形 各种带背景的textview 仿魅族内存清理的UI 支付密码输入框 点赞的动画 好看的引导页 滑动的时候底部和顶部出来 自定义View和属性动画结合实现支持动态修改指示点位置，拖拽或点击改变指示点位置，点击位置监听及切换动画自定义的圆点指示器。 可自定义动效的卡片切换视图 底部Tab 顶部Tab 各种Tab页面 一种支持多种弹幕样式的弹幕视图控件 使得 SQLite 和 Excel 之间相互转换更加便捷。 viewpager 图片查看 密码锁 波浪加载动画 沉浸式状态栏 仿nice图片上打标签控件 RecyclerViewSidebar 选择器 帮助快速查阅对应分组的侧边栏 Android广告图片轮播控件，支持无限循环和多种主题，可以灵活设置轮播样式、动画、轮播和切换时间、位置、图片加载框架等！ 通用的广告栏控件，让你轻松实现广告头效果。支持无限循环 半圆锯齿背景虚线边框组合实现简单优惠券效果，可实现一些简单组合 卡卷 跟随手势滑动，显示隐藏标题栏、底部导航栏及悬浮按钮的Android Behavior Library 类似新闻加载的动画库 Android 立体的3d Android各种粒子效果 UltraViewPager 各种风格的ViewPager 仿微信(weixin wechat)实现的朋友圈 评价的进度 自定义SeekBar，进度变化由可视化气泡样式呈现 应为需要实现一个类似于双向滑动的SeekBar 离散的ScrollView 图片的展示 1行代码让你的ViewGroup拥有华丽的布局动画！ RecyclerView侧滑 RecyclerView解决方案，支持addHeaderView，addFooterView和页面加载 这是一个包含一个有趣的动画的自定义拉到刷新布局的项目 下拉刷新 Android Gradle Java应用程序模板 一个圆形的ImageView for Android 基于RecyclerView的Android的材料横向日历视图 CoordinatorTabLayout是一个自定义组合控件 各种toast 请求网络之后的各种状态的展示 loading 悬浮的 材料风格的查找 MaterialSearchView 材料风格的查找 TextView跨度行为，支持惊人的recyclelerView功能的流式布局行为 淡入淡出的textview 新闻客户端的加载动画效果 Behavior实现的漂亮的效果 从桌面启动应用 桌面操作应用 Android日历 仿小米 华为 滴答清单 365日历（农历），周视图 月视图 平滑滚动 节假日 week or month calendar An imageView can auto scroll with device rotating.图像跟随手机转动 漂亮的toast text path显示动画 Android 单击listview弹出popupwindow弹出框 可缩放矢量图形为Android android高仿微信表情输入与键盘输入详解 还在羡慕微信／微博的图片处理?－android酷炫图片处理(下) 悬浮球-一个服务开启悬浮球，任何界面都可以使用 vr 虚拟现实的app Material Design 的搜索框 可展开的RecycleView 不一样的toast 点赞的动画 显示gif图 一个简单，强大的广告活动弹窗控件 为任何视图添加一个headview和支持ItemView卷轴时坚持顶部导航器。 密码解锁的样式 下拉刷新的RecycleView Androi可拖拽的ListView 高仿微信数字键盘、支付键盘（密码键盘） 上拉刷新下拉加载 app icon 上加气泡 仿应用宝下载进度条 类似于映客，快手，等直播APP布局，直播刷礼物特效，定时清除礼物，计时器，圆形头像，横行listview等！！！， TextView中输入表情 树形RecyclerView 这是一个简单而精致的 Fragment 菜单控件，它可以让你切换 Fragment 的时候不再单调、死板。 仿网易新闻加载效果 五星评价 AppBarLayout 下拉拉伸 仿锤子 拖拽选择 使用风扇布局管理器可以实现水平列表的项目像风机叶片recycleview ViewPager转换效果 高仿微信底部状态栏的轻量级库 日历 和支付宝一样的密码验证框 RecyclerView下拉刷新 安卓选择器类库，包括日期时间选择器、单项选择器、地址选择器、颜色选择器、文件目录选择器、数字选择器、星座选择器 音乐播放器中显示歌词 android高仿钉钉和小米的自定义日历控件 googledemo 日期选择器 Android 中各种绚丽的效果 像微信中的那种下雨的效果 下表情 无缝为Activity、Fragment、任何View设置加载（loading）、重试(retry)和无数据（empty）页面。 神交互。模仿饿了么详情页可以跟随手指移动 viewpager变详情页 股票中固定左边滑动 仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果 圆形进度条 RecyclerView实现的excelPanel左右上下滑动 类似QQ空间，微信朋友圈，微博主页等，展示图片的九宫格控件 通过MarqueeFactory来提供各种样式的跑马灯View， 支持自定义跑马灯ItemView 广告 一个带伸缩位移旋转动画的购物车按钮 各种各样的Notification效果 嵌套滚动的多种实现方案Demo excelPanel 上滑和左滑 下载进度按钮 淘宝 VirtualLayout是一个针对RecyclerView的LayoutManager扩展, 主要提供一整套布局方案和布局间的组件复用的问题。 密码输入 加载动画 loading 支持水平方向上滑动和竖直方向上的滑动，直接修改的官方提供的ViewPager的源码 精仿iOS的PickerView控件 wheelview 各种加载动画 activity场景切换动画 Android进程保活招式大全 进程保活的一般套路 android 后台运行 系统进程守护 Android 端外推送到底有多烦？ 集成第三方推送最佳实践 推送sdk 推送集成 二维码 A better way to operate quick response code in Swift各种类型二维码 几行代码快速集成二维码扫描功能 QR code ASCII art for java 二维码 图片二维码 艺术二维码生成器 （GIF动态二维码、图片二维码） 一个长按扫描 View 上的二维码的工具库。webView 也可以。 一个很全的二维码扫描例子 zxing二维码扫描例子 ZXing and ZBar 二维码 Gradle多渠道打包(动态设定App名称，应用图标，替换常量，更改包名，变更渠道) 快速多渠道打包工具 Gradle 多渠道打包实践 最简单的Android studio发布Library到Jcenter Android Signature V2 Scheme签名下的新一代渠道包打包神器 git Git GUI使用方法 闯过这 54 关，点亮你的 Git 技能树 (二) 常用git命令手册 有关 git 的学习资料 Android 测试和性能优化 安卓单元测试 简化测试 Android自动化测试例子 Google官方提供的Android UI自动化测试的框架. leakcanary测试 (MVP+RxJava+Retrofit)解耦+Mockito单元测试 经验分享 Android严苛模式StrictMode使用详解 Mocking framework for unit tests written in Java Android 单元测试框架 Android 单UI试框架 Android客户端性能优化 App瘦身最佳实践 App优化之性能分析工具 360开源又一力作——ArgusAPM移动性能监控平台 页面启动速度优化利器 预加载 支持网络数据、网络图片、本地图片、数据库查询及文件I/O等各种耗时操作的预加载 Android APP 性能优化的一些思考 Android瘦身不反弹最佳实践 JS Vue2 全家桶仿 微信App 项目，支持多人在线聊天和机器人聊天 js 图表框架 vue demo 工作中经常用到github上优秀、实用、轻量级、无依赖的插件和库 js库 Free Bootstrap 3 Admin Template HTML5弹幕播放器 使用JavaScript，HTML和CSS构建跨平台桌面应用程序 從零開始學 ReactJS（ReactJS 101） vue.js demo Javascript框架学习 Javascript engine Vue.js 点赞效果 vue写的网易音乐客户端 Vue 全家桶 + axios 前端实现登录拦截、登出、拦截器等功能 基于Vue2.0 + vuex + vue-router + axios +更少的图片社交分享应用程序 Material design for AngularJS Material Design components for Angularhttps://github.com/angular/material2) vue2.0版英雄联盟助手 Vue2.0版-仿知乎日报SPA js 可伸缩布局方案 Vue.js相关组件 案例 vue写的豆瓣案例 Vue2.0版-仿知乎日报SPA 基于 G6 和 React 的可视化图编辑器 基于 G6 和 React 的可视化图编辑器 Vue.js 源码解析 腾讯移动Web前端知识库 手摸手，带你用 vue 撸后台 VUE 组件 VUE2.0 优雅的H5 下拉刷新。零依赖，高性能，多主题，易拓展。 vue组件 Vue写的网页 vue2.0+vuex+vue-router+vux 基于React的滑尺数值选择器 NDK AndroidStudio NDK开发最佳入门实践 图像 Similar to Lottie. Render After Effects / Animate CC (Flash) animations natively on Android and iOS, Web. 使用 SVGAPlayer 在 Android、iOS、Web中播放 After Effects / Animate CC (Flash) 动画 Android Image Edit Lib. Android 图片编辑库，微信图片编辑库 截屏 屏幕截图 轻量级安卓水印框架，支持隐形数字水印 查看大图 android图片压缩的处理 图片压缩 裁剪 图片压缩工具 一个Android转换库，为(picasso)提供各种图像转换 图片选择工具 LeafPic是一个流畅的，材料设计的替代画廊 相册选择器 Android裁剪图像的demo 图片的模糊效果 可能是最接近微信朋友圈的图片压缩算法 可以给图片添加标签 放大 缩小 删除 Android动态模糊图像 Android仿微信图片选择器 图片选择器 多图片像选择器 Android获取图片的三种方法 给图片加标签 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 图片选择 world level Gallery , from Telegram ，QQ 相册风格，相册选择器 图片模糊效果 仿微信图片选择器 各种类型的imageview显示 圆角等 实现imageview的各种效果 android多图选择器 图片/视频 单选or多选，以及视频录制。 一个可配置的迷你版轻量级 Label 辅助类，支持多种配置效果。图片加标签 模糊效果 图片选择 模糊效果 基于MVP模式的Android多媒体选择器支持多/单图片选择和预览，单图裁剪功能 知乎的图片选择器 架构 终极组件化框架项目方案 android 官方mvp框架优化：lifecycle-mvp，像前端那样组合式写页面 带你高效学习MVP+RxJava+Retrofit Android 组件化 —— 路由设计最佳实践 使用简单但功能强大的安卓组件化框架 多个维度对比一些有代表性的开源android组件化开发方案 一个基于AOP设计的Fragment管理框架 阿里的动态组件化 基于DataBinding框架，MVVM设计模式的一套快速开发库，整合Okhttp+RxJava+Retrofit+Glide等主流库 Androdid组件化实战 互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构 MVP架构 Retrofit+RxJava请求接口数据 Dagger、ButterKnife简化代码 持续更新Android架构文章大全 WMRouter是一款Android路由框架，基于组件化的设计思路，有功能灵活、使用简单的特点 模板工程 极简 Android 组件化方案。仅包含 3 个注解加 1 个 API，超低学习成本，支持渐进式组件化。 组件化demo 安卓框架源码 阿里巴巴开源路由框架 Android项目组件化 Android项目组件化示例代码 Router activities and methods with url for android 路由 仿京东app 采用组件化架构 首页采用屏幕适配的较好方案 基于MVP开发的Android应用程序的通用架构集成了许多开源项目 Android MVP+Retrofit+RxJava 实例 Mars 是微信官方的跨平台跨业务的终端基础组件 轻量级的Android MVP快速开发框架 安居客模块化架构 Android MVP Architecture Study MVP开发框架 优雅的路由框架 Router Android 应用开发框架（模块开发非常棒） Android 应用开发框架 EasyMVP 项目架构采用MVP模式，使用 Retorfit2.0+RxJava1.0+OKhttp+Fresco+Rtmp直播，高仿斗鱼TV项目，仅供代码参考学习！ 材料设计风格的开源照片笔记（MVP + Dagger2 + RxJava + AspectJ + Dex处理） HiBeaver是一个用于进行Android字节码插桩的Gradle插件，可以用于实现Android轻量级AOP设计 简单路由框架 a MVP library for Android favoring a stateful Presenter RxJava+Retrofit封装，基于RxJava2和Retrofit2重构，便捷使用 The MVVM Architecture in Android（MVVM+Jetpack的开发实践） mvvm响应式开发框架 谷歌mvvm例子Android Architecture Components samples 滴滴跨端解决方案Chameleon终于发布 跨平台方案 一套完整有效的android组件化方案 小程序 基于规范的小程序 UI 组件库，自定义标签组件 微信小应用资源汇总整理 一套高质量的微信小程序 UI 组件库 基于鸿洋大神的玩android开放API完成的《玩android》微信小程序版本 基于 Vue.js 的小程序开发框架 微信小程序开发资源汇总 小程序组件化开发框架 微信小程序图表charts组件 WeUI 是一套同微信原生视觉体验一致的基础样式库 小程序 微信小程序(微信应用号)微信小程序官方demo,官方文档,开发工具，高仿手机QQ应用程序,持续更新中… 小程序可滑动得tab-view 硬件 这是一个可拓展的Android指纹识别API兼容库，目前集成了 安卓标准API 以及 三星 和 魅族 的指纹SDK。 指纹识别 指纹识别 一个可拓展的Android指纹识别API兼容库，目前集成了 安卓原生API 以及 三星 和 魅族 的指纹SDK。 Android BLE 蓝牙开发框架 Android BLE 蓝牙快速开发框架，使用回调方式处理 蓝牙操作库 蓝牙开发 指纹识别 人脸识别 android BLE蓝牙框架，包括扫描、连接、设置通知、发送数据、读取和接收数据以及各种直观的回调，近乎一行代码植入项目，可扩展配置蓝牙相关操作。 完整项目 一款新闻客户端, MVP + RxJava + Retrofit + Dagger2 Android开源项目-微Yue电子书阅读（MD设计） 一款纯粹的ACG聚合类App项目 一款采用MVP模式的设计的仿造腾讯漫画的APP 新浪微博第三方Android客户端 一款多视图记账APP 在线商城 仿有宠商城APP 一款第三方今日头条客户端, MVP + RxJava + Retrofit 咕咚翻译 MVP + RxJava + Retrofit 一个仿京东商城的个人练手项目 Android免费开源漫画阅读器 吐槽第三方Android客户端 项目例子 萤火小程序商城 Espresso是一种采用材料设计风格设计的快递跟踪应用程序，建立在具有RxJava2，Retrofit2，Realm数据库和ZXing的MVP（Model-View-Presenter）架构上。 高仿铜板街 一款基于Google Material Design设计开发的Android客户端 新浪微博客户端 高仿Bilibili客户端 创业的完整项目 开源小说阅读器 GSD_WeiXin（高仿微信） 仿知乎日报 仿ireader阅读器 一个天气app 项目源码开源的 Material Design 豆瓣客户端 基于融云开发的 Android 版即时通讯（IM）可以发红包 项目源码开源商城 Android平台开源天气App，采用MVP+RxJava+Retrofit2+OKHttp3+Dagger2+RetroLambda等开源库来实现。架构 订餐app 一款基于网易云音乐UI，使用Gank.Io及豆瓣api开发的符合Google Material Design的Android客户端 本项目高仿微信6.3.31 项目实战 A news-reading App (MVP+Dagger2+RxJava+Retrofit2+Material Design) diycode 项目客户端 高仿全民直播（全民TV），项目采用 MVP + RXJava + Retrofit + OKHttp + Material Design + Dagger2 + Base + Glide + GreenDao构建。视频 java项目 基于JAVA的模块化开发框架，它提供在运行时动态加载模块 ”乡吧“社交项目后台代码（Spring+Springmvc+mybatis） 基于SpringBoot2.0的权限管理系统 是用JAVA语言,基于t-io开发的轻量、高性能、单机支持几十万至百万在线用户IM 一个基于SpringBoot 2的管理后台系统 后台管理界面 Tiny, easily embeddable HTTP server in Java. 基于Spring+SpringMVC+Mybatis分布式敏捷开发系统架构","link":"/2019/02/27/technology/Android资料/"}],"tags":[{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"感悟","slug":"感悟","link":"/tags/感悟/"},{"name":"读书","slug":"读书","link":"/tags/读书/"},{"name":"进阶","slug":"进阶","link":"/tags/进阶/"},{"name":"资料","slug":"资料","link":"/tags/资料/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"人生","slug":"人生","link":"/categories/人生/"},{"name":"UI","slug":"Android/UI","link":"/categories/Android/UI/"},{"name":"感悟","slug":"人生/感悟","link":"/categories/人生/感悟/"},{"name":"读书","slug":"人生/读书","link":"/categories/人生/读书/"},{"name":"源码","slug":"Android/源码","link":"/categories/Android/源码/"},{"name":"资料","slug":"Android/资料","link":"/categories/Android/资料/"}]}