{"pages":[{"title":"","text":"һ����˼�����ũ","link":"/about/index.html"}],"posts":[{"title":"Android中使用Protocol Buffer","text":"Android中使用Protocol Buffer Protocol Buffer 是啥谷歌官方定义：Protocol Buffer 是一种轻便高效的结构化存储格式，使用于结构化数据序列化，适合做数据存储或者RPC数据交换格式。与语言无关，与平台无关，可扩展的序列化结构数据格式 比 json xml 更加高效 优点： 序列化之后的体积比json和xml都小 支持快平台，多语言 消息格式升级和兼容性都不错 序列化和反序列化速度很快 使用Protocol Buffer 1. 搭建Protocol Buffer环境 下载 https://github.com/protocolbuffers/protobuf/releases Mac下安装Homebrew123456789101112131415//安装依赖brew install autoconf automack libtool curl//运行字画生成脚本cd xxx/protobuffer-3.xx./autogen.sh//运行配置脚本./configure//编译为编译的依赖包make//检查依赖包的完整性make check//安装 protocol buffermake install//检查是否安装完成protoc --version 在AndroidStudio中使用插件的方式安装 Google提供了插件的方式，配置build.gradle https://github.com/google/protobuf-gradle-plugin 在工程的build.gradle中12345678buildscript { repositories { mavenCentral() } dependencies { classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.10' }} 在app的build.gradle中(每个版本的配置都不一样，这里是3.8.0)12345678910111213141516171819202122apply plugin: &apos;com.google.protobuf&apos;dependencies { // You need to depend on the lite runtime library, not protobuf-java //lite是轻量版 compile &apos;com.google.protobuf:protobuf-javalite:3.8.0&apos;}protobuf { protoc { artifact = &apos;com.google.protobuf:protoc:3.8.0&apos; } generateProtoTasks { all().each { task -&gt; task.builtins { java { option &quot;lite&quot; } } } }} 2. 定义.Proto文件（Android中在main文件夹下面创建proto文件夹在创建.proto文件） ，编译.Proto文件 构建消息 消息至少由一个字段组合而成 字段 = 字段修饰符 + 字段类型 + 字段名 + 标识号 字段修饰符：设置该字段解析时的规则 字段理性：基本类型 枚举类型 消息对象 字段名：字段名称 表示号：二进制格式唯一标识每个字段 字段默认值 Proto2支持声明默认值，Proto3使用以下规则 对于string类型，默认值为空字符串 对于byte类型，默认值为一个空byte数组 对于bool类型，默认为false 对于数值类型，默认值为0 对于枚举类型，默认值为第一项，即值为0的那个枚举值 对于引用其他message类型，默认值和对应的语言相关 标识号TAG 对应同一个message中的字段，每个字段的Tag是必须唯一的数字 Tag主要用于说明字段在二进制文件中的对应关系，一旦指定字段为对应的Tag，不应该在后序进行变更 对于Tag的分配。1~15只用一个byte进行编码（因此应该留给那些常用的字段），16~2047用两个byte进行编码，最大支持到536870911，但是中间有一段（19000~19999）是protobuf内部使用的 可以通过reserved关键字来预留Tag和字段名，还有一种场景是如果某个字段已经被废弃，不希望后序被使用，也可以使用reserved关键字声明 .proto文件 例子123456789101112131415161718192021222324252627//指定是 不写默认proto23的语法 不写默认proto2syntax = &quot;proto3&quot;;package tutorial;//对应环境下的处理方式 这里是java中option java_package = &quot;com.sample.model&quot;;option java_outer_classname= &quot;AddressProto&quot;;message Person{ string name = 1; int32 id = 2; string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4;}message Address {//使用repeated关键字修饰 表示该字段可以重复多次赋值，包括0次，不指定表示0次或者1次，重复的值的顺序会被保留，相当于动态化的数组(list)[packed=true]开启高效编码 repeated Person person = 1;} 编译消息 （命令行方式）12345678在终端输入下面命令protoc -I=#SRC_DIR -xxx_out=$DST_DIR $SRC_DIR/xxx.proto//比如：protoc -I=/User/doc/Android/prorobuffer/app/src/proto -- java_out=/User/doc/Users/doc/Android/protobuffer/app/src/main/proto/address.proto//在/User/doc下面生成对应的java文件 SRC_DIR 编译.proto的文件目录 –xxx_out 设置生成的代码类型 java: –java_out c++: -cpp_out DST_DIR 代码生成目录 xxx.proto 的路径 在AndroidStudio中，配置好之后直接build即可 生成文件在 build/generated/source/proto中 3. Android中使用Protocol Buffer 在项目中使用序列化和反序列化1234567891011121314151617181920212223242526//创建对象AddressProte.Person.Builder builder = AddressProto.Person.newBuilder();AddressProto.Person person = builder.setEmain(\"xxx\").build();//序列化byte[] bytes = person.toByteArray();//反序列化try{ AddressProto.Person person1 = AddressProto.Person.parseFron(bytes);}catch(InvalidPriticilBufferException e){ e.prientStackTrace()}//序列化ByteArrayOutputStream output = new ByteArrayOutputStream();try(){ person.witeTo(output); byte[] byte1 = output.toByteArray();}catch(IOException e){ e.prientStackTrace()}//反序列化try(){ AddressProto.Person person1 = AddressProto.Person.parseFrom(new ByteArrayInputStream(byte));}catch(IOException e){ e.prientStackTrace()} Protocol Buffer 原理 编码机制 Base 128 Varints 消息结构 key-value 键值对组成 Varints是一种可变字节序列化整形的方法 每个Byte的最高为(msb)是标志位，如果该位是1，表示该Byte后面还有其他的Byte，如果该位为0，表示Byte是最后一个Byte 每个Byte的第7位是用来村存数值的位 Varints方法用Little-Endian（小端）字节序 一个多位整数，按照其存储地址的最高或者最低字节进行排序，如果最低有效位在最高有效位的前面，则成为小端序，反之成为大端序 消息结构 编码类型 Type Mesning Used For 0 Varints int32 ,int64,uint32,uint64,sint32,sint64,bool,enum 1 64-bit fiexd64 ,sfixed64 ,double 2 Length-delimited string,bytes,embedded message,packed,repeated fields 3 Start group groups(deprecated) 4 End group groups(deprecated) 5 32-bit fixed32,sfixed32,float 消息结构 key key 的具体值为（field_number&lt;&lt;3|wire_type） key的范围 wire_type只有6种类型，用3bit表示，在一个Byte里，去掉mbs,以3bit的wire_type,只剩下4bit来表示field_number，因此在一个Byte里，field_number只能表达0-15，如果超过15，则需要两个或者多个Byte来表示。常用字段放在前面 Varints优缺点 Varints适用于表达比较小的证书，当数字很大时，采用定长编码类型（64bit,32bit） Varints不擅长表达负数，负数采用补码表示，会占用更多的字节，因此如果确定会出现负数，可以采用sint32或者sint64，他会采用ZigZig编码将负数映射为整数，之后再使用Varints编码 Length-delimited：编码格式则会将数据的length也编码进最终数据中，使用Length-delimited编码格式的数据类型包括string bytes和自定义消息 repeated/packed：repeated类型是把每个字段依次进行序列化，key相同，value不同，但是如果repeated的字段比较多，每次都带上相同的key则会浪费空间，因此 protobuf提供了packed选项，当repeated字段设置了packed选项，则会使用Length-delimited格式来编码字段值 Protocol Buffer使用注意事项 尽量不要修改tag 字段数量不要超过16个，否则会采用2个字节进行编码 如果确定使用负数，采用sint32/sint64","link":"/2019/10/20/architecture/Android中使用Protocol-Buffer/"},{"title":"Android Hook入门","text":"Android Hook入门 Hook 英文意思是钩子，可以把一段执行着的代码钩下来，然后加入我们自己的逻辑，最后在放回去。比如我们可以Hook住一段系统代码，在执行系统代码之前加入我们自己的逻辑。 Hook技术主要用到java反射和java动态代理两个知识点，下面来个简单的例子，我们来Hook一个按钮的点击事件 1234567Button button = findViewById(R.id.btn_click); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(getApplicationContext(),((Button) v).getText(),Toast.LENGTH_SHORT).show(); } }); 点击按钮的时候，我们如何能在不改变上面代码的前提下，在Toast弹出之前执行一些别的逻辑呢？比如现在Toast弹出的是按钮上的字，我们动态的把子给它改了 思路就是我们通过反射拿到系统中的OnClickListener的对象，通过动态代理，创建一个该对象的代理对象，这个代理对象中就可以写一些别的逻辑啦，最后把这个代理对象通过反射设置回系统中来个偷梁换柱就可以啦。 OK下面开始按照步骤来 第一步 反射拿到设置的OnClickListener对象，上面的代码中，我们进入setOnClickListener方法可以看到123456public void setOnClickListener(@Nullable OnClickListener l) { if (!isClickable()) { setClickable(true); } getListenerInfo().mOnClickListener = l; } 这里把我们传进来的回调对象设置给了getListenerInfo().mOnClickListener。1234567ListenerInfo getListenerInfo() { if (mListenerInfo != null) { return mListenerInfo; } mListenerInfo = new ListenerInfo(); return mListenerInfo; } getListenerInfo()方法返回一个ListenerInfo对象，它内部就保存了我们传过来的mOnClickListener回调对象。我们功过反射执行getListenerInfo方法就能拿到ListenerInfo对象了如下123456Class&lt;?&gt; viewClass = Class.forName(\"android.view.View\");//需要拿到setOnClickListener方法set过去的对象Method getListenerInfoMethod = viewClass.getDeclaredMethod(\"getListenerInfo\");getListenerInfoMethod.setAccessible(true);//本质是ListenerInfo对象Object listenerInfo = getListenerInfoMethod.invoke(view); 拿到了ListenerInfo对象，在通过它拿到它的成员变量mOnClickListener123Class&lt;?&gt; listenerInfoClass = Class.forName(\"android.view.View$ListenerInfo\");Field onClickListenerField = listenerInfoClass.getField(\"mOnClickListener\");final Object onClickListener = onClickListenerField.get(listenerInfo); 第二步 使用动态代理定义一个代理的onClickListener，在回调函数中添加一些别的逻辑12345678910Object proxyClickListener = Proxy.newProxyInstance(MainActivity.class.getClassLoader(), //需要将监听的方法 new Class[]{View.OnClickListener.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Button button = new Button(MainActivity.this); button.setText(\"我就点你\"); return method.invoke(onClickListener, button); } }); 在InvocationHandler方法中就可以添加别的逻辑了，这里添加了Toast用来测试，最后返回一个代理的OnClickListener对象。 第三步 把代理的OnClickListener对象设置回系统中,在第一步中已经拿到了mOnClickListener对象，最后把它给改了就好了。 1onClickListenerField.set(listenerInfo,proxyClickListener); OK Hook完成，效果 完整代码：12345678910111213141516171819202122232425262728293031/** * hook * @param view 需要hook的view */ private void hook(View view) { try { Class&lt;?&gt; viewClass = Class.forName(\"android.view.View\"); //需要拿到setOnClickListener方法set过去的对象 Method getListenerInfoMethod = viewClass.getDeclaredMethod(\"getListenerInfo\"); getListenerInfoMethod.setAccessible(true); Object listenerInfo = getListenerInfoMethod.invoke(view); Class&lt;?&gt; listenerInfoClass = Class.forName(\"android.view.View$ListenerInfo\"); Field onClickListenerField = listenerInfoClass.getField(\"mOnClickListener\"); final Object onClickListener = onClickListenerField.get(listenerInfo); Object proxyClickListener = Proxy.newProxyInstance(MainActivity.class.getClassLoader(), //需要将监听的方法 new Class[]{View.OnClickListener.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Button button = new Button(MainActivity.this); button.setText(\"我就点你\"); return method.invoke(onClickListener, button); } }); onClickListenerField.set(listenerInfo,proxyClickListener); } catch (Exception e) { e.printStackTrace(); } }","link":"/2019/08/16/architecture/Android-Hook入门/"},{"title":"外观模式","text":"外观模式：隐藏了系统的复杂性，为子系统中的一组接口提供了一个统一的访问接口。高内聚低耦合。 例子：比如一个网络框架一般都有缓存策略，首先从内存中查找，找不到在去硬盘中查找，还找不到在去网络上下载。 下面开始先定义几个接口123456789public interface MemoryCache { Bitmap findFromMemory(String url);}public interface DiskCache { Bitmap findFromDisk(String url);}public interface NetworkCache { InputStream findFromNetwork(String url);} 定义实现类123456789101112131415161718192021public class MemoryCacheImpl implements MemoryCache { @Override public Bitmap findFromMemory(String url) { System.out.println(\"从内存中查找\"); return null; }}public class DiskCacheImpl implements DiskCache { @Override public Bitmap findFromDisk(String url) { System.out.println(\"从硬盘查找\"); return null; }}public class NetworkCacheImpl implements NetworkCache { @Override public InputStream findFromNetwork(String url) { System.out.println(\"从网络获取\"); return null; }} 一般情况下回这么调用12345678MemoryCache memoryCache = new MemoryCacheImpl();memoryCache.findFromMemory(\"http...\");DiskCache diskCache = new DiskCacheImpl();diskCache.findFromDisk(\"http...\");NetworkCache networkCache = new NetworkCacheImpl();networkCache.findFromNetwork(\"http...\"); 如果使用外观模式，把这几个类封装到一个类中，使用起来就方便很多了如下1234567891011121314151617181920public class Facade { private String url; private MemoryCache mMemoryCache; private DiskCache mDiskCache; private NetworkCache mNetworkCache; public Facade(String url) { this.url = url; mMemoryCache = new MemoryCacheImpl(); mDiskCache = new DiskCacheImpl(); mNetworkCache = new NetworkCacheImpl(); } public void load(){ mNetworkCache.findFromNetwork(url); mDiskCache.findFromDisk(url); mNetworkCache.findFromNetwork(url); }} 使用12Facade facade = new Facade(\"http...\");facade.load(); 效果跟之前一想，看起来就清爽很多了。","link":"/2019/06/16/architecture/外观模式/"},{"title":"适配器模式","text":"适配器模式是将一个类的接口转换成开发者希望的另一个接口 下面参考Retrofit的源码学习适配器模式，Retrofit现在的Andorid开发者基本都用到过，里面用到了很多设计模式比如动态代理模式，适配器模式等。下面来看其中的一个适配器 在使用Retrofit的时候我们经常会看到下面的写法来添加一个addCallAdapterFactory，如果我们不添加，会有自己的一个CallAdapter返回一个Call对象，如果我们想和RxJava结合使用只需要添加一个RxJava的CallAdapter即可。 123456789101112131415161718192021Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"\") .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build();// Retrofit的create方法源码 public &lt;T&gt; T create(final Class&lt;T&gt; service) { ...... return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { ...... ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); } }); } 下面开始仿照Retrofit写一下适配器模式 首先有一个Call接口和CallAdapter适配器和一个Call的实现类OkHttpCall，CallAdapter中有一个抽象工厂类里面有个get()方法可以返回自己。123456789101112131415161718public interface Call&lt;T&gt; { void enqueue();}public interface CallAdapter&lt;R,T&gt; { T adapt(Call&lt;R&gt; call); abstract class Factory{ public abstract CallAdapter&lt;?,?&gt; get(); }}public class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; { @Override public void enqueue() { //请求网络 }} 实现一个默认的 CallAdapter12345678910111213141516171819public class ExecutorCallAdapterFactory extends CallAdapter.Factory { @Override public CallAdapter&lt;?, ?&gt; get() { return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() { @Override public Call&lt;?&gt; adapt(Call&lt;Object&gt; call) { System.out.println(\"default 方式\"); return new ExectorCallbackCall&lt;&gt;(); } }; } static final class ExectorCallbackCall&lt;T&gt; implements Call&lt;T&gt;{ @Override public void enqueue() { } }} 在实现一个RxJava的CallAdapter123456789101112131415161718public class RxJavaCallAdapterFactory extends CallAdapter.Factory { @Override public CallAdapter&lt;?, ?&gt; get() { return new CallAdapter&lt;Object, Observable&lt;?&gt;&gt;() { @Override public Observable&lt;?&gt; adapt(Call&lt;Object&gt; call) { System.out.println(\"rxjava 方式\"); ObservableOnSubscribe subscribe = new ObservableOnSubscribe() { @Override public void subscribe(ObservableEmitter emitter) throws Exception { } }; return Observable.create(subscribe); } }; }} Retrofit类中调用1234567891011121314151617181920212223242526272829303132public class Retrofit { private CallAdapter.Factory mFactory; private Retrofit(CallAdapter.Factory factory) { mFactory = factory; } public CallAdapter callAdapter(){ return mFactory.get(); } public &lt;T&gt; T create(){ ServiceMethod serviceMethod = new ServiceMethod.Builder&lt;&gt;(this).build(); OkHttpCall okHttpCall = new OkHttpCall(); return (T) serviceMethod.adapt(okHttpCall); } public static final class Builder{ CallAdapter.Factory mFactory; public Builder addCallAdapterFactory(CallAdapter.Factory factory){ mFactory = factory; return this; } public Retrofit build(){ if(mFactory == null){ return new Retrofit(new ExecutorCallAdapterFactory()); } return new Retrofit(mFactory); } }} 通过ServiceMethod把Retrofit和CallAdapter连起来1234567891011121314151617181920212223242526272829public class ServiceMethod&lt;R,T&gt; { private CallAdapter&lt;R,T&gt; mCallAdapter; private &lt;R, T&gt; ServiceMethod(Builder builder) { mCallAdapter = builder.mCallAdapter; } T adapt(Call&lt;R&gt; call){ return mCallAdapter.adapt(call); }; static final class Builder&lt;R,T&gt;{ Retrofit mRetrofit; CallAdapter&lt;R,T&gt; mCallAdapter; public Builder(Retrofit retrofit) { mRetrofit = retrofit; } public ServiceMethod build(){ mCallAdapter = createCallAdapter(); return new ServiceMethod(this); } private CallAdapter&lt;R, T&gt; createCallAdapter() { return mRetrofit.callAdapter(); } }} 最后调用：1234Retrofit retrofit = new Retrofit.Builder() .addCallAdapterFactory(new RxJavaCallAdapterFactory()) .build();retrofit.create(); 如果不加addCallAdapterFactory运行输出：”default 方式” 如果添加了运行输出：”rxjava 方式” 适配器模式完成。","link":"/2019/06/16/architecture/适配器模式/"},{"title":"人生需要坚持一次","text":"记一次学习数据结构和算法的经历和感悟。 数据结构与算法在软件编程中有着非常重要的作用，由于这部分的知识比较难，所以很多程序员都对这块不是很了解，计算机专业的还好点，大学时候接触过，转行过来的相对就更难了。 因为编程语言已经把很多算法思想和数据结构都封装的很好了，平时工作很少会用到，但是算法和数据结构依然很重要，因为它直指一个编程语言的本质。让我们写起程序来更加得心应手。是成为一个高级开发者的必经之路。 我就是一个转行过来的程序员，曾经的我想的比较少，每天写写业务代码，算法和数据结构对我来说是非常高端的东西，不是我所能接触的。可是随着科技的不断发展，程序员这一行竞争也越来越激烈，需要终身学习不断更新自己的技术，才能不被大多数人拉开距离，而想要成为最前面的一批人，数据结构和算法是不能绕开的。 于是某年某月某日，我买了一个数据结构和算法的课程开始学习这部分的东西。刚开始跟着学了四五节课就放一边了。应该就是人的惰性作祟，太费脑子太费时间了，一节课就十几分钟语音加一篇文章完事，但是想要理解里面的思想必须逐字逐句的读，并且边读边思考，可能需要半天一天甚至几天的时间才能搞明白。看看课程目录总共有五六十节课程啥时学完啊，正好那段时间也比较忙，工作完就不想学习也就落下了。 当回过神来的时候已经过去了两个月了，这时候课程已经更新了三十多节课，看到最后一节课的下面还有好多同学的评论，做课后作业，看到他们都坚持着学着，不仅感到一丝羞愧。 于是重新开始学习，并记笔记，不看课程更新了多少了，那只会增加自己的压力，只管今天有没有学习，有没有进步就好。并且记完笔记把笔记整理好发表一篇博客。这也算学完一篇后的成果，让自己看到自己的学习成果，也能激励着自己继续前进。 记得有一节课讲的动态规划，这节课对我来说真的是很难啊，整整想了一个星期才搞明白，不过搞明白的那一刻真的感觉很爽。 就这样，一天一天的过去了，直到学完了所有的知识点。回头看看感觉成就感满满的，以后再遇到需要坚持的事情，就想想曾经那么枯燥的算法和数据结构我都学完了还怕啥，干就是了。 以前经常看网络武侠小说，这些小说一般都有一个共同点，当长辈告诉晚辈他们这个世界的武者的等级的时候，只会告诉他们几个段位，在高的就不告诉了，如果晚辈问起来就说到时候你自然会知道了。 其实这也是为了让晚辈能一步一个脚印的去努力，武者一般都有几十上百个等级，如果他一开始就知道有那么多的等级需要升，并且看到那么多人已经在很好的等级中，可能一开始就被压垮了，不练了。相反如果只知道很少的等级，等到达这个等级之后再告诉他下一部分，这样一步一步的，最终才可能能走向巅峰。 学习是这样，人生也是这样，没有什么是一撮而就的，不要想着一下子达成多大的成就，只要找准目标大方向对，然后就是干去就行了，只要今天的自己比昨天有进步，剩下的就交给时间吧。相信坚持的力量，相信时间的力量。 人生需要一次坚持，一次学习，一次旅行或者一次创业等等，很多事情不去尝试永远不知道其实你能够做到，等你做到了一件事情，之后你会对很多事情都有信心去开始并且完成。 生命本来也是一次漫长的坚持，中间有很多小的坚持，N年之后蓦然回首，我们会发现人生的路上雕刻了很多的美好。","link":"/2019/04/14/life/人生需要坚持一次/"},{"title":"夯实自己的金字塔","text":"不知道大家有没有这种情况，有时候今天的工作很多，自己沉浸在工作之中，忽然间一看时间，已经快下班了，心里面感觉慢慢的充实 有的时候工作少很，刷刷朋友圈，浏览一下新闻，逛一下论坛，一看时间怎么过的这么慢啊，啥时候下班啊，感到非常的无聊，然后继续刷网页逛论坛知道下班结束，心里面感觉到慢慢的空虚。 不只是工作中，平时的放假中也经常会体现，有事情去做无论是学习还是娱乐还是生活琐事，会感觉时间过的很快，但是如果没事情做呢，床上躺尸一天还会感觉非常累。 很多时候我们都是这样重复着每一天，有时候充实，有时候空虚，也许会认为这就是生活的多姿，就没有去在意，但是正常情况下充实是我们想要的，空虚不是我们想要的，为什么不能让每天都是充实的呢？ 稍微想一下，就会发现，这跟我们是否有一个行动的目标有关系，当有目标的时候，我们自然就向着目标前进就行了，反之就像一个无头苍蝇到处乱飞哪也到不了。 所以想要充实自己首先要有一个目标，从大的目标开始，然后分解成一个一个的小目标，比如大目标，两年之内学好英语，小目标就是今天背几个单词说几句口语。 然后按照自己的小目标一天一天的去完成，一个人的技能是生活的支柱，技能的金字塔需要我们一块砖一块砖的去砌，每天一点一点的往上堆砌，总有一天会变成一个高大的金字塔，如果偷懒，每天东逛西爽，技能的金字塔永远也起不来，生活也就失去了支柱。 当我们娱乐的时候身体会感到很满足比如游戏刷视频，而大部分人也都倾向于去享受这种满足感，对于比较辛苦的事情没有耐心比如学习和工作，没有那种延时满足的觉悟，如果你还没有达到财务自由，这些满足感都是暂时的，大部分时间还是去面对生活中的柴米油盐。 试想一下，如果你能在别人娱乐的时候去自己的金字塔添几块砖，起初可能很不起眼，但请相信时间的力量，坚持下去，一段时间之后，你就能明显的看出自己的金字塔比别人高了一层。 自己的金字塔比别人高了一层。自然就有了一丝优越感，或者满足感，为了保证这种满足不会消失，自然更加勤快的去添砖，然后的行成一个良性循环，金字塔也越来越高，慢慢的就变成了别人眼中的成功的人。 永远不要让自己失去目标，永远要坚持建造自己的金字塔，金字塔成了，在这个比较残酷的世界上，才有能力让自己和自己的亲人活的更好，才能活的更加有底气。","link":"/2019/03/04/life/夯实自己的金字塔/"},{"title":"什么是拖延，拖延的根源","text":"拖延心里学第一章：笔记和思考 拖延是大部分人都会遇到的问题，很多人都遭受过或者正在遭受着拖延的折磨，一提到拖延可能很多曾经的事情都会涌现到脑海，比如校园时代中假期快结束的时候急急忙忙的赶作业，比如至今一个等着你去完成的项目，比如年初定下的看书计划，健身计划等等。 有数据显示，70%的学生存在拖延问题，50%的学生拖延已成为他们的习惯，在一般的人群中，25%的成人有慢性拖延问题，而95%以上的拖延者都希望能减轻他们的拖延的习惯，因为拖延总是会让他们无法把事情做好，从而会让他们为此感到痛苦。 研究还显示年纪越大的人拖延越小，这就能让我们想到很多了，比如可能感觉自己的时间不多了，不想浪费时间，亦或者他们已经退出了竞争的舞台，去做自己真正喜欢的事情，也可能他们终于看清了这个世界，活出了真正的自己。我管如何年轻时候的大把光阴可能是浪费了的。 我们经常不知道怎么辨识自己是不是真正的拖延，因为有时候我们会有甚多事情要做，真的没法把全部是事情做完，有的事情就得往后拖，怎么知道自己是否是在拖延呢？有一个很好的办法就是看它是不是让你感到烦恼。 有些人就是喜欢忙忙碌碌的，把自己的任务安排的满满的，一件一件的去完成，有些人喜欢过的轻松一点，一件事情往往花很长时间去完成，并不急于求成，还有一些人可以的去拖延，只是为了利用这些时间好好思考找到当前最重要的一件事情去做。这些有目标的人或者接受自己能力有限的人一般都不会为了拖延的事情而烦恼。 而另外一些人因为拖延让他们无法完成他们认为自己有能力完成的事情，这让他们必须承受因为无法完成而带来的恼怒后悔和强烈的自责和绝望。现实生活中我们经常会听到这样的话：如果当初我要怎么怎么样就好了。殊不知现在的我们完全可以决定以后的我们不会再说出那句话。 拖延者有一个奇怪的现象，比如每年年初我们都为子定一个目标，这次一定要早点开始早点实现，过了两个月忽然想到自己怎么还没开始，然后想不行我得马上开始了，其实还没开始做，不知不觉半年过去了，这时候其实已经不是什么时候开始了，而是很多负面的情绪会冒出来了，比如我要是早点开始就好了，如果我年初就做现在已经做了很多了吧，在这种消极的情绪下很难愉快的去做别的事情。最后的结果可能是背水一战或者直接放弃，无论选择了那种都会如释重负，然后发个誓以后不再会拖延了，然而第二年仍然会重复这样。 为什么有些人会产生拖延的不良习惯，很大的原因就是将要做的事情是他们能力范围但是有点难，并不能很快的完成，他们害怕，害怕去做了就会陷入麻烦或者害怕不被接受，从而导致他们不仅多开了这个世界，甚至躲开了自己，虽然有时候会承受拖延带来的自责和对自己的反感，但是和去做事情带来的麻烦来说，他们宁愿选择了前者，拖延成了保护他们的盾牌。","link":"/2019/07/07/life/什么是拖延，拖延的根源/"},{"title":"意识到不足才有机会改","text":"焦虑有时候是好的，如果连焦虑都感受不到，那要么家里有矿，要么就是每天迷迷糊糊的过日子，过到哪算哪；感受到焦虑的人，有的去努力夯实自己，有的每天在娱乐中焦虑的煎熬 最近比较热的就是滴滴裁员啊，美团裁员啊，宜家裁员啊……，各大媒体争相报道，用各种言语表达寒冬的到来，表达中年危机的可怕，弄的我们也是各种焦虑，各种培训班也开始推出各种应对寒冬的课程，具体管不管事就不知道了。 这些事情都是事实，产生焦虑也是应该的，关键的是感受到焦虑的我们该怎么去做。 经常有人抱怨生活很难，日子真的很难过，然后你发现，他一边抱怨着一边躺在床上玩手机。有些人总闲自己很胖，你告诉他每天做做瑜伽，晚上别吃太多，然后发现他每天仍然是瘫在床上玩手机吃东西。 我们大多数人每天都在重复昨天的日子，即使有时候我们知道自己需要改变，需要去努力，知道什么应该做，什么不应该做，结果仍然是不愿动，甚至都没有那么一点点的改变。 现在的八零九零后，很多都是上有老，下有小，中间还有房贷，如果失业了，真的是很大的打击，还可能会意志消沉，妄自菲薄，那就真是雪上加霜了，工作总会找到的，在努力奋斗的同时，一定要相信自己。 所以一定要让焦虑变成自己努力的动力，而不是压垮自己的稻草。 有了动力之后，找到自己的生活目标，为什么不是人生目标而是生活目标呢，因为人生太长了，大多数人经不起等待，我们需要定的是一个一个的小目标，一个月，一季度，半年，一年就好。然后就是一个一个的去完成，完成的同时也能激励自己继续前进 比如做技术总有一天会遇到瓶颈的，因为它需要终身学习。也许是因为生活的原因你没时间学了，也许是因为做的时间长了厌倦了，也许你一直保持着热情，每天都在努力的深挖你的技能，但是因为年龄的原因被企业嫌弃了，无论什么原因，结果都是技术的路线干不动了。 所以，技术做到一定程度之后，业余时间多关注一下别的领域，比如产品啊，理财啊，写作啊，商业啊，就像在这个到处裁员的寒冬，股市却是开门红，从年初到现在，涨了不少，很多人都赚了。所以给自己定个学习计划，在不断精进自己技术的同时，也开始学习一个别的领域的知识，扩展自己的第二技能。 最后就是坚持，学习这东西见效比较慢，冰冻三尺非一日之寒，量变引起质变，不要被游戏，抖音，直播这类的的APP占据太多的时间。对于学习来说，因为大多数人的智力是差不多的，最终拼的就是坚持，如果你不能长期面对痛苦，不能长期等待，那么这个世界上大多数的美好都与你无缘。","link":"/2019/02/27/life/意识到不足才有机会改/"},{"title":"娱乐和节制","text":"很多人都推荐《娱乐至死》这本书，听着名字也挺唬人的，也想看看怎么在娱乐中死去，于是找来这书读了。 虽然本书字数不多，不过看本书真的需要一点耐心，特别还是翻译的外国的书，每个人的名字都很长，各种引用，而且本书在1985年就写完了，比我还大。 文章主要讲了媒介的含义，从印刷术到电报在到电视，随着信息传递的多样化和成本的越来越低，人们各种娱乐活动越来越多，人类进入了娱乐时代，每天被一些简短的广告，各种娱乐节目包围着，这些广告和娱乐节目基本都没啥实质性的意义，却占据了人们的很多时间，各种文字图像和音乐不断刺激着人们，给人娱乐却没让人思考。作者很担心人们沉浸在娱乐中而导致退化。 很遗憾这本书1985年就写完了，如果这时候写完，作者肯定能写更多的东西 ，如今的社会随着网络的普及，电脑的普及，只能手机是普及，人类的娱乐方式比以前多了无数倍，而沉浸在娱乐中的人们比以前也更是多了很多，跟那时候相比，现在更是娱乐至死。 书中提到了躲猫猫的世界，我觉得很好，当我们沉浸在娱乐中的时候，在那个个世界里，一会这个一会那个突然进入我们的世界，然后又很快的消失，这是一个不连续也没有实际意义的世界，大多数时候我们只是一个看客，看着各种热点，各种广告，各种电视剧，各种小说，看完之后我们有能记得什么，大部分时候这些东西对我们都没大意义。 记得以前我特别爱看武侠小说，每当看到一本比较好的小说的时候，总是废寝忘食的看，真的很讽刺啊，学习没见过这么用功，沉浸在小说的剧情里无法自拔，当小说快要看完的时候，甚至感到点点的失落，因为马上要离开这个世界了，几天之后，可能又进入了另一个小说的世界。 一遍一遍的看着别人在别人的世界里打怪升级，成为一代强者，就像自己成功了一样，心里上也是有那么一丝丝的满足，可是那有怎么样呢，现实世界中的我们依然要面对自己的残酷。而那字数动辄几兆十几兆的小说只会浪费我们大量的时间，只有弱者才会去虚拟的世界里感受别人的成功。 我家老弟，平时学习成绩都不错，去年年底迷上了网络游戏吃鸡，天天玩，结果期末考试考得很差。抗拒不了诱惑就很难成功，现实中有很多上学的时候学习成绩很好，考了好大学，但是到了大学之后就不学习了各种娱乐，只求混个毕业证万事，大部分人都认为高考完就是人生的解放，终于可以肆无忌惮的娱乐了。而这些人真正毕业进入社会后混的却并不好。 人类天生就爱娱乐，有些人考上了好大学是自己想考上好大学想有出息，有些人是被老师家长逼着考上的，等到没人管之后，才真正的能看出一个人是否真的有前途。 很庆幸三十多年过去了，人类并没有娱乐至死，而且发展的更快更好，这是因为并不是所有的人都深陷享乐中无法自拔，世界上有很多极度自律的人，他们不断学习不断成长，最终成为大部分人眼中的成功人士。而本书的意义也是能让更多的普通人能意识到娱乐的真正含义，娱乐只是让我们轻松一下的工具，而我们却不能成为它的俘虏。 刷抖音两小时之后你会记得什么吗？只是在刷视频的那一瞬间咯咯笑了一下罢了，而学一个东西两个小时候之后呢，你又会了一个小技能，而它可能会在未来的某一次帮助你。请相信积累的力量，当二十个小时，两百个小时，两千个小时之后，刷抖音的你依然是啥也没记住，而学习的你肯定已经经历了蜕变。 总结一下，娱乐的东西一般都是很快的经过我们的脑子，娱乐不会让我们思考，可以说把各种好东西喂到我们嘴里。而学习呢，却需要我们无时无刻的都在思考，只有去思考，想明白了，那些东西才是我们自己的，然而人类天生懒惰拒绝思考，也就让娱乐比学习更受欢迎。可是世界很残酷啊，往小了将我们需要吃穿玩，需要买房，需要娶妻嫁人，需要赡养老人抚养儿女，往大了将人类需要不断的进步。这些都是那些虚拟的娱乐无法给我们的，想要过的更好，唯有控制住自己懒惰的欲望，不断学习增强自身。","link":"/2019/03/11/life/娱乐和节制/"},{"title":"高效的学习的几种方式","text":"高效的学习的几种方式 最近看了万维钢老师的《万万没想到》这本书感触很多。 学习可以说是生活中的一部分，无论是为了升值加薪还是为了扩充自己的知识面，还是无意中的好奇心，我们都会去学习。 不过很多时候，学过的东西没多久就忘记了，有人说在一个领域练习一万个小时就能成为这个领域的高手，可是你在某一行呆了很多年了依然菜的不行。 怎么才能让自己的知识技能不断进步呢，当然就是学习，不过并不是学了就真的掌握了，比如听老师讲课，听的时候都听懂了，可是轮到自己做的时候呢，大脑一片空白。怎么才能有效的学习呢？答案就是刻意练习。练习也是有技巧的，掌握技巧更能事半功倍。 不要呆在舒适区心里学家把人的知识技能分成三个区域，舒适区，学习区，恐慌区。舒适区就是我们已经掌握了的技能，恐慌区就是我们一时半会无法掌握的技能，学习区在这两者中间，通过和思考可以慢慢掌握。 这就可以解释在某一领域呆了很多年依然很菜的原因，因为一直呆在自己的舒适区，每天做的事情只是熟练自己已有的技能，却没有刻意的去练习自己不熟悉的部分。在舒适区做事情是生活，在学习区做事情是练习，持续不断进步的关键就是不断的在学习区做事情。 脱离舒适区，让每天的自己都比昨天的自己有进步，不过脱离舒适区需要强大的意志力，如果你自己意志力不足，也可以自己给自己找点压力，很多时候成功都是被逼出来的。 掌握套路刻意练习中最重要的就是基础练习，比如职业运动员的训练往往针对特定的技术动作而不是比赛本身，一个高水平的美式足球运动员只有1%的时间是队内比赛，其余时间都是在做各种基础的训练。在比如在程序员行业，一线互联网企业招人的时候算法是必考的部分。这些基本功是今后比赛赢得胜利或者解决复杂问题的重要筹码 而想要练好基本功的练好的唯一办法就是不断的重复！程序员都会觉得算法题非常难，以至于大部分在这里都是弱项，其实那只是懒得去思考，去练习罢了，一道算法题写上十遍八遍的自然会记到骨子里。 还有一点要有针对性，哪里不会练哪里，有针对性的不停的去实战。 获得反馈很多情况下，我们会高估自己，以为自己知道了，其实却不知道，就像我们看一个教学视频，老师讲的都明白，可真的让自己实战的时候却不知道从哪里下手。 其实把一个视频或者一本书看多变只是让我们对它熟悉而已，熟悉并不等于理解，想要真正的理解就去真正的实践测试，实践的结果就是反馈，能让我们对自己有一个清楚的认识 自己对自己的看法和别人对自己的看法，很有可能是不同的，就像当局者迷，旁观者清，很多时候我们需要一个旁观者来给我们指出错误。 篮球排球乒乓球，很多队员可能都比教练打的好，那为什么还需要教练呢，因为有一个懂行的在旁边观察者自己，在训练的时候以旁观者的身份不断的给自己提供反馈。 单独练习小时候，我们经常会发现一个现象，一个每次玩耍都少不了的小伙伴考试成绩却非常好，哈哈说不定人家回家都自己单独学了很久。 刻意的练习不是个好玩的事情，它需要练习着调动大量的精气神，刻意练习需要不断重复，重复也不是好玩的事情，如果你觉得自己是在享受练习，那就不是刻意练习。 如果你想学点知识，最好的办法就是找个该专业的教科书或者专业人士的著作，然后老老实实的找个没人的地方好好钻研，并且做笔记，必要的时候做练习题反馈。如果你坚持不了8分钟说明你不适合学习这个 小时候就听老师说过，如果你学完一本教科书，你的书还是崭新的，那么很大的可能你没有学好。 最可怕的是天赋比我们好的人还在不断努力的练习。 输出式学习如果自己观察自己身边的学习好的人，会发现，他们基本都要做笔记或者写博客的习惯。 学习一个知识，听一遍只是知道了，听两遍只是熟悉了，自己能说出这是个什么原理，并且能讲给别人听才是真正的学会了。 写一个博客或者开源一个项目到网上，别人可以通过你的博客学到东西，也可以发现你的问题给你提出来，这是一个双赢的事情。而且东西写出来，以后还可以方便复习。看着一篇篇自己写的东西，还会有自豪感，也能激励着自己继续努力。 最后学习方法很重要，坚持更重要，滴水石穿，量变引起质变，有了好的方法，再能坚持不懈，相信成功离你不远了。","link":"/2019/07/07/life/高效的学习的几种方式/"},{"title":"Android刘海屏适配","text":"刘海屏和水滴屏的手机目前市场上还是挺多的，所以如果有必要的话，我们开发者还是需要去适配一下。 那什么情况下我们需要去适配这个刘海屏呢？ 如果App使用了沉浸式的状态栏，或者透明状态栏，我们自己的布局延伸到了状态栏内部，这时候如果我们在刘海处有一个可交互的控件就会被遮挡 使用了全面屏的页面，比如APP的闪屏界面，图片查看大图的页面，这时候状态栏不可见，刘海会遮挡一部分地方。 如果没有上面两种情况，可以不去适配刘海屏。Android从9.0开始加入刘海屏适配的API，9.0之前的刘海屏手机想要适配就得去各个厂商的官网去找适配的代码了。 Anroid9.0官方适配的原则 如果不是全屏模式（有状态栏）则不受刘海屏的影响。因为刘海屏的高度一般就是状态栏的高度 对于全屏显示的界面，如果没有适配刘海屏，系统会有一个默认的下移处理来避开刘海屏，竖屏向下移动，横屏想右移动。 想要真正的全屏显示，需要通过Android9.0提供的API进行适配处理。 所以说，如果遇到》=9.0的Android刘海屏手机，如果没有适配刘海，我们设置的全屏的界面默认不是全屏的，会避开刘海区域。 那如果设置了全屏或者沉浸栏，如何让内容延伸进状态栏呢，需要调用几个新的API,下面的API只有targetSdkVersion 28以上才能找到，先判断是否有刘海 123456789101112131415161718/** * 判断是否有刘海 */@TargetApi(28)private fun hasDisplayCutout(window: Window): Boolean { val displayCutout: DisplayCutout? val rootView = window.decorView val insets = rootView.rootWindowInsets if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P &amp;&amp; insets != null) { displayCutout = insets.displayCutout if (displayCutout != null) { if (displayCutout.boundingRects != null &amp;&amp; displayCutout.boundingRects.size &gt; 0 &amp;&amp; displayCutout.safeInsetTop &gt; 0) { return true } } } return false} 然后允许内容延伸进刘海区域其实也就是状态栏1234567891011if(hasDisplayCutout(window)){ //2.让内容区域延伸进刘海 val params = window.attributes /** * * @see #LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT 全屏模式，内容下移，非全屏不受影响 * * @see #LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 允许内容去延伸进刘海区 * * @see #LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 不允许内容延伸进刘海区 */ params.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES window.attributes = params } OK 内容延伸到状态栏中了，如果我们界面顶部有一个可交互的控件，比如很多APP在顶部设置一个全局的搜索框，这就会被刘海遮盖住了。解决方法很简单 1.设计的时候避开这个区域 2.给该控件一个顶部的margin值或者给它的父控件一个padding值，这个值可以直接拿状态栏的高度1234567891011121314151617181920212223242526 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //1.设置全屏 requestWindowFeature(Window.FEATURE_NO_TITLE) val window = window window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN) setContentView(R.layout.activity_bang) root_view.setPadding(0,getStatusBarHeight(this),0,0) }/** * 获取状态栏高度 * * @param context * @return */ fun getStatusBarHeight(context: Context): Int { var statusBarHeight = 0 val resourceId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\") if (resourceId &gt; 0) { statusBarHeight = context.getResources().getDimensionPixelSize(resourceId) } return statusBarHeight } 3.在布局文件的根布局加一个属性android:fitsSystemWindows=”true”，就会自动往下移动 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout android:id=\"@+id/root_view\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@mipmap/loading\" android:fitsSystemWindows=\"true\" &gt; &lt;EditText android:layout_width=\"200dp\" android:layout_height=\"40dp\" android:layout_centerHorizontal=\"true\" android:text=\"请输入\" android:background=\"@drawable/selector_button\" /&gt;&lt;/RelativeLayout&gt; 对于国内的一些手机厂商的适配，8.0,9.0的手机都有，需要去其官网看看其文档，然后根据不同的机型调用不同厂商的API。 优先使用厂商的API，即使是9.0的手机，厂商没有对应API的时候在使用谷歌提供的9.0以上的适配方式 判断是那个厂商使用可以使用布兰柯基大佬的util 华为:https://devcenter.huawei.com/consumer/cn/devservice/doc/50114 小米:https://dev.mi.com/console/doc/detail?pId=1293 Oppo:https://open.oppomobile.com/service/message/detail?id=61876 Vivo:https://dev.vivo.com.cn/documentCenter/doc/103","link":"/2019/04/05/technology/Android刘海屏适配/"},{"title":"Canvas和属性动画实现好看的效果","text":"旋转，聚合，水波纹 最终效果如下图 实现步骤： 绘制6个小圆圈，小圆圈是围绕着一个大圆平均绘制的，我们可以计算大圆的总弧度，然后除以小圆的个数，就能得到每个小圆之间间隔的弧度。然后循环绘制12345678910111213private void drawSmallCircle(Canvas canvas) { canvas.drawColor(Color.WHITE); //一个完整的圆的弧度是2π，计算每个小圆之间的弧度 float angleEach = (float) (2*Math.PI/mCircleColors.length); //循环绘制6个小圆 for (int i = 0; i &lt; mCircleColors.length; i++) { float angle = i*angleEach+mCurrentAngle; float x = (float) (Math.cos(angle)*mRotateRadius+mCenterX); float y = (float) (Math.sin(angle)*mRotateRadius+mCenterY); mPaint.setColor(mCircleColors[i]); canvas.drawCircle(x,y,mCircleRadius,mPaint); } } 小圆的的原点的坐标可以看下图，根据我们中学数学中所讲，x=sin(角度)大圆的半径，y=cos(角度)大圆的半径。最后在加上大圆的原点坐标，就是上面代码上中的计算方法了。 让着些小圆转起来，那就需要通过属性动画了，通过属性动画，动态的改变弧度的大小，就能该表小球的原点坐标了，最后重绘即可。1234567891011121314151617181920212223private void initRotateAnimator() { //弧度从0到最大弧度 ValueAnimator rotateAnimator = ValueAnimator.ofFloat(0, (float) (Math.PI * 2)); rotateAnimator.setDuration(1000); rotateAnimator.setRepeatCount(2); rotateAnimator.setInterpolator(new LinearInterpolator()); rotateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mCurrentAngle = (float) animation.getAnimatedValue(); invalidate(); } }); //监听动画结束，然后开启另一个动画 rotateAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); initAggregationAnimator(); } }); rotateAnimator.start();} 3.让小球执行聚合扩展的动画，首先我们动态的改变大圆的半径值，然后重绘。这里需要设置一个特殊的插值器OvershootInterpolator，它的意思是向前甩一定值后再回到原来位置。123456789101112131415161718192021private void initAggregationAnimator() { ValueAnimator aggregationAnimator = ValueAnimator.ofFloat(mCircleRadius, mRotateRadius); aggregationAnimator.setDuration(500); aggregationAnimator.setInterpolator(new OvershootInterpolator(10f)); aggregationAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mRotateRadius = (float) animation.getAnimatedValue(); invalidate(); } }); //监听动画结束，然后开启另一个动画 aggregationAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); initRippleAnimator(); } }); aggregationAnimator.reverse();} 上面的两个动画中用到了两个插值器：LinearInterpolator和OvershootInterpolator。Android系统中默认给我们提供了很多插值器如下： 插值器 | 描述 :-: | :-: AccelerateDecelerateInterpolator | 开始和结束缓慢，中间加速 AccelerateInterpolator | 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator | 开始的时候向后甩一下，然后向前 AnticipateOvershootInterpolator | 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator | 动画结束的时候弹起 CycleInterpolator | 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator | 开始的时候快，结束的时候慢 LinearInterpolator | 以常量速率变化 OvershootInterpolator | 运动到终点后，冲过终点后再回弹 4.最后绘制一个水波纹的效果，可以通过绘制空心圆的做法实现，通过属性动画，动态改变圆的半径，圆的半径从0到屏幕对角线的一半。123456789101112131415private void initRippleAnimator() {//mDistance为屏幕对角线的一半 ValueAnimator rippleAnimator = ValueAnimator.ofFloat(mCircleRadius, mDistance); rippleAnimator.setDuration(1200); rippleAnimator.setInterpolator(new LinearInterpolator()); rippleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { isRipple = true; mHollowRadius = (float) animation.getAnimatedValue(); invalidate(); } }); rippleAnimator.start();} 最后是onDraw方法中,因为前两部需要绘制6个小圆，最后一步绘制一个空心圆不用绘制小圆，通过一个标志位isRipple来判断需要绘制哪个。标志位在第二个动画结束的时候置为true。1234567891011protected void onDraw(Canvas canvas) { super.onDraw(canvas); if(isRipple){ float strokeWidth = (mDistance - mHollowRadius); mHollowPaint.setStrokeWidth(strokeWidth); float radius = strokeWidth / 2 + mHollowRadius; canvas.drawCircle(mCenterX,mCenterY,radius,mHollowPaint); }else { drawSmallCircle(canvas); } } 到此动画完成。 源码位置请点这里","link":"/2019/03/29/technology/Canvas和属性动画实现好看的效果/"},{"title":"快速排序","text":"快速排序 快速排序效率高，空间复杂度底，在工作中一般是用的最多的排序算法，所以需要掌握。 在看快速排序之前，先看一下另一个比快排简单点的问题，就是荷兰国旗问题 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N) 解决思路： 准备准备三个指针less、more、cur less指针，从数组的第一个元素的前一个位置开始，第一个元素的位置为0，所以less从-1开始 more指针，从数组最后一个元素的后一个位置开始，最后一个元素的位置是数组长度减一位置，所以more的值就是数组的长度 cur指针，当前比较的元素的位置，从第一个元素开始比较，也就是从0开始 如果当前元素小于num，less的后一个位置的元素跟cur位置的元素交换。交换完成之后，当前位置cur加一，比较下一个元素 如果当前元素大于num，more的前一个元素跟cur位置的元素交换。交换完成之后，此时交换回来的元素我们不知道它大于num还是小于num，所以cur位置不变，继续比较 如果当前元素的值等于num，cur直接加一，比较下一个。 代码如下 12345678910111213141516171819202122232425262728293031public static int[] partition(int[] arr, int num) { if(arr == null || arr.length &lt; 2){ return arr; } //less从数组第一个元素的前一个元素开始 int less = -1; //more从数组的最后一个元素的后一个元素开始 int more = arr.length; //cur 当前比较的位置 int cur = 0; while (cur &lt; more) { if (arr[cur] &lt; num) { //less的后一个位置和cur位置元素交换 //交换之后，cur加一 swap(arr, ++less, cur++); } else if (arr[cur] &gt; num) { //cur和more位置的前一个交换 swap(arr, --more, cur); }else { cur++; } } //返回等于num数据的位置 return new int[] { less + 1, more - 1 }; } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 快速排序跟荷兰国旗算法的思想差不多，不同的是荷兰国旗算法是给了一个num值用来比较，快速排序中，我们自己从数组中随便找一个数来作为比较值。数组分成两部分之后，这两部分按照同样的方式递归在分自己，最后完成排序 解决思路 首先选一个参照点，一般选择数组的最后一个值当做参照点 之后的交换思路就跟荷兰国旗思路一样了 需要注意，如果需要排序的数据本来就是一个有序的数组，那么如果一直选择最后的点作为参考点，那么每次分区得到的两个区间是不相等的，每次都要进行n次分区操作，每次分区大约扫描n/2个元素，时间复杂度会退化为O(N²) 解决方式，每次不在取最后一个，从数组中随机取一个数，然后跟最后一个元素交换，在按照前的方式循环。改成随机事件，就从概率上降低了时间复杂度 代码如下 代码中直接使用left这个变量代替cur，可以省一个变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void quickSort(int[] arr) { if (arr == null || arr.length &lt; 2) { return; } quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr,int left,int right){ if(left&lt;right){ //在经典快排中，一般取最后一个位置的点作为参考点，但是加入数据本来就是有序的时候，快排的时间复杂度会退化到O(N²) //所以，可以在数组中随机找一个数来作为参考点，使用这种方法来降低时间复杂度 //在left到right的范围中随机取一个数，把它放到最后一个位置 swap(arr,left + (int)(Math.random()*(right-left+1)),right); //选一个参考点，把数组分区，比如选数组的最后一个点 //把比它小的放到它的左边，比它大的放到它右边，相等的不动 //返回的p数组中包含两个元素，这两个元素就是跟参考点相等的数的左边界和右边界 int []p = partition(arr,left,right); //递归分区 quickSort(arr,left,p[0]-1); quickSort(arr,p[1]+1,right); } } private static int[] partition(int[] arr, int left, int right) { //左边指针 最开始在数组最左边的前一个位置 也就是 -1 位置 int less = left-1; //右边指针，最开始在数组最右边的位置（所以最后位置的那个数不参与循环） int more = right; // left变量 作为当前指针的位置 while (left&lt;more){ //以数组最右边的数值为参考点 //如果当前指针的位置的数小于参考点的数 if(arr[left]&lt;arr[right]){ //左边指针的下一个位置的数和当前指针位置的数交换，然后当前位置加一 //比如第一次的时候其实是数组第一个元素和自己交换 swap(arr,++less,left++); } //如果当前指针的位置的数大于参考点的数 else if(arr[left]&gt;arr[right]){ //当前指针位置的元素和数组最后一个元素交换 swap(arr,left,--more); }else { //如果相等，当前位置的指针加一 left++; } } //因为数组最后位置的数是最为参考点来的，没有参与循环，最后需要把它交换到正确的位置 swap(arr,more,right); return new int[]{less+1,more}; } public static void swap(int[] arr,int left,int right){ int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; }","link":"/2019/10/20/technology/快速排序/"},{"title":"粒子效果的实现","text":"想要实现一个图片的粒子效果，非常简单 效果图： 思路： 遍历图片的宽高，通过Bitmap.getPixel(row,cloum)这个方法，返回值我们可以拿到当前像素点的颜色值，我们也能拿到当前的坐标点，然后封装成一个一个的小球对象，保存在集合里面。 在onDraw里面遍历集合根据这些小球的坐标点和颜色值绘制圆圈。如果我们取的像素足够密，绘制出来的原点可以组成这个图片。 动画效果，通过属性动画，在onAnimationUpdate方法中根据一定的算法不断更新小球对象的x，y坐标点。这个算法可以自己定，比如通过自有落体的公式，或者随机数等。 在onTouchEvent方法中监听ACTION_DOWN事件开启动画 如果直接取图片的所有像素，如果图片很大的话，会非常卡，如果不取全部的，那绘制出来效果没原图清晰，我们可以通过一个标志位，开始绘制原图，点击之后在绘制小圆球。 创建一个Ball对象，用来保存将要绘制的每个点的坐标和当坐标更新时的变化速度。1234567891011121314151617181920public class Ball { public int color; //x坐标 public float x; //y坐标 public float y; //半径 public float r; //水平速度 public float vX; //垂直速度 public float vY; //水平加速度 public float aX; //垂直加速度 public float aY;} 创建一个bitmap,遍历它的宽高，获取像素值，和坐标值，封装成一个一个的小球并保存起来。为了提高效率这里的遍历每次+2，可根据实际情况更改。12345678910111213141516171819mBitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.shader);for (int i = 0; i &lt; mBitmap.getWidth()/d; i+=2) { for (int j = 0; j &lt; mBitmap.getHeight()/d; j+=2) { Ball ball = new Ball(); ball.color = mBitmap.getPixel(i,j); ball.x = i*d+d/2; ball.y = j*d+d/2; ball.r = d/2; //速度(-20,20) ball.vX = (float) (Math.pow(-1, Math.ceil(Math.random() * 100)) * 20 * Math.random()); ball.vY = rangInt(-15, 35); //加速度 ball.aX = 0; ball.aY = 0.98f; mBalls.add(ball); } } 开始绘制，判断是绘制原图还是绘制小圆圈。123456789101112protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.translate(getWidth()/2-mBitmap.getWidth()/2,getHeight()/2-mBitmap.getHeight()/2); if(isShowBitmap){ canvas.drawBitmap(mBitmap,0,0,null); }else { for (Ball ball : mBalls) { mPaint.setColor(ball.color); canvas.drawCircle(ball.x,ball.y,ball.r,mPaint); } }} 使用属性动画，动态的更新每个小球的坐标值然后重新绘制。1234567891011121314151617181920splitAnimator = ValueAnimator.ofFloat(0,1); splitAnimator.setRepeatCount(-1); splitAnimator.setDuration(2000); splitAnimator.setInterpolator(new LinearInterpolator()); splitAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { updateBall(); invalidate(); } }); private void updateBall() { for (Ball ball : mBalls) { ball.x += ball.vX; ball.y += ball.vY; ball.vX += ball.aX; ball.vY += ball.aY; }} OK完成，源码地址点击这里","link":"/2019/03/29/technology/粒子效果的实现/"},{"title":"Andorid Hook进阶","text":"Android Hook入门 上一篇文章学习了Hook的简单用，这次来做个稍微麻烦一点的，我们知道新建一个Activity之后我们需要在manifest中注册，否则启动的时候就会崩溃，现在使用Hook的方法绕过检查来启动一个没有注册的Activity 如果我们不注册的话就会报下面的错误 123android.content.ActivityNotFoundException: Unable to find explicit activity class{com.chs.hookplugin/com.chs.hookplugin.LoginActivity};have you declared this activity in your AndroidManifest.xml? 然后找一下这个错误是在哪里报出来的，我们就在检查报错的前面Hook一下，给他传入一个正常的Activity，在检查之后在Hook一下，替换回我们要去的Activity就好了。 下面的源码是基于Android9.0的，每个版本的源码可能不一样 寻找第一个Hook点 从startActivity这个方法开始找123456789101112131415161718192021222324 @Overridepublic void startActivity(Intent intent) { this.startActivity(intent, null); } @Overridepublic void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { startActivityForResult(intent, -1); } } public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) { startActivityForResult(intent, requestCode, null); }public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { ... Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ... } 一路点击跟进，最后进入到了Instrumentation这个类中的execStartActivity方法。12345678910111213public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); ... } ActivityManager.getService()是拿到拿到ActivityManagerService服务在本地的代理对象，然后通过它操作ActivityManagerService执行startActivity方法，最后返回一个结果，最后执行checkStartActivityResult方法 1234567891011121314151617public static void checkStartActivityResult(int res, Object intent) { if (!ActivityManager.isStartResultFatalError(res)) { return; } switch (res) { case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( \"Unable to find explicit activity class \" + ((Intent)intent).getComponent().toShortString() + \"; have you declared this activity in your AndroidManifest.xml?\"); throw new ActivityNotFoundException( \"No Activity found to handle \" + intent); ... 在checkStartActivityResult方法中可以看到，当res返回是START_CLASS_NOT_FOUND的时候就会报出一开始的错误了。因为我们传过去的Activity，ActivityManagerService找不到。 所以我们就可以把检查方法之前的ActivityManager.getService().startActivity作为第一个Hook点，我们给它随便传一个注册过的Acivity，这样就可以欺骗ActivityManagerService了 12345678910111213141516171819202122232425262728 ActivityManager.getService() public static IActivityManager getService() { return IActivityManagerSingleton.get(); } private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } };public abstract class Singleton&lt;T&gt; { private T mInstance; protected abstract T create(); public final T get() { synchronized (this) { if (mInstance == null) { mInstance = create(); } return mInstance; } }} 可以看到Singleton是一个系统的单例类，getService()方法调用的时候，就会create方法，最终会调用IActivityManagerSingleton 中的create方法创建一个IActivityManager返回。 IActivityManager就是ActivityManagerService在本地的代理对象。用来进行进程间的Binder通信。 我们来Hook IActivityManager，替换成我们自己的。 先定义一个空的ProxyActivity，并在AnroidManifest中注册1234567public class ProxyActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Toast.makeText(this, \"我是代理Activity\", Toast.LENGTH_SHORT).show(); }} 然后在Application中Hook住AMS12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PluginApplication extends Application { @Override public void onCreate() { super.onCreate(); try { hookAms(); } catch (Exception e) { e.printStackTrace(); } } private void hookAms() throws Exception{ Class&lt;?&gt; activityManagerClass = Class.forName(\"android.app.ActivityManager\"); Field iActivityManagerSingletonField = activityManagerClass.getDeclaredField(\"IActivityManagerSingleton\"); iActivityManagerSingletonField.setAccessible(true); //静态方法不用穿参数 Object iActivityManagerSingleton = iActivityManagerSingletonField.get(null); Class&lt;?&gt; singletonClass = Class.forName(\"android.util.Singleton\"); Field mInstance = singletonClass.getDeclaredField(\"mInstance\"); mInstance.setAccessible(true); Class&lt;?&gt; iActivityManagerClass = Class.forName(\"android.app.IActivityManager\"); Method getServiceMethod = activityManagerClass.getDeclaredMethod(\"getService\"); final Object iActivityManagerObj = getServiceMethod.invoke(null); //定义我们自己的IActivityManager Object proxyIActivityManager = Proxy.newProxyInstance(getClassLoader(), //需要监听的 IActivityManager new Class[]{iActivityManagerClass} , new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(\"startActivity\".equals(method.getName())){ Intent proxyIntent = new Intent(PluginApplication.this, ProxyActivity.class); proxyIntent.putExtra(\"targetIntent\",(Intent) args[2]); args[2] = proxyIntent; } return method.invoke(iActivityManagerObj, args); } }); //需要两个参数 IActivityManagerSingleton 和 我们自己的动态代理对象 mInstance.set(iActivityManagerSingleton,proxyIActivityManager); } 我们的目的很清楚，通过反射拿到IActivityManager的实例，然后把它替换成我们自己的proxyIActivityManager。动态代理对象中，我们把intent替换成一个注册过的Activity也就是ProxyActivity。现在我们就拦截住了，当我们跳转到LoginActivity这个没有注册的Activity的时候，就会先跳转到该Activity 效果： 当然这不是我们想要的效果，我们需要在检查完之后再给它替换回来，所以在检查完后还要Hook一个地方给它换回来。 第二个Hook点 熟悉Activity的启动流程的都知道，ActivityManagerService处理完成之后，会执行到realStartActivityLocked（可以看之前的文章：Activity启动流程（上） 和 **Activity启动流程（下））最终会回到ActivityThread类中的mH这个Handler中进行最后的处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445//frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.javafinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ...... // 为Activity的launch创建 transaction final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread, r.appToken); //创建一个LaunchActivityItem对象，并传添加到事物中 clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, mService.isNextTransitionForward(), profilerInfo)); //设置Activity的最终状态 final ActivityLifecycleItem lifecycleItem; if (andResume) { lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward()); } else { lifecycleItem = PauseActivityItem.obtain(); } clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. mService.getLifecycleManager().scheduleTransaction(clientTransaction); ......}//ActivityThread中 mH 这个Handler中的handleMessagepublic void handleMessage(Message msg) { ... switch (msg.what) { ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); if (isSystem()) { //系统流程中的客户端事务在客户端回收 // instead of ClientLifecycleManager to avoid being cleared before this transaction.recycle(); } break; ... } 在realStartActivityLocked方法中创建了一个LaunchActivityItem方法，添加到到事物中，最终在handler中执行真正的启动。msg.obj中封装的是ActivityManagerService传过来的对象信息，强转成ClientTransaction 1234567public class ClientTransaction implements Parcelable, ObjectPoolItem { /** A list of individual callbacks to a client. */ private List&lt;ClientTransactionItem&gt; mActivityCallbacks; ...} ClientTransaction内部有一个ClientTransactionItem的集合，在前面realStartActivityLocked方法中可以看到将一个LaunchActivityItem添加到ClientTransaction中的集合中，也就是mActivityCallbacks中。12345678910public class LaunchActivityItem extends ClientTransactionItem { private Intent mIntent; private int mIdent; private ActivityInfo mInfo; private Configuration mCurConfig; private Configuration mOverrideConfig; private CompatibilityInfo mCompatInfo; .... LaunchActivityItem中存储了Activity的各种信息，这里有一个mIntent参数，它现在的跳转是我们在上一个Hook点改变成的ProxyActivity，所以这里我们需要重新给他还原会我们的LoginActivity,这样才能顺利跳转到LoginActivity中 所以我们需要在执行Handler中的handleMessage方法之前将它给改了。 我们知道Handler的消息分发机制中有一个dispatchMessage方法 123456789101112public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } Activity的启动最终会执行handleMessage方法，而在这个之前有一个判断，如果mCallback不为null就执行(mCallback.handleMessage(msg)方法，所以我们可以给它传一个我们自己的CallBack，在内部将mIntent给改了，然后返回false它还是会继续执行下面的handleMessage方法，这样就完成了替换。 在Application中在写一个hookActivityThread方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void hookActivityThread() throws Exception{ //拿到mH对象 Class&lt;?&gt; activityThreadClass = Class.forName(\"android.app.ActivityThread\"); Field mHField = activityThreadClass.getDeclaredField(\"mH\"); mHField.setAccessible(true); //拿到ActivityThread对象 Object currentActivityThreadObj = activityThreadClass.getDeclaredMethod(\"currentActivityThread\").invoke(null); Object mHObj = mHField.get(currentActivityThreadObj); //拿到mCallback替换成我们自己的 Field mCallbackField = Handler.class.getDeclaredField(\"mCallback\"); mCallbackField.setAccessible(true); mCallbackField.set(mHObj,new MyCallBack()); }private class MyCallBack implements Handler.Callback{ @Override public boolean handleMessage(Message msg) { Object clientTransactionObj = msg.obj; //拿到intent ProxyActivity try { Class launchActivityItemClass = Class.forName(\"android.app.servertransaction.LaunchActivityItem\"); //从mActivityCallbacks中取出mLaunchActivityItem的对象 Field mActivityCallbacksField = clientTransactionObj.getClass().getDeclaredField(\"mActivityCallbacks\"); mActivityCallbacksField.setAccessible(true); List activityCallbackList = (List) mActivityCallbacksField.get(clientTransactionObj); if (activityCallbackList.size() == 0) { return false; } Object mLaunchActivityItem = activityCallbackList.get(0); if (!launchActivityItemClass.isInstance(mLaunchActivityItem)) { return false; } //找到mIntent字段准备替换 Field mIntentField = launchActivityItemClass.getDeclaredField(\"mIntent\"); mIntentField.setAccessible(true); //获取代理的Intent Intent ProxyIntent = (Intent) mIntentField.get(mLaunchActivityItem); //获取传过来的当前的Intent Intent targetIntent = ProxyIntent.getParcelableExtra(\"targetIntent\"); if(targetIntent!=null){ mIntentField.set(mLaunchActivityItem,targetIntent); } } catch (Exception e) { e.printStackTrace(); } return false; } } OK这样就完成了效果如下","link":"/2019/08/16/architecture/Andorid-Hook进阶/"},{"title":"AOP面向切面编程--解放你的双手","text":"AOP面向切面编程 假如现在有一个需求，在对数据库进行增删改查的时候，假如执行每个操作之前都要求把数据备份一下。这个时候怎么做比较好呢，难道要在每个方法之前都写一个save()方法吗，如果用到增删改查的地方非常多，这时候就非常麻烦了。 通过java中的动态代理就可以很方便的实现。比如 首先有个操作数据库的类123456789public interface DBOperation { int save(); int delete(); int insert(); Object get();} 定义一个activity，实现数据库操作接口，通过Proxy.newProxyInstance方法创建出DBOperation的代理实现类，这个方法需要一个InvocationHandler参数， 自定义一个InvocationHandler，在其invoke方法中我们就可以在执行每个方法之前和之后做一些自己的操作了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ProxyActivity extends AppCompatActivity implements DBOperation{ private final static String TAG = \"myTag &gt;&gt;&gt; \"; DBOperation db; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_proxy); db = (DBOperation) Proxy.newProxyInstance(DBOperation.class.getClassLoader() ,new Class[]{DBOperation.class},new DBHandler(this)); } public void action(View view) { db.delete(); } class DBHandler implements InvocationHandler{ DBOperation db; public DBHandler(DBOperation db) { this.db = db; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (db != null) { Log.e(\"TAG\",\"before\"); save(); Log.e(\"TAG\",\"after\"); return method.invoke(db,args); } return null; } } @Override public int save() { Log.e(TAG, \"保存数据\"); return 0; } @Override public int delete() { Log.e(TAG, \"删除数据\"); return 0; } @Override public int insert() { return 0; } @Override public Object get() { return null; }} 上面的代码点击执行action方法,执行结果如果下12342019-07-02 22:49:55.296 7516-7516/com.chs.architecturetest E/TAG: before2019-07-02 22:49:55.296 7516-7516/com.chs.architecturetest E/myTag &gt;&gt;&gt;: 保存数据2019-07-02 22:49:55.296 7516-7516/com.chs.architecturetest E/TAG: after2019-07-02 22:49:55.297 7516-7516/com.chs.architecturetest E/myTag &gt;&gt;&gt;: 删除数据 在项目开发中，我们经常会遇到这样的需求 统计用户的点击行为 在进入某些页面之前先判断是否登录，如果没登录就去登录页面 我们不可能去每个方法中都写相关的统计代码，如果类很多的情况下会麻烦死还容易出错，如果使用动态代理也是比较麻烦的，这时候我们可以使用AspectJ。 AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。 下面使用它来解决前面的两个问题 首先配置AspectJ app下的build.gralde中添加依赖 1implementation &apos;org.aspectj:aspectjrt:1.8.13&apos; 工程的build.gralde中添加classpath AspectJ还需要添加maven的依赖12345678910dependencies { classpath &apos;com.android.tools.build:gradle:3.4.1&apos; classpath &apos;org.aspectj:aspectjtools:1.8.10&apos; classpath &apos;org.aspectj:aspectjweaver:1.8.10&apos; }buildscript { repositories { mavenCentral() } 最后app下的build.gralde中添加AspectJ的编译代码,在dependencies同级添加。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.aspectj.bridge.IMessageimport org.aspectj.bridge.MessageHandlerimport org.aspectj.tools.ajc.Mainfinal def log = project.loggerfinal def variants = project.android.applicationVariantsvariants.all { variant -&gt; if (!variant.buildType.isDebuggable()) { log.debug(\"Skipping non-debuggable build type '${variant.buildType.name}'.\") return; } JavaCompile javaCompile = variant.javaCompile javaCompile.doLast { String[] args = [\"-showWeaveInfo\", \"-1.8\", \"-inpath\", javaCompile.destinationDir.toString(), \"-aspectpath\", javaCompile.classpath.asPath, \"-d\", javaCompile.destinationDir.toString(), \"-classpath\", javaCompile.classpath.asPath, \"-bootclasspath\", project.android.bootClasspath.join(File.pathSeparator)] log.debug \"ajc args: \" + Arrays.toString(args) MessageHandler handler = new MessageHandler(true); new Main().run(args, handler); for (IMessage message : handler.getMessages(null, true)) { switch (message.getKind()) { case IMessage.ABORT: case IMessage.ERROR: case IMessage.FAIL: log.error message.message, message.thrown break; case IMessage.WARNING: log.warn message.message, message.thrown break; case IMessage.INFO: log.info message.message, message.thrown break; case IMessage.DEBUG: log.debug message.message, message.thrown break; } } }} OK配置完毕下面开始解决第一个行为统计的问题 首先定义一个注解ClickBehavior，运行时注解，作用在方法上，并且有一个参数代表需要统计的行为的名称12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface ClickBehavior { String value();} 然后定义一个切面类 ClickBehaviorAspectJ123456789101112131415161718192021222324252627282930313233@Aspect//定义切面类public class ClickBehaviorAspectJ { private final static String TAG = \"myTag &gt;&gt;&gt; \"; //execution 定义切入点 //* *(..)) 通配符 可以处理所有ClickBehavior注解的方法 @Pointcut(\"execution(@com.chs.architecturetest.annotation.ClickBehaviorAspectJ * *(..))\") public void methodPointCut() {} //对切入点方法应该如何处理 环绕通知 切入点之前和之后需要做的的事情 @Around(\"methodPointCut()\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable { //获取签名方法 MethodSignature signature = (MethodSignature) joinPoint.getSignature(); //获取方法名 String methodName = signature.getName(); //获取class名 String className = signature.getDeclaringType().getSimpleName(); //获取需要统计的value值 String funName = signature.getMethod().getAnnotation(com.chs.architecturetest.annotation.ClickBehavior.class).value(); //当前时间 long begin = System.currentTimeMillis(); Log.e(TAG,\"ClickBehaviorAspectJ Method Before\"); Object proceed = joinPoint.proceed(); Log.e(TAG,\"ClickBehaviorAspectJ Method End\"); //执行时间 long duration = System.currentTimeMillis() - begin; Log.e(TAG, String.format(\"统计了：%s功能，在%s类的%s方法，用时%d ms\", funName, className, methodName, duration)); return proceed; }} 这里面有几个注解，一般用前三个就能完成 @Aspect 代表这是一个切面类 @Pointcut 设置需要切入的方法，这里设置的所有的有ClickBehavior注解的方法。我们也可以指定某一个类下的所有方法(&quot;execution(com.chs.architecturetest.MainActivity *(..))&quot;)，或者整个工程中的所有方法(&quot;execution(* *(..))&quot;) //execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?) @Around 对切入点方法应该如何处理 环绕通知 切入点之前和之后需要做的的事情 @Before(“methodPointCut()”) 切入之前执行 @After(“methodPointCut()”)切入之后执行 @AfterReturning(value = “methodPointCut()”, returning = “returnValue”) 返回通知，切点方法返回结果之后执行 @AfterThrowing(value = “methodPointCut()”, throwing = “throwable”) 异常通知，切点抛出异常时执行 在Activity中整3个按钮分别为登录，VIP，账户，并设置点击方法。给这几个点击方法设置行为点击注解123456789101112131415@ClickBehavior(\"VIP页面\")public void goToVip(View view) { Log.e(TAG,\"去VIP页面\"); startActivity(new Intent(this,OtherActivity.class));}@ClickBehavior(\"账户页面\")public void goToZh(View view) { Log.e(TAG,\"去账户页面\"); startActivity(new Intent(this,OtherActivity.class));}@ClickBehavior(\"登录页面\")public void goToLogin(View view) { Log.e(TAG,\"去登录页面\");} OK完成到这里行为统计就完成了，执行带@ClickBehavior注解的方法都会执行统计的代码， 比如点击登录按钮打印日志 12342019-07-02 23:23:48.639 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: ClickBehaviorAspectJ Method Before2019-07-02 23:23:48.639 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: 去登录页面2019-07-02 23:23:48.639 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: ClickBehaviorAspectJ Method End2019-07-02 23:23:48.640 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: 统计了：登录页面功能，在ProxyActivity类的goToLogin方法，用时0 ms 检查登录的功能 首先写一个注解ClickBehavior。它不需要有值 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface LoginBehavior {} 定义登录的AspectJ类123456789101112131415161718192021222324@Aspect//定义切面类public class LoginAspectJ { private final static String TAG = \"myTag &gt;&gt;&gt; \"; //execution 定义切入点 //* *(..)) 通配符 可以处理所有ClickBehavior注解的方法 @Pointcut(\"execution(@com.chs.architecturetest.annotation.LoginBehavior * *(..))\") public void methodPointCut() {} //对切入点方法应该如何处理 环绕通知 切入点之前和之后需要做的的事情 @Around(\"methodPointCut()\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable { //是否登录真实项目中去sharedprefrence中去那 Context context = (Context) joinPoint.getThis(); if(false){ Log.e(TAG, \"检测到已登录！\"); return joinPoint.proceed(); }else { Log.e(TAG, \"检测到没有登录！\"); context.startActivity(new Intent(context,LoginActivity.class)); return null; } }} 在around方法中就可以执行判断是否登录的逻辑了，真实项目中一般都是从SharedPreferences中拿到数据判断是否登录。 最后给需要判断登录状态的地方添加@LoginBehavior注解1234567891011121314151617@LoginBehavior @ClickBehavior(\"VIP页面\") public void goToVip(View view) { Log.e(TAG,\"去VIP页面\"); startActivity(new Intent(this,OtherActivity.class)); } @LoginBehavior @ClickBehavior(\"账户页面\") public void goToZh(View view) { Log.e(TAG,\"去账户页面\"); startActivity(new Intent(this,OtherActivity.class)); } @ClickBehavior(\"登录页面\") public void goToLogin(View view) { Log.e(TAG,\"去登录页面\"); } 比如这里将前面代码if判断中直接改为false，点击去VIP页面的按钮测试结果如下，会跳转到到登录页面12342019-07-02 23:26:00.057 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: ClickBehaviorAspectJ Method Before2019-07-02 23:26:00.058 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: 检测到没有登录！2019-07-02 23:26:00.067 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: ClickBehaviorAspectJ Method End2019-07-02 23:26:00.068 8640-8640/com.chs.architecturetest E/myTag &gt;&gt;&gt;: 统计了：VIP页面功能，在ProxyActivity类的goToVip方法，用时10 ms OK完成啦","link":"/2019/07/07/architecture/AOP面向切面编程-解放你的双手/"},{"title":"Gradle之Project，Task","text":"Gradle之Project，Task gradle基本概念百度百科：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 gradle是一个构建工具，也是一个编程框架 gradle组成： groovy核心语法 build script block gradle api gradle的优势: 相比于maven,ant构建更加灵活 可以服用各种插件 兼容上，兼容maven等所有功能 细粒度，可以自定义编译过程 gradle的生命周期gradle的生命周期主要分为3个阶段：Initialization初始化阶段，Configuration配置阶段，Execution执行阶段 Initialization：解析真个工程中的所有Project，构建所有Project赌赢的project对象 Configuration：解析project中的所有的task，构建成一个有向无环图 Execution：执行具体的task以及其依赖的task setting.gradle：这个文件是在初始化阶段执行，一个gradle项目中必须由setting.gradle这个文件，因为它决定了那些项目参与构建。在gradle的构建中这是最先执行的一个文件。 如何监听gradle的生命周期呢 在setting.gradle文件中可以监听初始化阶段和配置之前的阶段123456gradle.settingsEvaluated { println('初始化阶段开始执行...')}gradle.beforeProject { println('配置之前调用...')} 在build.gradle文件中，可以监听配置之后、task的执行阶段和执行完成的阶段123456789101112this.afterEvaluate { println('配置之后....')}gradle.taskGraph.beforeTask { println \"执行阶段 before task\"}gradle.taskGraph.afterTask { println \"执行阶段 afterTask \"}this.gradle.buildFinished { println(\"执行阶段完毕,构建完毕...\")} gradle Project官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project 在一个gradle项目中，怎么算是一个Project呢，以一个Android项目为例，跟工程算是一个Project，其内部的子module也是一个Project。准确的说，只要该文件夹下有build.gradle文件，它就是一个Project。每一个module在编译期间都会生成一个对应的project对象，我们在build.gradle中编写的代码，其实都是在一个project对象内部编写。 获取一个项目所有的project123this.getAllprojects().eachWithIndex { Project entry, int index -&gt; println(entry.name)} 获取Project中的目录12println(this.project.getRootDir().absolutePath)println(this.project.getBuildDir().absolutePath) gradle中拷贝文件，非常简单，比如把app目录下的proguard-rules.pro文件拷贝到根目录下的build文件夹下面1234copy { from(file('proguard-rules.pro')) into(getRootProject().getBuildDir())} file(‘’)函数可以定位当前project中的某个文件。 Project的依赖： 在一个Android项目的根目录中的build.gradle中，我们都会看到下面的一段配置：12345678910111213buildscript { repositories { google() jcenter() maven{ url 'http://localhost:8081/xxxx' } } dependencies { classpath 'com.android.tools.build:gradle:3.5.1' }} buildscript 就是依赖配置的核心部分，它接受一个闭包，内部可以设置很多参数，最重要的就是前面的两个repositories和dependencies。 repositories ：配置工程的仓库地址，按照顺序从不同的仓库中查找依赖。这里也可以添加本地的maven仓库地址 dependencies ：配置工程的插件依赖地址（gradle程序所依赖的第三方库）。比如com.android.tools.build:gradle:3.5.1就是谷歌开发的Android相关的插件还有平时开发经常用到的tinker相关插件，butterknife相关插件都在这里。 在Project中执行外部指令，比如下面的一个复制的任务： 12345678910111213141516171819202122task('copytask'){ //保证是在执行阶段 doLast{ def fromPath = this.buildDir.path + '\\\\outputs\\\\apk' def toPath = 'D:\\\\data' //外部命令脚本 def command = \"xcopy ${fromPath} /s ${toPath}\" println(command) //执行代码块 exec { try { //执行 dir命令， /c 表示 cmd窗口执行完 dir 命令后立即关掉， // 至于 cmd 后可带哪些参数，可在终端下 cmd /? 查看 commandLine 'cmd', '/c', command println('copytask is success') }catch(GradleException e){ println('copytask is failed') } } }} 上面的代码：定义一个资源路径、一个目标路径和一个复制的指令。这里使用的是windows中的复制目录的指令xcopy，在mac和linux中需要使用对应系统的指令。然后使用commandLine来执行指令。 gradle Task官方文档 ：https://docs.gradle.org/current/dsl/org.gradle.api.Task.html#org.gradle.api.Task task是构建过程中的基本单元，每一个task都属于一个project，每一个task都有一个自己的名字和一个唯一的路径，该路径在所有project和所有的task中都是唯一的。 Task的创建方式：第一种直接创建：123task('helloTask'){ println('hello task')} 第二种通过TaskContainer容器创建123this.tasks.create('helloTask2'){ println('hello task2')} 这两种方式创建的task没有区别，TaskContainer可以更好的管理task，它里面有创建task和查找task等方法。 Task的配置方式同样，Task的配置也有两种方式：比如下面的两种配置分组和描述信息。12345678910//第一种task helloTask(group:'hello',description:'hello task des'){ println('hello task')}//第二种this.tasks.create(name:'helloTask2'){ setGroup('hello') setDescription('hello create task') println('hello task2')} 不同的task设置相同的分组，方便查找，比如把我们自己自定义的task都设置到一个同样的分组中，跟系统的区分开。 自定义Task的执行时机当我们在studio的命令行执行前面的代码的时候，比如执行gradlew helloTask，我们只执行第一个task，执行结果会看到helloTask和helloTask2都会输出。这是因为前面的写法都是在gradle生命周期的配置阶段执行。 那如何让一个自定义的task在gradle的执行阶段执行，可以使用doFirst和doLast这两个闭包函数。因为系统中会有很多默认的task，比如Android中build和clean等。doFirst就是在系统task执行之前执行，doLast就是在系统的task执行之后执行。 123456789101112task helloTask(group:'hello',description:'hello task des'){ //配置阶段执行 println('hello task') //系统task执行之前 doFirst{ println('hello task do First') } //系统task执行之后 doLast{ println('hello task do Last') }} 通过doFirst和doLast，我们可以做一些事情，比如统计build执行阶段的时间123456789101112131415161718def buildStartTimedef buildEndTimethis.afterEvaluate { Project project -&gt; //afterEvaluate配置阶段完成后执行 def preTask = project.tasks.getByName('preBuild') preTask.doFirst{ buildStartTime = System.currentTimeMillis() } def endTask = project.tasks.getByName('build') endTask.doLast{ buildEndTime = System.currentTimeMillis() println(\"build 执行时间：${buildEndTime - buildStartTime}\") }}//输出&gt; Task :app:buildbuild 执行时间：28018 Task的依赖一个task可能会依赖一个或者多个别的task，那么在执行的时候，它所依赖的task会先执行 静态添加依赖，当我们明确知道需要依赖那几个task的时候123456789101112131415task taskA{ doLast{ println('i am taskA') }}task taskC{ doLast{ println('i am taskC') }}task taskB(dependsOn:[taskA,taskC]){ doLast{ println('i am taskB') }} taskB依赖了taskA和taskC，运行可以看到，taskA和taskC在taskB之前执行。 动态添加依赖，比如下面的taskB依赖所有name以lib开头的task 12345678910111213141516171819202122232425task lib1 { doLast{ println('i am lib1') }}task lib2 { doLast{ println('i am lib2') }}task lib3 { doLast{ println('i am lib3') }}task taskB { dependsOn project.tasks.findAll { task -&gt; return task.name.startsWith('lib') } doLast{ println('i am taskB') }} 控制task的执行顺序可以通过前面的依赖的方式，也可以通过mustRunAfter这个关键字来指定某个task的执行必须在谁的后面。 1234567891011121314151617task taskC{ doLast{ println('i am taskC') }}task taskB { mustRunAfter taskC doLast{ println('i am taskB') }}task taskA{ mustRunAfter taskB doLast{ println('i am taskA') }} 前面我们知道，通过this.afterEvaluate {}这个闭包我们可以在配置完成之后来执行我们自己的一些操作，那如何将我们自己的task插入到系统构建的中间部位执行呢？ 办法就是：通过mustRunAfter关键字，让我们的task必须执行在一个系统的task之后，然后通过dependsOn来让另一个一个系统的task依赖我们自己的task。这样就把我们自己的task插入到了这两个系统的task之间了。 Task的输入输出从proguard-rules.pro中读取数据，写入到destination.txt文件中 123456789101112131415161718192021task combineFileContent { def source = file('proguard-rules.pro') def destination = file('destination.txt') //inputs 属性应该被赋值为 一个目录、一个或多个文件、或是一个任意属性 inputs.file source // 将sources声明为该Task的inputs //outputs 应该被赋值为一个或多个目录或者一个或多个文件 outputs.file destination // 将destination声明为outputs doLast { source.withReader { reader -&gt; def lines = reader.readLines() destination.withWriter { writer -&gt; lines.each { line -&gt; writer.append(line+'\\r\\n') } } } }}","link":"/2019/11/21/architecture/Gradle之Project，Task/"},{"title":"Gradle之自定义插件","text":"Gradle之自定义插件 前面两篇了解了Gradle的基础知识，最终目的就是为了自己能写出Gradle插件来解决现实项目中的问题。现在Gradle自定义插件用的越来越广泛，插件化，热修复，性能优化，指标检测，多渠道打包等等都会用到Gradle插件。 自定义Gradle插件的方式有三种，代码都差不多，都是必须实现Plugin&lt;T&gt;这个接口，然后实现接口中的apply方法。只不过写的地方不一样。 第一种在build.gradle在AndroidStido中创建一个新项目，然后直接在app目录下的build.gradle文件中写插件1234567891011class MyPlugin implements Plugin&lt;Project&gt;{ @Override void apply(Project target) { println('MyPlugin执行了') target.task(\"mytask\"){ doLast { println('MyPlugin中的task执行了') } } }} 定义一个MyPlugin插件实现Plugin接口。然后在apply方法中自定义一个task。一个简单的插件就完成了。 然后在当前build.gradle文件中引入插件1apply plugin: MyPlugin OK完成，然后在控制台执行一下我们自己的task，window下命令：gradlew mytask 输出如下，Mac在gradlew前面加个./12345&gt; Configure project :appMyPlugin执行了&gt; Task :app:mytaskMyPlugin中的task执行了 使用这种方式可以很快的创建一个插件，不过缺点也很明显： 该plugin只能被当前build.gradle引用。 一个插件不可能就上面那几行代码，插件代码全写到这一个文件中，会让这个文件非常臃肿不好维护。 第二种在buildSrc文件夹下buildSrc是Gradle中的默认插件目录，编译的时候Gradle会自动识别这个目录，将其内的代码编译成插件。 可以先创建一个java的module，然后修改一个build.gradle文件为下面1apply plugin: 'groovy' 只写上面的一句话就行。因为需要写一个groovy项目，所以把main文件夹下的原来的java入口文件夹直接改成groovy，这种方式比较方便。 或者重新建一个groovy文件夹，然后把这个文件夹设置为项目的入口文件设置方式如下1234567sourceSets { main { groovy { srcDir 'src/main/groovy' } }} 然后开始在groovy文件夹下写插件代码 com.hsm.buildsrc.MyPlugin1234567891011class MyPlugin implements Plugin&lt;Project&gt; { @Override void apply(Project target) { println('buildSrc中MyPlugin执行了') target.task(\"mytask\"){ doLast { println('buildSrc中MyPlugin中的task执行了') } } }} 写完插件，怎么让gradle知道哪个是插件呢？ 在main目录下新建resources目录，然后在resources目录里面再新建META-INF目录，再在META-INF里面新建gradle-plugins目录。最后在gradle-plugins目录里面新建properties文件 properties文件的名字可以随便取，后面用到的时候就用这个取好的名字，这里就直接使用插件的包名了com.hsm.buildsrc。在properties文件中指明我们自定义的插件的类implementation-class=com.hsm.buildsrc.MyPlugin 然后去app中的build.gradle文件中引入插件1apply plugin: 'com.hsm.buildsrc' 最后控制台输入命令验证插件gradlew mytask12345&gt; Configure project :appbuildSrc中MyPlugin执行了&gt; Task :app:mytaskbuildSrc中MyPlugin中的task执行了 使用这种方式写的插件，整个工程中的所有module都可以引用到，而且插件代码在自己的文件夹中，也方便维护。 第三种自定义module，上传maven第二种方式写的插件只能在当前工程中使用，有时候我们需要插件能多个工程都能使用，比如我们的项目中可以使用butterknife的插件，可以使用greenDao的插件。这就需要把我们的插件上传到别的仓库中比如maven。 在项目中新建一个module，这里命名为plugin_module，可以是java module也可以是android Library反正最后都得改嘿嘿。最好建个java的改的少。 修改build.gradle文件为下面12345678910111213141516171819202122232425apply plugin: 'groovy'apply plugin: 'maven'dependencies { //gradle sdk implementation gradleApi() //groovy sdk implementation localGroovy()}//uploadArchives是将已经自定义好了插件打包到本地Maven库里面去，//也可以选择打包到远程服务器中。其中， group和version是我们之后配置插件地址时要用到的。group='com.hsm.plugin_module'version='1.0'uploadArchives { repositories { mavenDeployer { //本地的Maven地址:当前工程下 repository(url: uri('./my-plugin')) //提交到远程服务器： // repository(url: \"http://www.xxx.com/repos\") { // authentication(userName: \"admin\", password: \"admin\") // } } }} dependencies中添加gradle sdk和groovy sdk之后，我们建的这个module就可以开发gradle的工程了。 uploadArchives是将已经自定义好了插件打包到本地Maven库里面去，也可以选择打包到远程服务器中 group和version是别的项目引用的时候使用的组名和版本号 开始编写插件：1234567891011class MyPlugin implements Plugin&lt;Project&gt; { @Override void apply(Project target) { println('plugin_module 中MyPlugin执行了') target.task(\"mytask\"){ doLast { println('plugin_module中MyPlugin中的task执行了') } } }} 然后跟第二步中的步骤一样创建resources目录和resources下面的各个目录和文件。这里使用的包名是com.hsm.plugin_module 执行gradle命令上传插件jar包到maven仓库gradlew uploadArchives，执行完之后jar包就上传到了我们前面定义的./my-plugin下面，内容如下图 最后去工程中使用插件 首先来到主工程的build.gradle文件夹下引入插件的仓库和依赖123456789101112131415buildscript { repositories { maven { //本地仓库地址 url uri('D:/androiddemo/5/GradlePlugin/plugin_module/my-plugin') } google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.5.2' ////格式为--&gt;group:module:version classpath 'com.hsm.plugin_module:plugin_module:1.0' }} 设置本地仓库的地址 在dependencies中引入插件，格式为group:module:version 然后去app文件夹下的build.gradle文件中引入插件1apply plugin: 'com.hsm.plugin_module' 到这里就OK了，控制台中输入命令验证：gradlew mytask12345&gt; Configure project :appplugin_module 中MyPlugin执行了&gt; Task :app:mytaskplugin_module中MyPlugin中的task执行了 插件的扩展 Extension我们在集成tinker的时候，会在build.gradle文件中配置tinkerPatch的各种参数比如oldApk ，useSign，buildConfig 等等， 这就是在配置插件中的参数或者属性，而插件的扩展Extension就是用来把这些参数传回插件中。 现在给第三步中的插件添加一个扩展Extension 在插件的module中新建一个实体类MyExtension123456package com.hsm.plugin_moduleclass MyExtension { int id String name} 然后去MyPlugin插件类中添加扩展123456789101112131415161718class MyPlugin implements Plugin&lt;Project&gt; { @Override void apply(Project target) { println('plugin_module 中MyPlugin执行了') //1.添加插件扩展到project.extensions集合中 target.extensions.add('myextension',MyExtension) target.task(\"mytask\"){ doLast { println('plugin_module中MyPlugin中的task执行了') //2.获取外界配置的 TestExtension MyExtension extension = target.myextension //3.输出插件扩展属性 println \"&gt;&gt;&gt;&gt;&gt;&gt; name: ${extension.name} id:${extension.id}\" } } }} 通过project.extensions.add方法将自定义的实体添加到扩展中，并起个名字 可以通过起的名字拿到扩展的实体类 最后拿到类中的属性 修改完之后重新上传到maven，如果版本号没变，最好先把仓库以前的文件删掉在上传 上传完成之后去项目app目录下的build.gradle中使用 123456apply plugin: 'com.hsm.plugin_module'myextension{ id 123 name 'chs'} 控制台中执行命令验证：gradlew mytask123456&gt; Configure project :appplugin_module 中MyPlugin执行了&gt; Task :app:mytaskplugin_module中MyPlugin中的task执行了&gt;&gt;&gt;&gt;&gt;&gt; name: chs id:123 OK，Gradle创建插件的流程完毕，想要完成更加复杂的功能，只需要在该插件中定义各种各样的task来完成不同的逻辑即可。","link":"/2019/11/28/architecture/Gradle之自定义插件/"},{"title":"占位式插件化之加载静态广播","text":"占位式插件化之加载静态广播 接着前几篇文章来：由于插件中的广播是在manifest中配置的，所以就不能使用上一篇中的方法来注册广播了，首先我们需要了解一下APK的解析原理 第一步我们要知道静态广播是什么时候注册的？ 在手机开机的时候，系统谁扫描所有的app，在重新安装一遍，这也是为啥手机开机会这么慢，这时候系统会去解析AndroidManifest文件，解析的过程中遇到静态广播后就会自动注册 第二步我们来看一下应用的安装目录 主要有三个目录 /data/app 该文件夹存放着系统中安装的第三方应用的 apk 文件，当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading …..就是上传我们的apk到这个文件夹，上传成功之后才开始安装。Android 中应用的安装就是将应用的安装包原封不动地拷贝到 /data/app 目录下，每个应用安装包本质上就是一个 zip 格式的压缩文件。为了提升应用的启动效率，Android 会将解压出来的 dex 格式的应用代码文件解析提取后，缓存在 /data/dalvik-cache 目录下。 /data/data 该文件夹存放存储包私有数据，对于设备中每一个安装的 App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。用户卸载 App 时，系统自动删除 data/data 目录下对应包名的文件夹及其内容。 data/dalvik-cache 虚拟机去加载执行指令 通过上面的解释，可以知道，我们应该分析data/app这个目录，手机开机的时候就会扫描这个目录，来解析apk中的配置信息。 然后就开始看看系统是怎么来解析apk文件的，系统中的包的解析都是通过PackageManagerService这个类来解析的，当系统启动的时候，首先启动Linux内核驱动，然后启动init进程，然后启动zygote孵化进程，在然后启动SystemServer进程，然后启动PackageManagerService。 所以我们去PackageManagerService这个类中看看系统是怎么解析data/app中的 apk文件的 下面的源码是基于Android9.0的，每个版本的源码可能不一样 Ok 现在来到PackageManagerService这个类中 我们从文件目录入手，可以看到它有几个静态的成员变量123456789 /** Directory where installed applications are stored */private static final File sAppInstallDir = new File(Environment.getDataDirectory(), \"app\");/** Directory where installed application's 32-bit native libraries are copied. */private static final File sAppLib32InstallDir = new File(Environment.getDataDirectory(), \"app-lib\");/** Directory where code and non-resource assets of forward-locked applications are stored */private static final File sDrmAppPrivateInstallDir = new File(Environment.getDataDirectory(), \"app-private\"); 其中第一个sAppInstallDir就是我们要找的安装目录data/app，所以从这里入手，看看系统是怎么解析apk文件的。 全局搜索sAppInstallDir就可以找到scanDirTracedLI这个方法，从名字也能看出，它就是扫描该目录。内部也会解析manifest文件，所以从这里开始分析，我们跟随扫描的方法一步一步的往下看。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 private void scanDirTracedLI(File scanDir, final int parseFlags, int scanFlags, long currentTime) { Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanDir [\" + scanDir.getAbsolutePath() + \"]\"); try { scanDirLI(scanDir, parseFlags, scanFlags, currentTime); } finally { Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); } }private void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime) { ... for (File file : files) { final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) { // Ignore entries which are not packages continue; } //开启线程池来解析 parallelPackageParser.submit(file, parseFlags); fileCount++; } ...}//mService是线程池public void submit(File scanFile, int parseFlags) { mService.submit(() -&gt; { ParseResult pr = new ParseResult(); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parallel parsePackage [\" + scanFile + \"]\"); try { PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); pp.setDisplayMetrics(mMetrics); pp.setCacheDir(mCacheDir); pp.setCallback(mPackageParserCallback); pr.scanFile = scanFile; //解析包 pr.pkg = parsePackage(pp, scanFile, parseFlags); } catch (Throwable e) { pr.throwable = e; } finally { Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); } try { mQueue.put(pr); } catch (InterruptedException e) { Thread.currentThread().interrupt(); mInterruptedInThread = Thread.currentThread().getName(); } }); } @VisibleForTesting protected PackageParser.Package parsePackage(PackageParser packageParser, File scanFile, int parseFlags) throws PackageParser.PackageParserException { return packageParser.parsePackage(scanFile, parseFlags, true /* useCaches */); } 这一路跟随，最后到了PackageParser这个类中的parsePackage方法。 1234567891011121314151617181920//packageFile文件包的路径 public Package parsePackage(File packageFile, int flags) throws PackageParserException { return parsePackage(packageFile, flags, false /* useCaches */); }public Package parsePackage(File packageFile, int flags, boolean useCaches) throws PackageParserException { Package parsed = useCaches ? getCachedResult(packageFile, flags) : null; if (parsed != null) { return parsed; } long parseTime = LOG_PARSE_TIMINGS ? SystemClock.uptimeMillis() : 0; if (packageFile.isDirectory()) { parsed = parseClusterPackage(packageFile, flags); } else { parsed = parseMonolithicPackage(packageFile, flags); } ... return parsed; } 到这里我们就知道系统是通过parsePackage这个方法来解析apk文件的，那么我们是不是可以反射得到这个方法来解析我们自己的apk包呢？当然可以啦，最后我们只要拿到Package这个对象就行了，这个Package对象是parsePackage的内部类，它里面包含了AndroidManifest中的所有信息包含Permission，Activity，Service，Provider，广播等等。能拿到静态广播的信息就可以给它注册了。 所以现在接着前两篇文章来，在PluginManager类中添加一个解析apk获取广播并注册的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 反射系统源码来解析自己的apk 注册广播 */ public void parseApkGetReceiver(){ try { File file = new File(Environment.getExternalStorageDirectory()+File.separator+\"p.apk\"); if(!file.exists()){ Log.i(TAG,\"插件包不存在\"); } //执行系统 PackageParser中的parsePackage方法来解析 Class&lt;?&gt; packageParserClass = Class.forName(\"android.content.pm.PackageParser\"); Object packageParser = packageParserClass.newInstance(); Method parsePackage = packageParserClass.getMethod(\"parsePackage\",File.class,int.class); //mPackage就是PackageParser中的Package类 Object mPackage = parsePackage.invoke(packageParser, file, PackageManager.GET_ACTIVITIES); //分析 mPackage拿到里面的广播的集合 Field receiversField = mPackage.getClass().getDeclaredField(\"receivers\"); //本质是ArrayList集合 public final ArrayList&lt;Activity&gt; receivers = new ArrayList&lt;Activity&gt;(0); Object receivers = receiversField.get(mPackage); ArrayList list = (ArrayList) receivers; //集合内部的元素activity是PackageParse的内部类 是一个广播的封装类 for (Object activity : list) { //拿到intentfilter Class&lt;?&gt; componentClass = Class.forName(\"android.content.pm.PackageParser$Component\"); Field intentsFile = componentClass.getDeclaredField(\"intents\"); ArrayList&lt;IntentFilter&gt; intents = (ArrayList) intentsFile.get(activity); Class&lt;?&gt; packageUserState = Class.forName(\"android.content.pm.PackageUserState\"); Class&lt;?&gt; userHandle = Class.forName(\"android.os.UserHandle\"); int userId = (int) userHandle.getDeclaredMethod(\"getCallingUserId\").invoke(null); //拿到广播的全类名 Method generateActivityInfoMethod = packageParserClass. getDeclaredMethod(\"generateActivityInfo\", activity.getClass(), int.class,packageUserState,int.class); generateActivityInfoMethod.setAccessible(true); ActivityInfo activityInfo = (ActivityInfo) generateActivityInfoMethod.invoke(null, activity, 0, packageUserState.newInstance(), userId); //插件包中的广播的全类名 String receiverClassName = activityInfo.name; Class&lt;?&gt; receiverClass = getClassLoader().loadClass(receiverClassName); BroadcastReceiver broadcastReceiver = (BroadcastReceiver) receiverClass.newInstance(); for (IntentFilter intentFilter : intents) { //注册广播 mContext.registerReceiver(broadcastReceiver,intentFilter); } } }catch (Exception e){ e.printStackTrace(); } } 写了这么多反射的代码，其实我们主要的目的只有两个第一个拿到intentFilter，第二个拿到broadcastReceiver， 最后调用mContext.registerReceiver方法注册广播。其余代码都是为了找到这两个参数来服务的。 在插件包中定义一个广播并注册到manifest中123456789101112131415161718public class PluginStaticReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, \"我是静态注册的广播，我收到广播啦\", Toast.LENGTH_SHORT).show(); }} &lt;receiver android:name=\".PluginStaticReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"plugin.package.PluginStaticReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 最后在MainActivity中加两个按钮，加载注册广播并发送广播123456789public void loadStaticReceiver(View view) { PluginManager.getInstance(this).parseApkGetReceiver(); } public void sendStaticReceiver(View view) { Intent intent = new Intent(); intent.setAction(\"plugin.package.PluginStaticReceiver\"); sendBroadcast(intent); } 效果：","link":"/2019/08/16/architecture/占位式插件化之加载静态广播/"},{"title":"占位式插件化之加载Activity","text":"占位式插件化之加载Activity 在一些大型的项目中，经常会用到插件化，插件化的优点有不少，即插即用，把不同的功能打包成不同的APK文件，通过网络下发到APP端，直接就可以使用，不用通过应用市场即可随时增加新功能，非常适用于功能多又需要敏捷开发的应用 可以实现插件化的方式有很多种，本系列先通过占位式的方法来实现。 我们知道，一个apk文件需要通过安装才能运行使用，那我们的插件apk是直接通过网络下载到本地的，不通过用户的安装，也就没有上下文环境context，怎么才能运行里面的功能呢？ 其中的一种方式就是使用占位式来开发，首先我们肯定有一个宿主APP，这个APP已经发布到市场上并安装到了用户的手机上，这个APP中有一个APK运行所需要的所有的环境，那我们想办法把这里面的环境传到我们的插件包APK中，插件包中都使用穿过来的环境就能正常的工作了。 然后就是宿主APP中怎么加载插件apk中的类和资源文件呢？这个需要了解一下Android中的类加载技术，简单说一下，Andorid中使用PathClassLoader来加载自身应用中的类，使用DexClassLoader来加载外部的文件（apk,zip等），使用Resources类来加载资源文件。 最后类加载完了，宿主APP中怎么调用插件中的对应的方法呢，它不知道什么时候该调用什么方法啊。这时候我们就可以用到面向接口编程了，让宿主APP和插件APP都依赖一套相同的接口标准，到时候通过这个相同的接口标准来调用对应的方法。 OK说了一大堆，现在开始干吧，先撸一个加载Activity的 首先如图在AndroidStudio中建立两个app和一个module，这两个app分别是宿主app和插件app，他们两个都依赖同一个module，这个module中定义了一些接口标准 先来看看Activity的接口标准：1234567891011121314151617public interface ActivityInterface { /** * 把宿主(app)的环境给插件 * @param appActivity 宿主环境 */ void insertAppContext(Activity appActivity); void onCreate(Bundle savedInstanceState); void onStart(); void onResume(); void onDestroy();} 标准很简单，主要分为两部分，第一部分插件中不是没有运行环境吗，那定义一个方法，专门用来把宿主的环境传过来。第二部分，在里面实现所有我们需要用到的activity的声明周期方法，这里就实现了几个常用的。 OK，标准包中就完事了 下面我们来到插件包中，定义一个BaseActivity，用它来实现标准接口和接收宿主传过来的环境，还有重写Activity中的相关方法。123456789101112131415161718192021222324252627282930313233public class BaseActivity extends Activity implements ActivityInterface { public Activity appActivity; @Override public void insertAppContext(Activity appActivity) { this.appActivity = appActivity; } @SuppressLint(\"MissingSuperCall\") @Override public void onCreate(Bundle savedInstanceState) { } @SuppressLint(\"MissingSuperCall\") @Override public void onStart() { } @SuppressLint(\"MissingSuperCall\") @Override public void onResume() { } @SuppressLint(\"MissingSuperCall\") @Override public void onDestroy() { } public void setContentView(int resId){ appActivity.setContentView(resId); }} BaseActivity实现了ActivityInterface接口，并实现了接口中的方法。 注意： BaseActivity中重写了setContentView方法，为什么呢？因为setContentView是当前插件Activity中的方法，而当前的插件Activity是没有上下文环境的，调用这个肯定就报错啦，为了能正常运行，我们只能通过宿主传过来的环境来调用相关的方法。这只是开始，后面很多跟环境有关的方法都需要在这里重写一下转为通过宿主的环境调用，这也是占位式插件化的一个缺点。 定义一个PluginActivity来继承自BaseActivity，等会我们将从宿主APP中跳转到此Activity。这是我们在插件中的第一个Activity，需要注册到manifest中，后面宿主跳转时需要用到，在后面创建的Activity就不用注册了。 12345678public class PluginActivity extends BaseActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_plugin); Toast.makeText(appActivity,\"我是插件中的activity\",Toast.LENGTH_SHORT).show();} OK，插件包中的类写完了,现在我们来到宿主app中创建一个工具来，用来加载插件包中的类和资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class PluginManager { private static final String TAG = PluginManager.class.getSimpleName(); public static PluginManager instance; private Context mContext; public static PluginManager getInstance(Context context){ if(instance == null){ synchronized (PluginManager.class){ if(instance == null){ instance = new PluginManager(context); } } } return instance; } private PluginManager(Context context) { mContext = context; } private DexClassLoader mClassLoader; private Resources mResources; public void loadPlugin(){ try { File file = new File(Environment.getExternalStorageDirectory()+File.separator+\"p.apk\"); if(!file.exists()){ Log.i(TAG,\"插件包不存在\"); } String pluginPath = file.getAbsolutePath(); //创建classloader用来加载插件中的类 //创建一个缓存目录 /data/data/包名/pDir File fileDir = mContext.getDir(\"pDir\",Context.MODE_PRIVATE); mClassLoader = new DexClassLoader(pluginPath,fileDir.getAbsolutePath(), null,mContext.getClassLoader()); //创建resource用来加载插件中的资源 //AssetManager 资源管理器 final修饰的不能new AssetManager assetManager = AssetManager.class.newInstance(); //addAssetPath方法可以加载apk文件 Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class); addAssetPathMethod.invoke(assetManager, pluginPath); //拿到当前宿主的resource 用来回去当前应用的分辨率等信息 Resources resources = mContext.getResources(); //用来加载插件包中的资源 mResources = new Resources(assetManager,resources.getDisplayMetrics(),resources.getConfiguration()); }catch (Exception e){ e.printStackTrace(); } } public DexClassLoader getClassLoader() { return mClassLoader; } public Resources getResources() { return mResources; }} 首先是加载类，我们通过创建一个DexClassLoader来加载，创建DexClassLoader需要三个参数一个是插件包的路径，一个是缓存/data/data/包名/pDirpDir是我们自己命名。和一个classloader。 然后是加载资源，通过创建Resources来加载资源，它需要三个参数，AssetManager ，分辨率信息和配置信息，分辨率信息和配置信息我们可以通过当前宿主中的Resources拿到。AssetManager可以通过反射执行它内部的addAssetPath方法来拿到。 然后我创建一个代理Activity123456789101112131415161718192021222324252627282930313233343536public class ProxyActivity extends Activity { @Override public Resources getResources() { return PluginManager.getInstance(this).getResources(); } @Override public ClassLoader getClassLoader() { return PluginManager.getInstance(this).getClassLoader(); } @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 插件里面的 Activity String className = getIntent().getStringExtra(\"className\"); //实例化插件包中的activity try { Class&lt;?&gt; pluginClass = getClassLoader().loadClass(className); Constructor&lt;?&gt; constructor = pluginClass.getConstructor(new Class[]{}); Object pluginActivity = constructor.newInstance(new Object[]{}); //强转为对应的接口 ActivityInterface activityInterface = (ActivityInterface) pluginActivity; activityInterface.insertAppContext(this); Bundle bundle = new Bundle(); bundle.putString(\"content\",\"从宿主传过来\"); //执行插件中的方法 activityInterface.onCreate(bundle); } catch (Exception e) { e.printStackTrace(); } }} 这个代理的Activity非常重要，它是一个真正的Activity，需要注册到manifest中，插件中的Activity最终都是通过它来展示。 首先我们重写它里面的getResources和getClassLoader方法，返回我们工具类中自己定义的classloader和resource。 然后在onCreate方法中，通过插件中需要启动的Activity的全类名来加载插件中的Activity。 由于我们知道插件中的Activity都实现了ActivityInterface接口，所以这里我们就可以直接强转成ActivityInterface， 最后调用ActivityInterface中的对应的生命周期方法即可。 那这个PluginActivity的全类名怎么来呢，在点击跳转到PorxyActivity的时候通过Intent传过来 下面我们来到MainActivity中加载插件并找到PluginActivity的全类名并跳转。1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void loadPlugin(View view) { PluginManager.getInstance(this).loadPlugin(); } public void startPlugin(View view) { //获取插件包中的activity的全类名 File file = new File(Environment.getExternalStorageDirectory() + File.separator + \"p.apk\"); String path = file.getAbsolutePath(); // 获取插件包 里面的 Activity PackageManager packageManager = getPackageManager(); PackageInfo packageInfo = packageManager.getPackageArchiveInfo(path, PackageManager.GET_ACTIVITIES); ActivityInfo activityInfo = packageInfo.activities[0]; Intent intent = new Intent(this,ProxyActivity.class); intent.putExtra(\"className\",activityInfo.name); startActivity(intent); }} 寻找PluginActivity的全类名，通过PackageManager 这个类，传入插件的路径最后通过getPackageArchiveInfo方法就可以拿到啦。ActivityInfo 中记录了manifest中所有的activity，因为我们插件的manifest中只注册一个Activity就可以了，所以直接取第0个就可以啦。 OK，到这里我们就可以顺利的从宿主的APP中跳转到插件APK中的PluginActivity了。 当然一个插件不能跳到插件的首页就完事了，插件有很多功能，内部也需要继续跳转到别的界面，插件内部怎么跳转呢，直接startActivity吗？当然不行啦，就跟前面的setContentView不能直接用一样，插件中是没有上下文环境的，而startActivity最终会进入到当前插件的Activity中，会报错，需要使用宿主传过来的环境，所以插件中的BaseActivity中还的需要重写startActivity方法。 123456789101112public View findViewById(int layoutId) { return appActivity.findViewById(layoutId); } @Override public void startActivity(Intent intent) { Intent intentNew = new Intent(); // PluginActivity 全类名 intentNew.putExtra(\"className\", intent.getComponent().getClassName()); appActivity.startActivity(intentNew); } 当然findViewById这个方法内部也是通过上下文环境调用的，所以也需要重写，然后转化为宿主的环境来调用。主要注意的是，后面凡是用到上下文环境的方法，都需要重写，转化为宿主的环境，这也时占位式插件化的一个非常麻烦的地方，不过它的好处是比较稳定，相对于通过hook来做兼容性比较好。 PluginActivity中添加点击事件123456findViewById(R.id.bt_start_activity).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startActivity(new Intent(appActivity, Plugin2Activity.class)); }}); 启动插件中的首页是启动了一个代理的Activity（ProxyActivity），而插件内部的跳转的本质就是在启动一个ProxyActivity，把当前要启动的Activity的全类名带过去，然后通过类加载，流程跟启动第一个Activity一样。 插件首页的Activity的全类名我们需要去manifest中拿，插件内部跳转就不用那么麻烦了，只需要通过intent就能拿到了。 所以我们需要在ProxyActivity中重写startActivity方法，拿到插件包中的Activity之后，自己跳自己，这样我们就能让插件中的一个新的Activity进栈出栈了，点击返回键可以返回上一个Activity。1234567@Override public void startActivity(Intent intent) { String className = intent.getStringExtra(\"className\"); Intent proxyIntent = new Intent(this,ProxyActivity.class); proxyIntent.putExtra(\"className\",className); super.startActivity(proxyIntent); } OK 这样就实现了跳转到插件首页和插件内部跳转的功能啦。下一篇来聊一下加载Service 把插件包打包成apk，放到手机根目录中 效果","link":"/2019/08/13/architecture/占位式插件化之加载Activity/"},{"title":"占位式插件化之加载Service和动态广播","text":"占位式插件化之加载Service和动态广播 接着上一篇加载Activity来，启动Service和启动Activity的套路是一样的，宿主端定义一个代理的Service，标准的module中定义一个Service的标准接口，然后开始干。 先来到标准module中添加一个Service的标准接口123456789101112131415public interface ServiceInterface { /** * 把宿主(app)的环境传给插件 * @param appService */ void insertAppContext(Service appService); public void onCreate(); public int onStartCommand(Intent intent, int flags, int startId); public void onDestroy();} 跟Activity一样，这里可以吧Service的所有生命周期方法都加进来，这里就加入几个主要的方法。 然后来到插件包中，创建一个BaseService来接收宿主传过来的上下文环境12345678910111213141516171819202122232425262728293031323334public class BaseService extends Service implements ServiceInterface { public Service appService; /** * 把宿主(app)的环境传给插件 * @param appService */ public void insertAppContext(Service appService){ this.appService = appService; } @Nullable @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { } @SuppressLint(\"WrongConstant\") @Override public int onStartCommand(Intent intent, int flags, int startId) { return 0; } @Override public void onDestroy() { }} BaseService实现了ServiceInterface接口，并实现接口中的方法来公子类调用 然后创建一个测试的Service PluginService1234567891011121314151617181920212223242526272829303132public class PluginService extends BaseService { private static String TAG = PluginService.class.getName(); @Override public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { new Thread(){ @Override public void run() { super.run(); while (true){ try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }finally { Log.i(TAG,\"插件中的服务在运行......\"); } } } }.start(); return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); }} 在PluginService中开启一个线程打印日志用来开启服务之后测试使用 PluginActivity中设置点击开启服务的按钮123456findViewById(R.id.btn_service).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startService(new Intent(appActivity,PluginService.class)); } }); 这里使用了startService方法，根据前面的套路，这个方法也需要安装的上下文环境，所以我们还是得在BaseActivity中重写此方法来转换为宿主传过来的环境。调用宿主中的startService方法，并把当前PluginService的全类名传过去。1234567@Override public ComponentName startService(Intent service) { Intent intentNew = new Intent(); // PluginService 全类名 intentNew.putExtra(\"className\", service.getComponent().getClassName()); return appActivity.startService(intentNew); } OK，插件包中的调用已经完成，下面就来到了宿主中的代理Service中了1234567891011121314151617181920212223242526272829303132333435363738394041public class ProxyService extends Service { @Nullable @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { //PluginService的全类名 String className = intent.getStringExtra(\"className\"); try { Class mTestServiceClass = PluginManager.getInstance(this).getClassLoader().loadClass(className); Object mTestService = mTestServiceClass.newInstance(); ServiceInterface serviceInterface = (ServiceInterface) mTestService; // 注入 组件环境 serviceInterface.insertAppContext(this); serviceInterface.onStartCommand(intent, flags, startId); } catch (Exception e) { e.printStackTrace(); } return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); }} ProxyService是一个真实的服务，需要在manifest中注册。 套路跟Activity中一样，先通过intent拿到需要启动的Service的全类名，然后通过类加载工具加载需要启动的服务，强转成对应的标准接口，最后调用接口中的方法来完成。 跟上一篇中的插件内跳转Activity一样，我们需要告诉系统我们需要跳转到哪个Serice，所以重写startService方法1234567@Override public ComponentName startService(Intent service) { String className = service.getStringExtra(\"className\"); Intent proxyIntent = new Intent(this,ProxyService.class); proxyIntent.putExtra(\"className\",className); return super.startService(proxyIntent); } 告诉系统我们要跳转到代理的服务中，通过插件中传过来的intent拿到包名传到代理服务中，这样就完成了。 效果： 是不是很简单啊，既然套路都一样，下面把动态广播也一块写了。 先来到标准module中添加广播的标准接口12345public interface ReceiverInterface { public void onReceive(Context context, Intent intent);} 然后来到插件包中，创建一个广播，并实现标准接口1234567public class PluginReceiver extends BroadcastReceiver implements ReceiverInterface { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, \"我是插件里面的广播接收者，我收到广播啦\", Toast.LENGTH_SHORT).show(); }} 然后到PluginActivity中添加注册广播和发送广播的按钮123456789101112131415161718//注册广播findViewById(R.id.btn_receive).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { IntentFilter filter = new IntentFilter(); filter.addAction(\"com.chs.plugin_package.FILTER_ACTION\"); registerReceiver(new PluginReceiver(),filter); }});//发送广播findViewById(R.id.btn_receive_send).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); intent.setAction(\"com.chs.plugin_package.FILTER_ACTION\"); sendBroadcast(intent); }}); 这里的registerReceiver和sendBroadcast和之前的startActivity和startService一样，都是通过安装环境来调用，所以依然需要在BaseActivity中重写一些转换成宿主的环境123456789@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) { return appActivity.registerReceiver(receiver, filter);}@Overridepublic void sendBroadcast(Intent intent) { appActivity.sendBroadcast(intent);} 最后回到宿主APP中，使用一个代理的广播来接收1234567891011121314151617181920212223public class ProxyReceiver extends BroadcastReceiver { //插件中 PluginReceiver的全类名 private String pluginReceiverName; public ProxyReceiver(String name) { pluginReceiverName = name; } @Override public void onReceive(Context context, Intent intent) { try { Class&lt;?&gt; pluginServiceClass = PluginManager.getInstance(context). getClassLoader().loadClass(pluginReceiverName); Object pluginService = pluginServiceClass.newInstance(); ReceiverInterface receiverInterface = (ReceiverInterface) pluginService; receiverInterface.onReceive(context,intent); } catch (Exception e) { e.printStackTrace(); } }} ProxyReceiver也是一个真实的广播，可以接收到广播。前面Activity和Service都是通过Intent来传递插件中对应类的全类名的，这里不大一样，可以通过构造方法直接传过来。然后就是类加载，强转为对应的标准接口，最后调用接口中的方法啦 我们也需要在ProxyActivity中重写一下注册广播的方法，然后拿到插件中广播类的全类名然后传到代理广播中12345@Override public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) { ProxyReceiver proxyReceiver = new ProxyReceiver(receiver.getClass().getName()); return super.registerReceiver(proxyReceiver, filter); } OK广播也完成啦 效果：","link":"/2019/08/13/architecture/占位式插件化之加载Service和动态广播/"},{"title":"Flutter基础--状态管理","text":"Flutter基础–状态管理 当我们使用编译器创建一个新Flutter应用的时候，我们可以在主界面看到两个小部件StatelessWidget和StatefulWidget。这是两个最常见使用最频繁的小部件了。 StatelessWidget ，StatefulWidget StatelessWidget 状态不可改变的，它内部的数值和UI都应该是常量不可改变 StatefulWidget 状态可变，我们可以通过点击，或者网络获取数据等来动态的改变界面。 假如我们要实现如下图的功能，点击加一。如果使用StatelessWidget，会发现点击的时候count是加一了，但是界面没有刷新。应该使用StatefulWidget，当count加一的时候通过setState(() { _count++;});方法来改变count的值，这时候就发现界面可以刷新了。 比如12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import 'package:flutter/material.dart';class StateManagerDemo extends StatefulWidget { @override _StateManagerDemoState createState() =&gt; _StateManagerDemoState();}class _StateManagerDemoState extends State&lt;StateManagerDemo&gt; { int _count = 0; void countCallBack(){ setState(() { _count++; }); debugPrint('$_count'); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('StateManagerDemo'), elevation: 0.0, ), body: Counter0(_count), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: countCallBack, ), ); }}//------class Counter0 extends StatelessWidget { final int count; Counter0(this.count); @override Widget build(BuildContext context) { return Center( child: Chip( label: Text('$count'), ), ); }}//-----class Counter extends StatelessWidget { final int count; final VoidCallback voidCallback; Counter(this.count,this.voidCallback); @override Widget build(BuildContext context) { return Center( child: ActionChip( label: Text('$count'), onPressed: voidCallback, ), ); }} 上面的代码中，StateManagerDemo有两个子部件Counter0和Counter。当我们点击按钮的时候，_count的值++，然后传递给子部件。 Counter0是直接接受父部件传过来的参数。 Counter不仅接收父部件传过来的参数，还有一个回调。这样点击它的时候，会执行父部件中的回调方法，也能改变自身的显示。 InheritedWidget上面的情况是只有一层，Counter小部件中使用了父部件的count这个变量，假如Counter没有用到这个变量而是它的子类用到了这个变量，我们还要一层一层的传下去吗，这有点麻烦啊，这时候可以使用InheritedWidget这个类来管理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';//使用InheritedWidget来管理状态，class ContentProvider extends InheritedWidget { final int count; final VoidCallback countCallBack; final Widget child; const ContentProvider({ this. count, this. countCallBack, this. child, }): assert(child != null), super(child: child); static ContentProvider of(BuildContext context) { return context.inheritFromWidgetOfExactType( ContentProvider) as ContentProvider; } //是否通知继承该小部件的小部件更新 @override bool updateShouldNotify(ContentProvider old) { return true; }}class StateManagerDemo extends StatefulWidget { @override _StateManagerDemoState createState() =&gt; _StateManagerDemoState();}class _StateManagerDemoState extends State&lt;StateManagerDemo&gt; { int _count = 0; void countCallBack(){ setState(() { _count++; }); debugPrint('$_count'); } @override Widget build(BuildContext context) { //ContentProvider放在最外层，指定参数count和callback return ContentProvider( count: _count, countCallBack: countCallBack, child: Scaffold( appBar: AppBar( title: Text('StateManagerDemo'), elevation: 0.0, ), body: Counter1(), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: countCallBack, ), ), ); }}class Counter1 extends StatelessWidget { @override Widget build(BuildContext context) { //直接使用ContentProvider中的参数 final int count = ContentProvider.of(context).count; final VoidCallback voidCallback = ContentProvider.of(context).countCallBack; return Center( child: ActionChip( label: Text('$count'), onPressed: voidCallback, ), ); }} 首先定义一个数据提供者ContentProvider继承InheritedWidget，里面定义我们需要的count和回调。提供一个of方法让外界可以拿到它的实例，方便拿到方法。 然后将这个ContentProvider放在主布局的最外层，并传入需要的参数count和callBack。这样它的子部件中就都能访问到这个参数了。 最后在子部件Counter1中直接使用ContentProvider中的参数。 ScopedModel还可以使用ScopedModel来完成状态管理 这是一个第三方的库，该库最初是从Fuchsia代码库中提取的，使用时需要先导入包，在pubspec.yaml文件中添加依赖12dependencies: scoped_model: 1.0.1 https://pub.dev/packages?q=scoped_model 这里可以看到最新版本。使用这个库的时候我们在StatelessWidget中也可以改变UI 该库主要分为三个部分 Model class 扩展此类以创建自己的模型，例如SearchModel或UserModel。我们可以监听数据的变化！ ScopedModel 小部件 把Model包装到ScopedModel中，它内部的所有部件都能拿到model中的数据 ScopedModelDescendant 只要Model发生改变 它就会改变 比如用ScopedModel实现前面的功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import 'package:flutter/material.dart';import 'package:scoped_model/scoped_model.dart';class CountModel extends Model{ int _count = 0; int get count =&gt;_count; void countIncrease(){ _count ++; //通知改变 notifyListeners(); }}class StateModelDemo extends StatelessWidget { @override Widget build(BuildContext context) { return ScopedModel&lt;CountModel&gt;( model: CountModel() , child: Scaffold( appBar: AppBar( title: Text('StateModelDemo'), ), body: Counter2(), floatingActionButton: ScopedModelDescendant&lt;CountModel&gt;( rebuildOnChange: false, builder: (context, child, model) =&gt; FloatingActionButton( child: Icon(Icons.add), onPressed: (){ model.countIncrease(); }, ), ), ), ); }}class Counter2 extends StatelessWidget { @override Widget build(BuildContext context) { return ScopedModelDescendant&lt;CountModel&gt;( builder: (context, child, model) =&gt; Center( child: ActionChip( label: Text('${model.count}'), onPressed: (){ model.countIncrease(); }, ), ), ); }} MobxMobx在前端中用的多，且很好用，所以Flutter也引入了，对于我们Android开发者来说跟学前面的成本都一样哈哈。 查看版本 https://pub.dev/packages?q=Mobx github https://github.com/mobxjs/mobx.dart/tree/master/mobx_codegen 首先需要去pubspec.yaml文件中引入依赖 123456dependencies: mobx: ^0.3.8 flutter_mobx: ^0.3.3dev_dependencies: mobx_codegen: ^0.3.9 build_runner: ^1.7.0 然后开始使用mobx完成之前的功能 首先创建一个store类123456789101112131415import 'package:mobx/mobx.dart';//包含生成的文件part 'state_manager_demo.g.dart';class Counter = _Counter3 with _$Counter;abstract class _Counter3 with Store { @observable int value = 0; @action void increment() { value++; }} 创建完成之后，我们会发现part后面的内容和_$Counter都会报错。说是找不到，需要我们生成。来到AndroidStudio的terminal窗口执行下面命令来生成文件1flutter packages pub run build_runner build 这时候就可以看到我们自己的文件state_manager_demo.dart文件旁边生成了一个新文件state_manager_demo.g.dart，而且不在报错了。 如果想要修改后.g.dart文件也能自动修改执行1pub run build_runner watch 下面去界面中使用它12345678910111213141516171819202122232425262728293031323334class MobxDemo extends StatefulWidget { @override _MobxDemoState createState() =&gt; _MobxDemoState();}class _MobxDemoState extends State&lt;MobxDemo&gt; { final Counter counter = Counter(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('StateModelDemo'), ), body: Center( child: Observer( builder: (_)=&gt;ActionChip( label: Text('${counter.value}'), onPressed: (){ counter.increment(); }, ), ), ), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed:(){ counter.increment(); }, ), ); }} 很简单继承StatefulWidget，需要监听的小部件使用Observer包裹起来。然后创建一个成员变量final Counter counter = Counter();内部就可以直接使用Counter中的变量和方法了。运行效果跟前面的一样。 综合来看这几种状态管理的方式 ，我感觉Mobx是最好用的一个。","link":"/2019/09/22/flutter/Flutter基础-状态管理/"},{"title":"Andorid加载大图，双击放大，手势缩放","text":"Andorid加载大图，双击放大，手势缩放 Android开发中，有时候会有加载巨图的需求，如何加载一个大图而不产生OOM呢，使用系统提供的BitmapRegionDecoder这个类可以很轻松的完成。 效果图： BitmapRegionDecoder：区域解码器，可以用来解码一个矩形区域的图像，有了这个我们就可以自定义一块矩形的区域，然后根据手势来移动矩形区域的位置就能慢慢看到整张图片了。 OK 核心原理就是这么简单，不过做起来还是有一些细节处理，下面就一步一步的完成一个加载大图，支持拖动查看，双击放大，手势缩放的的自定义View。 第一步初始化变量12345678910private void init(){ mOptions = new BitmapFactory.Options(); //滑动器 mScroller = new Scroller(getContext()); //所放器 mMatrix = new Matrix(); //手势识别 mGestureDetector = new GestureDetector(getContext(),this); mScaleGestureDetector = new ScaleGestureDetector(getContext(),this); } BitmapFactory.Options我们很熟悉，用来配置Bitmap相关的参数，比如获取Bitmap的宽高，内存复用等参数。 GestureDetector用来识别双击事件，ScaleGestureDetector用来监听手指的缩放事件，都是系统提供的类，比较方便使用。 第二步设置需要加载的图片123456789101112131415public void setImage(InputStream is){ mOptions.inJustDecodeBounds = true; BitmapFactory.decodeStream(is,null,mOptions); mImageWidth = mOptions.outWidth; mImageHeight = mOptions.outHeight; mOptions.inPreferredConfig = Bitmap.Config.RGB_565; mOptions.inJustDecodeBounds = false; try { //区域解码器 mRegionDecoder = BitmapRegionDecoder.newInstance(is,false); } catch (IOException e) { e.printStackTrace(); } requestLayout();} 设置需要要加载的图片，无论图片放到哪里都可以拿到图片的一个输入流，所以参数使用输入流，通过BitmapFactory.Options拿到图片的真实宽高。 inPreferredConfig这个参数默认是Bitmap.Config.ARGB_8888，这里将它改成Bitmap.Config.RGB_565，去掉透明通道，可以减少一半的内存使用。最后初始化区域解码器BitmapRegionDecoder。 ARGB_8888就是由4个8位组成即32位，RGB_565就是R为5位，G为6位，B为5位共16位 第三步获取View的宽高，计算缩放值123456789101112@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); mViewWidth = w; mViewHeight = h; mRect.top = 0; mRect.left = 0; mRect.right = (int) mViewWidth; mRect.bottom = (int) mViewHeight; mScale = mViewWidth/mImageWidth; mCurrentScale = mScale;} onSizeChanged方法在布局期间，当此视图的大小发生更改时，将调用此方法，第一次在onMeasure之后调用，可以方便的拿到View的宽高。 然后给我们自定义的矩形mRect的上下左右的边界赋值。一般情况下我们使用这个自定义的View显示大图，都是占满这个View，所以这里矩形初始大小就让它跟View一样大。 mScale用来记录原始的所方比，mCurrentScale用来记录当前的所方比，因为有双击放大和手势缩放，mCurrentScale随着手势变化。 第四步绘制123456789101112@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); if(mRegionDecoder == null){ return; } //复用内存 mOptions.inBitmap = mBitmap; mBitmap = mRegionDecoder.decodeRegion(mRect,mOptions); mMatrix.setScale(mCurrentScale,mCurrentScale); canvas.drawBitmap(mBitmap,mMatrix,null);} 绘制也很简单，通过区域解码器解码一个矩形的区域，返回一个Bitmap对象，然后通过canvas绘制Bitmap。需要注意mOptions.inBitmap = mBitmap;这个配置可以服用内存，保证内存的使用一直只是矩形的这块区域。 到这里运行就能绘制出一部分图片了，想要看全部的图片，需要手指拖动来看，这就需要处理各种事件了。 第五步分发事件1234567@Overridepublic boolean onTouchEvent(MotionEvent event) { mGestureDetector.onTouchEvent(event); mScaleGestureDetector.onTouchEvent(event); return true;} onTouchEvent中很简单，事件都交给两个手势检测器自己去处理。 第六步处理GestureDetector中的事件12345678@Overridepublic boolean onDown(MotionEvent e) { //如果正在滑动，先停止 if(!mScroller.isFinished()){ mScroller.forceFinished(true); } return true;} 当手指按下的时候，如果图片正在飞速滑动，那么停止123456789101112131415161718192021222324@Overridepublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { //滑动的时候，改变mRect显示区域的位置 mRect.offset((int)distanceX,(int)distanceY); //处理上下左右的边界 if(mRect.left&lt;0){ mRect.left = 0; mRect.right = (int) (mViewWidth/mCurrentScale); } if(mRect.right&gt;mImageWidth){ mRect.right = (int) mImageWidth; mRect.left = (int) (mImageWidth-mViewWidth/mCurrentScale); } if(mRect.top&lt;0){ mRect.top = 0; mRect.bottom = (int) (mViewHeight/mCurrentScale); } if(mRect.bottom&gt;mImageHeight){ mRect.bottom = (int) mImageHeight; mRect.top = (int) (mImageHeight-mViewHeight/mCurrentScale); } invalidate(); return false;} onScroll中处理滑，根据手指移动的参数，来移动矩形绘制区域，这里需要处理各个边界点，比如左边最小就为0，右边最大为图片的宽度，不能超出边界否则就报错了。 12345678910111213141516171819202122 @Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { mScroller.fling(mRect.left,mRect.top,-(int)velocityX,-(int)velocityY,0,(int)mImageWidth ,0,(int)mImageHeight); return false;}@Overridepublic void computeScroll() { super.computeScroll(); if(!mScroller.isFinished()&amp;&amp;mScroller.computeScrollOffset()){ if(mRect.top+mViewHeight/mCurrentScale&lt;mImageHeight){ mRect.top = mScroller.getCurrY(); mRect.bottom = (int) (mRect.top + mViewHeight/mCurrentScale); } if(mRect.bottom&gt;mImageHeight) { mRect.top = (int) (mImageHeight - mViewHeight/mCurrentScale); mRect.bottom = (int) mImageHeight; } invalidate(); }} 在onFling方法中调用滑动器Scroller的fling方法来处理手指离开之后惯性滑动。惯性移动的距离在View的computeScroll()方法中计算，也需要注意边界问题，不要滑出边界。 第七步处理双击事件12345678910111213141516171819202122232425262728293031@Overridepublic boolean onDoubleTap(MotionEvent e) { //处理双击事件 if(mCurrentScale&gt;mScale){ mCurrentScale = mScale; }else { mCurrentScale = mScale*mMultiple; } mRect.right = mRect.left+(int)(mViewWidth/mCurrentScale); mRect.bottom = mRect.top+(int)(mViewHeight/mCurrentScale); //处理边界 if(mRect.left&lt;0){ mRect.left = 0; mRect.right = (int) (mViewWidth/mCurrentScale); } if(mRect.right&gt;mImageWidth){ mRect.right = (int) mImageWidth; mRect.left = (int) (mImageWidth-mViewWidth/mCurrentScale); } if(mRect.top&lt;0){ mRect.top = 0; mRect.bottom = (int) (mViewHeight/mCurrentScale); } if(mRect.bottom&gt;mImageHeight){ mRect.bottom = (int) mImageHeight; mRect.top = (int) (mImageHeight-mViewHeight/mCurrentScale); } invalidate(); return true;} mMultiple为双击之后放大几倍，这里设置3倍。第一次双击放大3倍，第二次双击返回原状。缩放完成之后，需要根据当前的缩放比重新设置绘制区域的边界。最后也需要重新定位一下边界，因为如果使用两个手指放大之后，这时候双击返回原状，如果不处理边界，位置会出错。处理边界的代码可以抽取出来。 第八步处理手指缩放事件1234567891011121314151617181920212223 @Override public boolean onScale(ScaleGestureDetector detector) { //处理手指缩放事件 //获取与上次事件相比，得到的比例因子 float scaleFactor = detector.getScaleFactor();// mCurrentScale+=scaleFactor-1; mCurrentScale*=scaleFactor; if(mCurrentScale&gt;mScale*mMultiple){ mCurrentScale = mScale*mMultiple; }else if(mCurrentScale&lt;=mScale){ mCurrentScale = mScale; } mRect.right = mRect.left+(int)(mViewWidth/mCurrentScale); mRect.bottom = mRect.top+(int)(mViewHeight/mCurrentScale); invalidate(); return true; } @Override public boolean onScaleBegin(ScaleGestureDetector detector) { //当 &gt;= 2 个手指碰触屏幕时调用，若返回 false 则忽略改事件调用 return true; } onScaleBegin方法需要返回true，否则无法检测到手势缩放。onScale方法中获取缩放因子，这个缩放因子是跟上次事件相比的出来的。所以这里使用*=，完成之后也需要重新设置绘制区域mRect的边界。 到这里各种功能就完成啦，点击获取源码","link":"/2019/12/20/technology/Andorid加载大图，双击放大，手势缩放/"},{"title":"Android Jetpack之ViewModel","text":"Android Jetpack之ViewModel ViewModel概念ViewModel是用来保存应用UI数据的类，会在配置变更后继续存在（比如旋转屏幕），我们知道当手机旋转的时候，Activity会被销毁重建，里面的数据都会丢失，或导致界面崩溃，以前我们解决这个问题一般重写onSaveInstanceState方法来保存一些关键数据，在onCreate或者onRestoreInstanceState方法中恢复数据，但此方法仅适用于可以序列化然后反序列化的少量数据，而不适用于潜在的大量数据 使用了ViewModel就不用这么麻烦了，在旋转屏幕的时候它不会被销毁,而且ViewMode中也可以保存相对大一点的数据。 另外遵守单一职责的原则，Activity应该只负责显示视图，数据的请求操作部分交给别的管理类去做ViewModel就可以完成这个任务 当然ViewModel并不能完全替代onSaveInstanceState，当进程被关闭的时候，ViewModel会被销毁，而onSaveInstanceState并会。 ViewModel简单使用比如我们一个请求接口的示例 123456789101112131415161718192021222324public class NameViewModel1 extends ViewModel { private MutableLiveData&lt;String&gt; currentName; public MutableLiveData&lt;String&gt; getCurrentName() { if (currentName == null) { currentName = new MutableLiveData&lt;String&gt;(); loadData(); } return currentName; } private void loadData() { OkGo.&lt;String&gt;get(\"http://gank.io/api/xiandu/categories\") .execute(new StringCallback() { @Override public void onSuccess(Response&lt;String&gt; response) { Gson gson = new Gson(); Catefories catefories = gson.fromJson(response.body(), Catefories.class); currentName.postValue(catefories.getResults().get(0).getName()); } }); }} 在ViewModel中请求接口，将返回值赋值给MutableLiveData，然后在Activity中绑定这个LiveData即可，如下12345678910111213141516171819public class NameActivity extends AppCompatActivity { private NameViewModel1 mViewModel; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_name); final TextView textView = findViewById(R.id.tv_name); mViewModel = ViewModelProviders.of(this).get(NameViewModel1.class); mViewModel.getCurrentName().observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { textView.setText(s); } }); }} 这样当ViewModel请求完数据之后，Activity中的TextView就会自动被赋值了。当Activity结束后，系统框架层会自动调用ViewModel的onCleared()方法来清理资源。 注意永远不要把Activity，View，Fragment的引用传入ViewModel中。比如前面我们知道当旋转屏幕的时候ctivity会被销毁然后重建，这时候ViewModel没被销毁，但是它还持有者以前被销毁的Activity的引用，这就会造成内存泄露。 如果 ViewModel需要 Application上下文，可以使用ViewModel的子类AndroidViewModel，它里面会有Application的上下文对象 ViewModel的生命周期ViewModel对象的作用域是在获取ViewModel时传递给ViewModelProvider的生命周期。它会一直存在，直到Lifecycle告诉它该关闭了，比如activity finish了，或者fragment detached了。 通常情况下ViewModel在系统第一次创建一个activity的时候，在其onCreate()方法中创建，在activity的整个活动周期中可能会调用onCreate()方法多次，比如旋转屏幕，ViewModel会一直存在，直到这个activity完全退出和销毁。 在不同的fragment之间共享数据activity中两个fragment之前互相通信也是比较常见的，使用ViewModel可以很好的共享数据 123456789101112131415161718192021222324252627282930313233public class SharedViewModel extends ViewModel { private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) { selected.setValue(item); } public LiveData&lt;Item&gt; getSelected() { return selected; }}public class MasterFragment extends Fragment { private SharedViewModel model; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; { model.select(item); }); }}public class DetailFragment extends Fragment { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); model.getSelected().observe(this, { item -&gt; // Update the UI. }); }} 可以看到，两个Fragment都是把他们所依赖的activity传入ViewModelProvider中，那么他们所获取到的ViewModel也是同一个。此ViewModel的生命周期也限制在这个activity的范围内。 这样做的好处： activity不用做任何事情，也不需要了解两个fragment之间的沟通 两个fragment之间除了它们共享的ViewModel，别的都不需要彼此关心，即使有一个fragment崩溃了，另一个依然会正常工作 每个fragment都有自己的生命周期，互相不影响。 ViewModel可以结合LiveData和Room,可以让UI和数据中数据同步，这可以替换以前的CursorLoader。 OK，上面大部分都是官方文档的翻译，看完就知道ViewModel的简单使用了，下面来看看其源码看看内部实现 前面我们知道ViweModel的初始化方法是这样：ViewModelProviders.of(this).get(NameViewModel1.class)，下面从of开始。 1234567891011public static ViewModelProvider of(@NonNull FragmentActivity activity) { return of(activity, null); } public static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) { Application application = checkApplication(activity); if (factory == null) { factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); } return new ViewModelProvider(activity.getViewModelStore(), factory); } fragment也有类似的上面两个方法，这里是从activity中调用的。 调用of方法，传入当前的activity或者fragment， 然后调用了两个参数的重载方法，传入的第二个参数Factory为null 因为为null,所以通过activity获取到当前的Application对象，然后创建出当前的工厂（factory） 最后创建一个ViewModelProvider对象，两个参数，当前activity相关联的ViewModelStore和factory。 这俩参数是干啥的，一个一个来，先看第一个参数ViewModelStore 123456789101112131415161718public ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(\"Your activity is not yet attached to the \" + \"Application instance. You can't request ViewModel before onCreate call.\"); } if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } return mViewModelStore; } 看看Activity中的NonConfigurationInstances对象是不是空，如果不是给mViewModelStore赋值，如果mViewModelStore还未null，创建一个ViewModelStore 1234567891011121314151617181920212223242526272829public class ViewModelStore { private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) { oldViewModel.onCleared(); } } final ViewModel get(String key) { return mMap.get(key); } Set&lt;String&gt; keys() { return new HashSet&lt;&gt;(mMap.keySet()); } /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); }} ViewModelStore里面有个HashMap对象用来存储ViewModel。 在看这个工厂AndroidViewModelFactory 12345678910111213141516171819202122232425262728293031323334353637public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory { private static AndroidViewModelFactory sInstance; @NonNull public static AndroidViewModelFactory getInstance(@NonNull Application application) { if (sInstance == null) { sInstance = new AndroidViewModelFactory(application); } return sInstance; } private Application mApplication; public AndroidViewModelFactory(@NonNull Application application) { mApplication = application; } @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) { if (AndroidViewModel.class.isAssignableFrom(modelClass)) { //noinspection TryWithIdenticalCatches try { return modelClass.getConstructor(Application.class).newInstance(mApplication); } catch (NoSuchMethodException e) { throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); } catch (IllegalAccessException e) { throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); } catch (InstantiationException e) { throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); } catch (InvocationTargetException e) { throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); } } return super.create(modelClass); } } AndroidViewModelFactory，是ViewModelProvider的静态内部类，getInstance获取它的单例。create中，可以看到，通过反射创建出一个Class对象。其实就是我们自己写的ViewModel类 OK到这里of方法就看完了，其实就是创建了一个ViewModelProvider对象，创建这个对象需要传入一个保存ViewModel的ViewModelStore类和一个工厂类，这个工厂有个create方法可以通过反射创建相应的Class对象。 下面来看get方法 1234567public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) { String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\"); } return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);} 找到全类名，然后拼接上一个默认的key，之后调用get的两个参数重载方法123456789101112131415161718192021public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) { //noinspection unchecked return (T) viewModel; } else { //noinspection StatementWithEmptyBody if (viewModel != null) { // TODO: log a warning. } } if (mFactory instanceof KeyedFactory) { viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); } else { viewModel = (mFactory).create(modelClass); } mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;} 通过key到mViewModelStore中寻找ViewModel，如果找到了并且是ViewModel类型的，就返回，如果没找到，调用工厂的create方法创建一个，并保存到ViewModelStore中，最后返回这个viewModel OK到这里ViewModel的源码就看完啦，总结一下ViewModel是通过ViewModelprovider中的AndroidViewModelFactory这个工厂创建的，创建完成后完成后保存在ViewModelStore中。 前面看文档我们知道，当手机屏幕旋转的时候，activity重建，但是ViewModel中的数据不丢失，这是怎么实现的呢？ 搜了一些博客都是是说创建了一个HolderFragment ，创建的时候调用了setRetainInstance(true)方法，这个方法可以保证activity销毁的时候这个HolderFragment不会重建，从而保证数据不会丢失。 应该是版本不同的原因，我现在看的是androidx中的源码，并没有发现这个HolderFragment，那它是怎么保证数据不丢失的呢 现在回到getViewModelStore()方法中，看到在那ViewModelStore的实例的时候，先去NonConfigurationInstances中那，拿不到才创建。12345static final class NonConfigurationInstances { Object custom; ViewModelStore viewModelStore; FragmentManagerNonConfig fragments; } 可以看到它是Activity的静态内部类，在activity创建时执行attach方法的时候被赋值，那么它的生命周期就跟这个Activity就没有关系了，Activity销毁了它也可能存在当Activity重新创建的时候,在FragmentActivity的onCreate中可以看到下面123456789101112protected void onCreate(@Nullable Bundle savedInstanceState) { mFragments.attachHost(null /*parent*/); super.onCreate(savedInstanceState); NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null &amp;&amp; nc.viewModelStore != null &amp;&amp; mViewModelStore == null) { mViewModelStore = nc.viewModelStore; } ......} 如果NonConfigurationInstances不为null，并且它中的viewModelStore也不为null,activity中的mViewModelStore为null的时候，会把NonConfigurationInstances中的viewModelStore的值赋值给mViewModelStore，所以数据也就没丢失了。","link":"/2019/04/20/technology/Android-Jetpack之ViewModel/"},{"title":"Android屏幕适配","text":"Android屏幕适配这个东西，真是每个Andorid开发者从入行开始就比较关注也比较头疼的问题 从多套dimens到百分比布局再到鸿神的AutoLayout还有smallestWidth最小宽度限定符适配，还有的公司重写了系统常用的布局容器，然后在onMeasure中进行等比例的缩放。这些都能达到一些挺好的效果，不过也有不少bug存在，适配起来酣畅淋漓的感觉。 后来有人想到了修改系统Density用起来比较爽，这篇文章非常不错，可惜知道的人比较少，直到今日头条在其公众号发表了一篇适配的文章一种极低成本的Android屏幕适配方式，核心思想跟上面是一样的，这种方式才迅速让更多的开发者知道，于是不少优秀的的框架出现AndroidAutoSize和AndroidUtilCode 本篇文章就把上面的原理在熟悉一下，记个笔记。如需源码请去上面开源库中寻找。 无论我们使用什么单位适配，除了px剩下的单位都会根据一定的规则进行转换，布局文件转换位置在android.util下的TypedValue#applyDimension。12345678910111213141516171819public static float applyDimension(int unit, float value, DisplayMetrics metrics) { switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); } return 0; } Bitmap的转换在 BitmapFactory#decodeResourceStream12345678public static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, Options opts) { ... if (opts.inTargetDensity == 0 &amp;&amp; res != null) { opts.inTargetDensity = res.getDisplayMetrics().densityDpi; } ... } 上面的代码可以看到，根据不同单位转换的时候，都用到了DisplayMetrics这个类，通过metrics.density，metrics.scaledDensity等值来转化。density就是屏幕的密度，scaledDensity是字体的缩放因子，正常情况下跟density值是相等的，当改变系统字体的大小的时候这个值会变。 如果我们是用dp，上面代码中的value就是我们的dp值，可以看到px=dp*density 所以，适配的时候，保持dp值不变，我们可以修改系统的density值让它跟我们的设计图中的density值相等就好了。 通常情况下，我们适配宽或者高中的一个就行了，因为每个设备的宽高比是不一样的，有的是16:9，有的是4:3等等，所以完全显示一直是不可能的。 下面使用宽度适配一下12345678910111213141516171819202122232425262728public class ScreenAdapter { /** * 参考设计图的宽 单位dp * 比如设计图是1920*1080 按360dp为基准 * 相同分辨率的手机，屏幕的尺寸不同也会导致最后的dp值不同。 * 比如1920*1080分辨率，屏幕尺寸为5，最后是392.7dp */ private static float WIDTH = 320; public static void adapter(Activity activity){ //系统的DisplayMetrics final DisplayMetrics systemDM = Resources.getSystem().getDisplayMetrics(); //根据设计图的WIDTH计算当前的density, scaleDensity, densityDpi float targetDensity = systemDM.widthPixels/WIDTH; float targetScaleDensity = targetDensity *(systemDM.scaledDensity/systemDM.density); //px = density * dp; density = dpi / 160; px = dp * (dpi / 160); int targetDensityDpi = (int) (targetDensity*160); //替换Activity的density, scaleDensity, densityDpi //Activity的DisplayMetrics final DisplayMetrics activityDM = activity.getResources().getDisplayMetrics(); activityDM.density = targetDensity; activityDM.scaledDensity = targetScaleDensity; activityDM.densityDpi = targetDensityDpi; }} 由于 API 26 及以上的 Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics() 是不同的引用，所以在 API 26 及以上适配是没有影响的，但在API26以下Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics()是相同的引用，导致适配有问题，而Resources#getSystem()#getDisplayMetrics() 没有这个问题所以使用它了。 如果使用Application#getResources()#getDisplayMetrics()，在手机的设置中改变字体的大小的时候，APP中无法改变，需要注册监听registerComponentCallbacks12345678910111213141516float appScaleDensity; //添加字体变化监听回调 application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { //字体发生更改，重新对scaleDensity进行赋值 if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0){ appScaleDensity = application.getResources().getDisplayMetrics().scaledDensity; } } @Override public void onLowMemory() { } }); 不过如果使用Resources#getSystem()#getDisplayMetrics()的话就没这个问题了，不需要注册上面的监听也能跟随系统改变。最后在Activity的setContentViw()方法之前调用上面类中的adapter方法就可以愉快的适配了。 缺点： 修改了系统的density值之后，所有的地方都适配了，比如第三方库中的dp值，系统库中的dp值，这就会出现一个问题,如果第三方库和系统库中的UI设计的尺寸跟我们的基准尺寸不一样，那适配肯定就会出问题了，比如AlertDialog，Toast的尺寸会变形。可以在调用这些控件的时候先取消适配。1234567public static void cancelAdapter(final Activity activity) { final DisplayMetrics systemDm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics activityDm = activity.getResources().getDisplayMetrics(); activityDm.density = systemDm.density; activityDm.scaledDensity = systemDm.scaledDensity; activityDm.densityDpi = systemDm.densityDpi;} 有时候系统会重置density的值，比如WebView初始化的时候会重置DisplayMetrics#density的值导致适配失效。可以重写VebView的setOverScrollMode方法12345@Overridepublic void setOverScrollMode(int mode) { super.setOverScrollMode(mode); //在这重新执行adapter的方法 } 还有一些其他的问题，可以去这两个框架的issue中查看。 从最开始的代码中可以看到除了dp,sp之外，还有一些别的单位，pt,in,mm,Android源代码和第三方库中一般都是使用的dp,sp来做单位，所以我们可以更改pt这个单位，pt，它表示一个点，是屏幕的物理尺寸，其大小为 1 英寸的 1 / 72，也就是 72pt 等于 1 英寸 123456//designWidth是我们设计图的px尺寸public static void adaptWidth(Activity activity, int designWidth) { DisplayMetrics dm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics activityDM = activity.getResources().getDisplayMetrics(); activityDM.xdpi= dm.xdpi = (dm.widthPixels * 72f) / designWidth; } 修改DisplayMetrics中的xdpi的值，在布局文件中使用pt做单位，这样我们的修改就不会对系统和第三方的控件的大小改变了。 当然是用这种偏门的单位，对代码的入侵性就有点大，如果以后有了更好的适配方式，更改起来比较麻烦，不过也有处理的方式 从最开始那个代码中我们可以看到，如果以pt为单位，返回的是return value * metrics.xdpi * (1.0f/72);，以dp为单位返回的是return value * metrics.density; 放到一块对比一下12return value * metrics.xdpi * (1.0f/72);return value * metrics.density; 从上面看，如果我们把metrics.xdpi * (1.0f/72)变成metrics.density，那么我们在布局文件中使用dp和pt的效果就一样了。 所以，假如真有更好的方式的时候，可以通过一个取消pt适配的方式，把上面给改了，到时候dp和pt效果一样，我们就不用去布局文件中一个一个的更改了。取消方式12345public static void cancelPtAdapter(final Activity activity) { final DisplayMetrics dm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics activityDm = activity.getResources().getDisplayMetrics(); activityDm.xdpi = dm.xdpi = dm.density * 72; }","link":"/2019/04/05/technology/Android屏幕适配/"},{"title":"JNI基础知识","text":"JNI(Java Native Interface)，它是java中的一套接口，用来跟c和c++通信。 JNI中的数据类型java中的数据类型和c的数据类型之间的映射关系：java-&gt;JNI-&gt;c/c++ 基本数据类型： java JNI boolean jboolean byte jbyte char jchar short jshort int jlong long jchar float jfloat double jdouble void void 引用类型： java JNI String jstring object jobject class jclass byte[] jByteArray object[] jobjectArray JNI开发流程的步骤 编写native方法 javah命令，生成.h头文件 复制.h头文件到CPP工程中 复制jni.h和jni_md.h文件到CPP工程中 创建jni目录 添加本地支持add native support 实现.h头文件中声明的函数 生成动态库Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib 令执行Java程序，加载动态库 java调用C，例如下面返回一个字符串1234567891011121314public class JniTest { //写一个native方法 public native static String getStringFromC(); public static void main(String[] args) { String text = getStringFromC(); System.out.println(text); } //加载动态库 static{ System.loadLibrary(\"jni_study\"); }} C中123456789//函数实现//Java_包名_类名_方法名JNIEXPORT jstring JNICALL Java_com_chs_jni_JniTest_getStringFromC(JNIEnv *env, jclass jcls){ //JNIEnv 结构体指针 env是二级指针 //代表Java运行环境，调用Java中的代码 //将C的字符串转为一个java字符串 return (*env)-&gt;NewStringUTF(env,\"C String\");} C调用java中的方法访问属性，访问静态属性，访问方法，访问静态方法 先在java中定义相关的属性和方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class JniTest { //加载动态库 static{ System.loadLibrary(\"jni_test\"); } public String name = \"chs\"; public static int count = 9; public native static String getStringFromC(); public native String getString2FromC(int i); //访问属性，返回修改之后的属性内容 public native String accessField(); //c调用java中的静态变量 public native void accessStaticField(); //c调用java中的方法 public native void accessMethod(); //c调用java中的静态方法 public native void accessStaticMethod(); //c调用java中的构造方法 public native void accessConstructor(); //c调用java中的父类的方法 public native void accessNonvirtualObjectMethod(); //中文 public native String chuneseChars(String in) //传入数组 public native void giveArray(int[] array); //获取数组 public native int[] getArray(int len); //获取本地引用 public native void loaclRef(); public static void main(String[] args) { String text = getStringFromC(); System.out.println(text); JniTest t = new JniTest(); text = t.getString2FromC(6); System.out.println(text); t.accessField(); t.accessStaticField(); t.accessMethod(); t.accessStaticMethod(); int[] array = {9,100,10,37,5,10}; //排序 t.giveArray(array); for (int i : array) { System.out.println(i); } int[] array2 = t.getArray(10); System.out.println(\"------------\"); for (int i : array2) { System.out.println(i); } //全局引用 t.createGlobalRef(); System.out.println(t.getGlobalRef()); //用完之后释放 t.deleteGlobalRef(); System.out.println(\"释放完了...\"); //System.out.println(t.getGlobalRef()); //Java中捕捉C中的异常Exception是无法捕捉到的 //得用Throwable捕获 try { t.exeception(); } catch (Exception e) { System.out.println(\"发生异常：\"+e.getMessage()); } System.out.println(\"--------异常发生之后-------\"); //C中手动抛出来的异常可以捕捉到 try { t.exeception(); } catch (Exception e) { //e.printStackTrace(); System.out.println(e.getMessage()); } //不断调用cached方法 for (int i = 0; i &lt; 100; i++) { t.cached(); } } //产生指定范围的随机数 public int genRandomInt(int max){ return new Random().nextInt(max); } //产生UUID字符串 public static String getUUID(){ return UUID.randomUUID().toString(); } 1.访问属性 这里会用到属性签名 数据类型 签名 boolean Z byte B char C short S int I long L float F double D void V object L开头，然后以/分割包的完整类型，后面再加;比如String的签名就是Ljava/long/String Array 以[开头，在加上数组元素类型的签名，比如int[],签名是[I，int[][]的签名是[[I，object[]的签名是[Ljava/lang/Object 1234567891011121314151617181920212223242526272829303132JNIEXPORT jstring JNICALL Java_com_chs_JniTest_accessField(JNIEnv *env, jobject jobj){ //jobj是t对象，JniTest.class jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jfieldID //属性名称，属性签名 jfieldID fid = (*env)-&gt;GetFieldID(env, cls, \"key\", \"Ljava/lang/String;\"); //jason &gt;&gt; super jason //获取key属性的值 //Get&lt;Type&gt;Field jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid); printf(\"jstr:%#x\\n\",&amp;jstr); //jstring -&gt; c字符串 //isCopy 是否复制（true代表赋值，false不复制） char *c_str = (*env)-&gt;GetStringUTFChars(env,jstr,JNI_FALSE); //拼接得到新的字符串 char text[20] = \"super \"; strcat(text,c_str); //c字符串 -&gt;jstring jstring new_jstr = (*env)-&gt;NewStringUTF(env, text); //修改key //Set&lt;Type&gt;Field (*env)-&gt;SetObjectField(env, jobj, fid, new_jstr); printf(\"new_jstr:%#x\\n\", &amp;new_jstr); return new_jstr;} 2.访问静态属性12345678910111213JNIEXPORT void JNICALL Java_com_chs_JniTest_accessStaticField(JNIEnv *env, jobject jobj){ //jclass jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jfieldID jfieldID fid = (*env)-&gt;GetStaticFieldID(env, cls, \"count\", \"I\"); //GetStatic&lt;Type&gt;Field jint count = (*env)-&gt;GetStaticIntField(env, cls, fid); count++; //修改 //SetStatic&lt;Type&gt;Field (*env)-&gt;SetStaticIntField(env,cls,fid,count);} 3.访问java方法 这里需要用到方法的签名，方法的签名的获取，可以通过javap命令，打开命令行，进入我们的java类所在的文件夹，执行javap命令 比如1javap -s -p com.chs.JniTest 执行上面的命令，就可以看到该类下面所有属性和方法的签名了。123456789JNIEXPORT void JNICALL Java_com_chs_JniTest_accessMethod(JNIEnv *env, jobject jobj){ //jclass jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jmethodID 最后一个参数是方法的签名 jmethodID mid = (*env)-&gt;GetMethodID(env, cls, \"genRandomInt\", \"(I)I\"); //Call&lt;Type&gt;Method jint random = (*env)-&gt;CallIntMethod(env, jobj, mid, 200); printf(\"random num:%ld\",random); 4.访问静态方法123456789101112131415161718192021JNIEXPORT void JNICALL Java_com_chs_JniTest_accessStaticMethod(JNIEnv *env, jobject jobj){ //jclass jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jmethodID jmethodID mid = (*env)-&gt;GetStaticMethodID(env, cls, \"getUUID\", \"()Ljava/lang/String;\"); //CallStatic&lt;Type&gt;Method jstring uuid = (*env)-&gt;CallStaticObjectMethod(env, cls, mid); //随机文件名称 uuid.txt //jstring -&gt; char* //第三个参数isCopy JNI_FALSE，代表java和c操作的是同一个字符串 char *uuid_str = (*env)-&gt;GetStringUTFChars(env, uuid, NULL); //拼接 char filename[100]; sprintf(filename, \"D://%s.txt\",uuid_str); FILE *fp = fopen(filename,\"w\"); fputs(\"i love jason\", fp); fclose(fp);} 5.访问构造方法 访问构造方式的时候需要传入一个”“参数 123456789101112131415161718//使用java.util.Date产生一个当前的时间戳JNIEXPORT jobject JNICALL Java_com_chs_JniTest_accessConstructor(JNIEnv *env, jobject jobj){ //找到要访问的class jclass cls = (*env)-&gt;FindClass(env, \"java/util/Date\"); //找到它的构造方法 jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, \"&lt;init&gt;\", \"()V\"); //实例化一个Date对象 jobject date_obj = (*env)-&gt;NewObject(env, cls, constructor_mid); //找到想要调用的方法 jmethodID mid = (*env)-&gt;GetMethodID(env, cls, \"getTime\", \"()J\"); //调用getTime方法 jlong time = (*env)-&gt;CallLongMethod(env, date_obj, mid); printf(\"\\ntime:%lld\\n\",time); return date_obj;} 6.调用父类的方法 Java中定义一个父类Human，和一个子类Man，父类中有个方法sayHai，子类重写该方法。 java中 1Human human = new Man(); C中1234567891011121314151617JNIEXPORT void JNICALL Java_com_chs_JniTest_accessNonvirtualMethod(JNIEnv *env, jobject jobj){ //拿到该对象 jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //找到属性的ID jfieldID fid = (*env)-&gt;GetFieldID(env, cls, \"human\", \"Lcom/chs/Human;\"); //获取man属性（对象 jobject human_obj = (*env)-&gt;GetObjectField(env, jobj, fid); //知道父类，注意：传父类的名称 jclass human_cls = (*env)-&gt;FindClass(env, \"com/chs/Human\"); //执行sayHi方法 jmethodID mid = (*env)-&gt;GetMethodID(env, human_cls, \"sayHi\", \"()V\"); //执行CallObjectMethod，还是会调用子类的方法 //(*env)-&gt;CallObjectMethod(env, human_obj, mid); //使用CallNonvirtualObjectMethod可以调用的父类的方法 (*env)-&gt;CallNonvirtualObjectMethod(env, human_obj, human_cls, mid);} 7.从C中返回中文乱码问题 C中字符串默认是UTF-16，想要返回到Java中不乱码，需要进行转码，C中转码非常麻烦，通过C调用Java中的String提供的类来进行转码就简单了很多。 123456789101112131415161718192021222324252627282930313233JNIEXPORT jstring JNICALL Java_com_chs_JniTest_chineseChars(JNIEnv *env, jobject jobj, jstring in){ //输出 //char *c_str = (*env)-&gt;GetStringUTFChars(env, in, NULL); //printf(\"%s\\n\",c_str); //c 转化成 jstring char *c_str = \"我是C中的文字\"; //char c_str[] = \"我是C中的文字\"; //jstring jstr = (*env)-&gt;NewStringUTF(env, c_str); //执行String(byte bytes[], String charsetName)构造方法需要的条件 //1.jmethodID //2.byte数组 //3.字符编码jstring //找到String类，并回去构造方法的ID jclass str_cls = (*env)-&gt;FindClass(env, \"java/lang/String\"); jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, str_cls, \"&lt;init&gt;\", \"([BLjava/lang/String;)V\"); //jbyte 转换成 char //jbyteArray -&gt; char[] jbyteArray bytes = (*env)-&gt;NewByteArray(env, strlen(c_str)); //byte数组赋值，C中的char跟jbyte类型是一样的 //0-&gt;strlen(c_str)，从头到尾 //对等于，从c_str这个字符数组，复制到bytes这个字符数组 (*env)-&gt;SetByteArrayRegion(env, bytes, 0, strlen(c_str), c_str); //字符编码jstring jstring charsetName = (*env)-&gt;NewStringUTF(env, \"GB2312\"); //调用构造函数，返回编码之后的jstring return (*env)-&gt;NewObject(env,str_cls,constructor_mid,bytes,charsetName);} 8.Java传数组到C中 传入一个数组并排序，操作完一定要同步回去12345678910111213141516171819202122//比较的方法int compare(int *a,int *b){ return (*a) - (*b);}//传入JNIEXPORT void JNICALL Java_com_chs_JniTest_giveArray(JNIEnv *env, jobject jobj, jintArray arr){ //jintArray -&gt; jint指针 -&gt; c int 数组 jint *elems = (*env)-&gt;GetIntArrayElements(env, arr, NULL); //printf(\"%#x,%#x\\n\", &amp;elems, &amp;arr); //数组的长度 int len = (*env)-&gt;GetArrayLength(env, arr); //排序 qsort(elems, len, sizeof(jint), compare); //同步 //0, Java数组进行更新，并且释放C/C++数组 //JNI_ABORT, Java数组不进行更新，但是释放C/C++数组 //JNI_COMMIT，Java数组进行更新，不释放C/C++数组（函数执行完，数组还是会释放） (*env)-&gt;ReleaseIntArrayElements(env, arr, elems, JNI_COMMIT);} 9.C返回数组到Java 操作完一定要同步回去 1234567891011121314JNIEXPORT jintArray JNICALL Java_com_chs_JniTest_getArray(JNIEnv *env, jobject jobj, jint len){ //创建一个指定大小的数组 jintArray jint_arr = (*env)-&gt;NewIntArray(env, len); //创建jint数组 jint *elems = (*env)-&gt;GetIntArrayElements(env, jint_arr, NULL); int i = 0; for (; i &lt; len; i++){ elems[i] = i; } //同步 (*env)-&gt;ReleaseIntArrayElements(env, jint_arr, elems, 0); return jint_arr;} 10.JNI中的引用 引用类型分为局部引用和全局引用 局部引用可以使用DeleteLocalRef手动释放对象，什么时候释放呢 当访问一个恨到的java对象，使用完成知乎，还要进行复杂的耗时操作 当创建了大量的局部引用，占用了太多的内存，这些局部引用只是暂时使用，跟后面的操作没有关联。 局部引用：123456789101112131415JNIEXPORT void JNICALL Java_com_chs_JniTest_localRef(JNIEnv *env, jobject jobj){ int i = 0; for (; i &lt; 5; i++){ //创建Date对象 jclass cls = (*env)-&gt;FindClass(env, \"java/util/Date\"); jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, \"&lt;init&gt;\", \"()V\"); jobject obj = (*env)-&gt;NewObject(env, cls, constructor_mid); //省略一些操作 //不在使用jobject对象了 //通知垃圾回收器回收这些对象 (*env)-&gt;DeleteLocalRef(env, obj); //省略一些操作... }} 全局引用 全局引用可以共享数据，可以跨多个线程，使用DeleteGlobalRef释放。 1234567891011121314151617jstring global_str;//创建全局引用JNIEXPORT void JNICALL Java_com_chs_JniTest_createGlobalRef(JNIEnv *env, jobject jobj){ jstring obj = (*env)-&gt;NewStringUTF(env, \"jni development is powerful!\"); global_str = (*env)-&gt;NewGlobalRef(env, obj);}//返回全局引用JNIEXPORT jstring JNICALL Java_com_chs_JniTest_getGlobalRef(JNIEnv *env, jobject jobj){ return global_str;}//释放全局引用JNIEXPORT void JNICALL Java_com_chs_JniTest_deleteGlobalRef(JNIEnv *env, jobject jobj){ (*env)-&gt;DeleteGlobalRef(env, global_str);} 弱全局引用 全局引用需要手动释放，弱全局引用，跟java中的弱引用差不多，当内存不足的时候系统会释放掉这部分内存。 创建：NewWeakGlobalRef,销毁：DeleteGlobalWeakRef 11.C中异常处理 C中发生错误抛出的异常，可以使用Throwable捕获，可以从C中把异常清理后才能继续执行后面的代码。C中使用ExceptionOccurred查看返回的异常是不是NULL。不过不是，可以清空异常，并做一些补救的措施。 C中通过手动通过ThrowNew抛出的异常，可以在java层try catch捕获到。 12345678910111213141516171819202122JNIEXPORT void JNICALL Java_com_chs_JniTest_exeception(JNIEnv *env, jobject jobj){ jclass cls = (*env)-&gt;GetObjectClass(env, jobj); jfieldID fid = (*env)-&gt;GetFieldID(env, cls, \"key2\", \"Ljava/lang/String;\"); //检测是否发生Java异常 jthrowable exception = (*env)-&gt;ExceptionOccurred(env); if (exception != NULL){ //让Java代码可以继续运行 //清空异常信息 (*env)-&gt;ExceptionClear(env); //补救措施 fid = (*env)-&gt;GetFieldID(env, cls, \"key\", \"Ljava/lang/String;\"); } //获取属性的值 jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid); char *str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); //对比属性值是否合法 if (_stricmp(str, \"super jason\") != 0){ //认为抛出异常，给Java层处理 jclass newExcCls = (*env)-&gt;FindClass(env, \"java/lang/IllegalArgumentException\"); (*env)-&gt;ThrowNew(env,newExcCls,\"key's value is invalid!\"); }} 12.缓存策略 如果从java中循环调用很多次下面的方法，我们让对象第一次拿到之后就缓存起来，以后再取的时候就去缓存中取，这时候可以使用局部静态变量来存储。 在实际的项目中，我们也可以在一个方法中一次初始化很多需要的全局的变量。 123456789101112131415161718JNIEXPORT void JNICALL Java_com_chs_JniTest_cached(JNIEnv *env, jobject jobj){ jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //获取jfieldID只获取一次 //局部静态变量 static jfieldID key_id = NULL; if (key_id == NULL){ key_id = (*env)-&gt;GetFieldID(env, cls, \"key\", \"Ljava/lang/String;\"); printf(\"--------GetFieldID-------\\n\"); }}//初始化全局变量，动态库加载完成之后，立刻缓存起来jfieldID key_fid;jmethodID random_mid;JNIEXPORT void JNICALL Java_chs_jni_JniTest_initIds(JNIEnv *env, jclass jcls){ key_fid = (*env)-&gt;GetFieldID(env, jcls, \"key\", \"Ljava/lang/String;\"); random_mid = (*env)-&gt;GetMethodID(env, jcls, \"genRandomInt\", \"(I)I\");}","link":"/2019/05/12/technology/JNI基础知识/"},{"title":"OpenGl入门","text":"OpenGl入门 什么是OpenGL Open Graphics Library，图形领域的工业标准，是一套跨平台的、专业的、图形变成软件接口。它用于二维、三维图像，是一个功能强大的调用方便的底层图形库。 OpenGL与硬件无关，可以在不同的平台比如Windows、Linux、Mac、Andorid、IOS之间进行移植，因此也得到了广泛的应用。 Android 中使用OpenGl ES GLSurfaceView，它继承自SurfaceView，它内嵌的sufface专门负责OpenGl渲染，管理Surface与EGL，允许自定义渲染器，让渲染器在独立的线程中运作，和UI线程分离，并且支持按需渲染(on-demand)和连续渲染(continuous)。 OpenGL是一个跨平台操作GUP的API，但是OpenGL需要本地视窗系统进行交互，这几需要一个中间层，EGL就是连接OpenGL ES和本地窗口的接口，引入EGL就是为了屏蔽不同平台上的区别。 CPU和GPU的区别 CPU是机器的大脑,中央处理器,用来发号施令 GPU的结构主要包括运算器(ALU)，控制单元(CU)，寄存器(Register)，高速缓存器(Cache)和他们之间通讯的数据，控制及状态的总线 计算单元主要执行算数运算，位移和转换 存储单元主要用来保存运算中产生的数据以及指令等 控制单元则对指令译码，发出要完成每条指令要执行的各个操作的控制信号。 CPU中控制器和缓存器比较多，GPU中计算单元比较多。GPU无法单独工作，必须由CPU进行控制调用才能工作，CPU可以单独作用。 Android中渲染步骤 UI对象–&gt;CPU处理为纹理–&gt;通过OpenGLES接口调用GPU –&gt;GPU对图像进行栅格化–&gt;硬件时钟–&gt;垂直同步–&gt;投射到屏幕 一维 点 顶点 二维 线 2个顶点 三维 面 3个顶点 在OpenGl的世界中中是又很多的3个顶点组成。 一个3D图片根据像素可以形成无数个顶点，顶点的连线叫做纹理（顶点着色器） 根据纹理形成一个一个像素（就像PS中对文字进行像素处理）（光栅化） 对像素进行着色（片元着色器） 上色之后交给GPU渲染（OpenGl渲染） 在使用OpenGl的时候，第二个和第四个是由系统完成的，我们需要手动写第一个和第三个，告诉系统有多少顶点和怎么着色 练习： 使用OpenGl绘制一个三角形 新建一个项目，Andorid系统中已经有OpenGl，不用导入第三方库，不过需要在AndroidManifest.xml中声明需要使用OpenGl1&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; OpenGl 使用套路 创建顶点数组 使用gl语言写顶点着色器和片元着色器 将java声明是顶点数组，颜色数组，传给gl语言中的变量 GPU开始渲染 自定义一个View继承自GLSurfaceView12345678910111213public class GLView extends GLSurfaceView { public GLView(Context context) { super(context); } public GLView(Context context, AttributeSet attrs) { super(context, attrs); setEGLContextClientVersion(2); setRenderer(new GLRander(this)); setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); }} 定义一个渲染器，定义一个三角形的类Triangle，绘制的方法交给它自己来做，因为还可能绘制别的图形。123456789101112131415161718192021222324252627public class GLRander implements GLSurfaceView.Renderer { protected View mView; Triangle mTriangle; public GLRander(View view) { mView = view; } @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) { GLES20.glClearColor(0, 0, 0, 0); mTriangle = new Triangle(); } @Override public void onSurfaceChanged(GL10 gl, int width, int height) { mTriangle.onSurfaceChanged(gl, width, height); } /** * 该方法不断被调用 */ @Override public void onDrawFrame(GL10 gl) { GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT|GLES20.GL_DEPTH_BUFFER_BIT); mTriangle.onDrawFrame(gl); }} 开始绘制。 顶点着色器用来确定需要绘制的图形的顶点，片元着色器用来给它上色。 顶点着色器和片元着色器都是使用着色器语言（GLSL）语言编写，编写的程序可以直接推送给GPU执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class Triangle { /** * 三个顶点 */ static float triangleCoords[] = { 0.5f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, }; /** * 管道 */ private FloatBuffer vertexBuffer; /** * 顶点着色器 */ private String vertextShaderCode = \"attribute vec4 vPosition;\\n\" + \"uniform mat4 vMatrix;\\n\" + \"void main(){\" + \"gl_Position=vMatrix*vPosition;\" + \"}\"; /** * 片元着色器 */ private final String fragmentShaderCode = \"precision mediump float;\\n\" + \"uniform vec4 vColor;\\n\" + \"void main(){\\n\" + \"gl_FragColor=vColor;\\t\\n\" + \"}\"; int mProgram; public Triangle(){ ByteBuffer bb = ByteBuffer.allocateDirect(triangleCoords.length * 4); bb.order(ByteOrder.nativeOrder()); vertexBuffer=bb.asFloatBuffer();// 把顶点 推送 给GPU vertexBuffer.put(triangleCoords); vertexBuffer.position(0); //创建顶点着色器 并在GPU中编译 int shader = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER); GLES20.glShaderSource(shader,vertextShaderCode); //编译顶点着色器 GLES20.glCompileShader(shader); //创建片元着色器 并在GPU中编译 int fragmentShader = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER); GLES20.glShaderSource(fragmentShader,fragmentShaderCode); //编译片元着色器 GLES20.glCompileShader(fragmentShader); //将顶点着色器和片元着色器放到统一的管理器中进行管理 mProgram = GLES20.glCreateProgram(); GLES20.glAttachShader(mProgram,shader); GLES20.glAttachShader(mProgram,fragmentShader); //连接到着色器程序 GLES20.glLinkProgram(mProgram); } public void onSurfaceChanged(GL10 gl, int width, int height) { //计算宽高比 float ratio=(float)width/height; //投影矩阵 Matrix.frustumM(mProjectMatrix, 0, -ratio, ratio, -1, 1, 3, 120); //相机 Matrix.setLookAtM(mViewMatrix, ////摄像机的坐标 0, 0, 0, 7, //目标物的中心坐标 0f, 0f, 0f, //相机方向 0f, 1f, 0f); //计算变换矩阵 Matrix.multiplyMM(mMVPMatrix,0,mProjectMatrix,0,mViewMatrix,0); } /** * rgba */ float color[] = { 1.0f, 1.0f, 1.0f, 1.0f }; private float[] mViewMatrix=new float[16]; private float[] mProjectMatrix=new float[16]; private float[] mMVPMatrix=new float[16]; public void onDrawFrame(GL10 gl) { //开始渲染 //拿到总的程序 GLES20.glUseProgram(mProgram); //拿到vPosition的地址 int mPositionHandle = GLES20.glGetAttribLocation(mProgram, \"vPosition\"); //设置缩放 int mMatrixHandler = GLES20.glGetUniformLocation(mProgram, \"vMatrix\"); GLES20.glUniformMatrix4fv(mMatrixHandler,1,false,mMVPMatrix,0); //允许对这个地址进行读写 GLES20.glEnableVertexAttribArray(mPositionHandle); //给顶点着色器赋值 GLES20.glVertexAttribPointer(mPositionHandle,3, GLES20.GL_FLOAT,false,3*4,vertexBuffer); //给片元着色器赋值 int mColorHandle = GLES20.glGetUniformLocation(mProgram,\"vColor\"); GLES20.glUniform4fv(mColorHandle,1,color,0); //开始绘制 GLES20.glDrawArrays(GLES20.GL_TRIANGLES,0,3); //关闭读写 GLES20.glDisableVertexAttribArray(mPositionHandle); }} 结果：","link":"/2019/06/22/technology/OpenGl入门/"},{"title":"QQ红点拖拽效果","text":"今天来做一下QQ列表上的红点拖拽效果 思路：首先我们得给小圆点定义一些状态，默认状态，手指点上去的状态，手指一动时的状态，手指松开时的状态。在onTouchEvent方法中更新状态值，最后在onDraw中根据不同的状态值绘制圆和path。思路很简单，就是绘制的时候我们需要把中学时候学的几何数学拿来用一下啦。 先定义一些成员变量,把状态啊，画笔啊，半径啊，原点等都初始化好然后在开始，具体可以到最下面点击源码查看 先看onDraw方法 首先，只要不是爆炸状态，我们都需要绘制移动的圆点和上面的数字。123456//只要不是爆炸的情况都要绘制圆和字 if (mState != BUBBLE_STATE_BLAST) { canvas.drawCircle(mMovePoint.x, mMovePoint.y, mMoveRadius, mBubblePaint); mTextPaint.getTextBounds(mText, 0, mText.length(), mTextRect); canvas.drawText(mText, mMovePoint.x - mTextRect.width() / 2, mMovePoint.y + mTextRect.height() / 2, mTextPaint); } 然后就是当我们手指点到圆上开始拖拽的的状态，这时候我们需要绘制一个静止的圆和一个移动的圆，当两个圆小于一定的距离的时候，我们需要在他们之间绘制一个黏性的效果，其实就是绘制两条二街贝塞尔曲线。 绘制贝塞尔曲线的时候，需要求曲线的起始点，结束点和控制点的坐标，这时候会用到中学几何数学的小知识 计算角度 在直角三角形中,非直角的sin值等于对边长比斜边长.使用勾股定理计算即可。sinA=对边/斜边 cosB=邻边/斜边 tanA=对边/邻边 看着下面的图绘制会更清晰 123456789101112131415161718192021222324252627282930313233343536//链接状态绘制静止的圆和赛贝尔曲线 if (mState == BUBBLE_STATE_CLICK) { //绘制静止的圆 canvas.drawCircle(mQuitPoint.x, mQuitPoint.y, mQuitRadius, mBubblePaint); //绘制贝塞尔曲线 //找到控制点 float controlX = (mMovePoint.x + mQuitPoint.x) / 2; float controlY = (mMovePoint.y + mQuitPoint.y) / 2; //计算角度 在直角三角形中,非直角的sin值等于对边长比斜边长.使用勾股定理计算即可 //sinA=对边/斜边 cosB=邻边/斜边 tanA=对边/邻边 float sinThet = (mMovePoint.y - mQuitPoint.y) / mDist; float cosThet = (mMovePoint.x - mQuitPoint.x) / mDist; //A点 float ax = mQuitPoint.x - mQuitRadius * sinThet; float ay = mQuitPoint.y + mQuitRadius * cosThet; //B点 float bx = mMovePoint.x - mMoveRadius * sinThet; float by = mMovePoint.y + mMoveRadius * cosThet; //C点 float cx = mMovePoint.x + mMoveRadius * sinThet; float cy = mMovePoint.y - mMoveRadius * cosThet; //D点 float dx = mQuitPoint.x + mQuitRadius * sinThet; float dy = mQuitPoint.y - mQuitRadius * cosThet; //设置path的路径 mBezierPath.reset(); mBezierPath.moveTo(ax, ay); mBezierPath.quadTo(controlX, controlY, bx, by); mBezierPath.lineTo(cx, cy); mBezierPath.quadTo(controlX, controlY, dx, dy); mBezierPath.close(); canvas.drawPath(mBezierPath, mBubblePaint); } 找到各个点之后就简单了，使用path的api将各个点连接起来，最后绘制就ok。 最后是爆炸状态,我们在初始化的时候定义一个有5张爆炸小图片的bitmap数组，使用属性动画控制数组的下标，然后循环绘制这几张图片。12345678//爆炸状态绘制爆炸图片 if (mState == BUBBLE_STATE_BLAST &amp;&amp; mBlastIndex &lt; mBlastDrawablesArray.length) { mBlastRect.left = mMovePoint.x - mMoveRadius; mBlastRect.top = mMovePoint.y - mMoveRadius; mBlastRect.right = mMovePoint.x + mMoveRadius; mBlastRect.bottom = mMovePoint.y + mMoveRadius; canvas.drawBitmap(mBlastBitmapsArray[mBlastIndex], null, mBlastRect, mBlastPaint); } OK 下面是onTouchEvent中，我们需要根据手指的各种事件来切换当前的状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean onTouchEvent(MotionEvent event) { float x = event.getRawX(); float y = event.getRawY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: //勾股定理算出点击位置和静止圆的圆心距离 mDist = (float) Math.hypot(x - mQuitPoint.x, y - mQuitPoint.y); if (mState == BUBBLE_STATE_DEFAULT) { //如果手指点击到了圆上或者圆的附近 if (mDist &lt; mMoveRadius + MOVE_OFFSET) { mState = BUBBLE_STATE_CLICK; } } break; case MotionEvent.ACTION_MOVE: if (mState != BUBBLE_STATE_DEFAULT) { //勾股定理算出点击位置和静止圆的圆心距离,也就是手指一动的距离 mDist = (float) Math.hypot(x - mQuitPoint.x, y - mQuitPoint.y); mMovePoint.x = event.getRawX(); mMovePoint.y = event.getRawY(); //如果手指点击到了圆上或者圆的附近 if (mState == BUBBLE_STATE_CLICK) { //手指一动的距离小于我们定义的一个最大的距离，就绘制贝塞尔曲线，反之就是分离状态 if (mDist &lt; mMaxDist - MOVE_OFFSET) { mQuitRadius = (mMoveRadius - mDist / 8); } else { mState = BUBBLE_STATE_BREAK; } } } invalidate(); break; case MotionEvent.ACTION_UP: //如果还没断开直接返回原状 if (mState == BUBBLE_STATE_CLICK) { //执行回弹动画 startBackAnim(); } //断开了 else if (mState == BUBBLE_STATE_BREAK) { //如果断开了，小球的位置移动到距离2倍移动小球的距离以内也返回原状 if (mDist &lt; mMoveRadius * 2) { //执行回弹动画 startBackAnim(); } else { mState = BUBBLE_STATE_BLAST; //执行爆炸动画 startBlastAnim(); } } break; default: } return true; } DOWN事件，如果我们的手指点击到圆上或者圆的附近(附近使用一个偏移量MOVE_OFFSET来定义)，就把状态改成点击连接的状态 MOVE事件，判断手指移动动的距离小于我们定义的一个最大的距离，就绘制贝塞尔曲线和静止的圆，反之就定义为分离状态。 UP事件，如果静止圆和移动圆还没断开直接返回原状，执行回弹动画，如果已经断开了，在判断如果移动的圆这时候移动到了原来的点的一定范围内，就还需要回到原点，执行回弹动画，反之就执行爆炸动画。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//爆炸动画private void startBlastAnim() { ValueAnimator animator = ValueAnimator.ofInt(0, 5); animator.setDuration(500); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mBlastIndex = (int) animation.getAnimatedValue(); invalidate(); } }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); if(mOnExecuteFinishListener!=null){ mOnExecuteFinishListener.onFinish(EXECUTE_STATE_BLAST); } } }); animator.start(); } //回弹动画 private void startBackAnim() { PointF start = new PointF(mMovePoint.x, mMovePoint.y); PointF end = new PointF(mQuitPoint.x, mQuitPoint.y); //系统的PointFEvaluator只能支持21以上的,编译不通过。所以自己弄了一个把它代码抄过来就行啦 ValueAnimator animator = ValueAnimator.ofObject(new MyPointFEvaluator(), start, end); animator.setDuration(200); animator.setInterpolator(new OvershootInterpolator(5f)); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mMovePoint = (PointF) animation.getAnimatedValue(); invalidate(); } }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); mState = BUBBLE_STATE_DEFAULT; if(mOnExecuteFinishListener!=null){ mOnExecuteFinishListener.onFinish(EXECUTE_STATE_BACK); } } }); animator.start(); } 最后就是两个简单的属性动画，爆炸动画用来控制我们的bitmap数组的index值。回弹动画来控制两个点的移动，使用系统默认的插值器OvershootInterpolator(运动到终点后，冲过终点后再回弹)。 这里的PointFEvaluator这个估值器系统有提供，但是只支持5.0以上，所以自定了一个PointFEvaluator，把系统的源码抄一下即可。 OK到这里效果就出来了可以看下图 效果出来了，那怎么用呢，现在是在我们自定义的view中可以全屏拖动绘制，但是如果把这个veiw放到列表中怎么办呢，只能在列表的那一条区域中拖拽吗，当然不符合我们的预期 思路就是，当我们点击列表中的红点的时候，通过当前的Window对象拿到我们的跟布局DecorView，然后把我们自定义的view放到跟布局中，把当前的textview设置隐藏，然后在我们的自定义view的手指点击的地方开始绘制圆就可以了 这里需要注意onTouchEvent获取坐标使用event.getRawX()和event.getRawY()，不能使用event.getX()和event.getY()了，因为我们现在的自定义veiw和点击的textveiw不在一个布局中。getRawX()是相对于屏幕来说的而getX()是相对于父布局来说的。 所以我们在textvew的onTouchListener中，找到DecorView，然后把我们的自定义view放进去，最后把事件传递到我们的自定义view中就好了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class QQViewListenter implements View.OnTouchListener , QQBubbleView.OnExecuteFinishListener { private Context mContext; private ViewGroup mViewGroup; private QQBubbleView mQQBubbleView; private View currentClickView; public QQViewListenter(Context context) { mContext = context; Window window = ((Activity) context).getWindow(); mViewGroup = (ViewGroup) window.getDecorView(); mQQBubbleView = new QQBubbleView(context); } @Override public boolean onTouch(View v, MotionEvent event) { currentClickView = v; Log.e(\"onTouch\",\"x--\"+event.getRawX()+\"y--\"+event.getRawY()+\"--event\"+event.getAction()); if (event.getAction() == MotionEvent.ACTION_DOWN) { if(mViewGroup!=null){ mViewGroup.addView(mQQBubbleView); } ViewParent parent = v.getParent(); if (parent == null) { return false; } if(v instanceof TextView){ String text = ((TextView) v).getText().toString(); mQQBubbleView.setText(text); } //防止父容器消费事件 parent.requestDisallowInterceptTouchEvent(true); int width = v.getWidth(); mQQBubbleView.setCenter(event.getRawX(),event.getRawY(),width/2); mQQBubbleView.setOnDismissListener(this); currentClickView.setVisibility(View.INVISIBLE); } //事件传递 mQQBubbleView.onTouchEvent(event); return true; } @Override public void onFinish(int type) { if(mViewGroup!=null&amp;&amp;mQQBubbleView!=null){ mViewGroup.removeView(mQQBubbleView); } if(type == EXECUTE_STATE_BACK){ currentClickView.setVisibility(View.VISIBLE); }else { currentClickView.setVisibility(View.GONE); } }} OnExecuteFinishListener是我们自顶一个view中定义的一个接口，用来监听手指抬起之后的的状态结果，因为完事后我们需要移除我们添加到DecorView中的我们自己的veiw。 使用的时候，我们在Adapter中的textveiw设置setOnTouchListener监听传入我们上面写的QQViewListenter即可。 最终效果： 源码位置","link":"/2019/03/30/technology/QQ红点拖拽效果/"},{"title":"shell语法练习","text":"shell语法练习 变量的定义和使用编写shell脚本，第一行是#!/bin/bash代表是个shell脚本 输入参数： 形式 说明 $0 当前程序的名称 $n 程序的输入参数n=1 第一个参数n2 第二个参数1..n $* 所有输入的参数 $# 输入参数的个数 $? 命令执行的状态，一般返回0代表成功 先来一个简单的输出shell12345678910111213141516#!/bin/bashecho \"haha\"A=10#代表输出自己echo $0#代表输出第一个参数echo $1#代表输出第二个参数echo $2#$?表示执行是否成功 0代表成功 非0代表失败echo \"this \\$? is $?\"#$* 列出所有传入的参数echo \"this \\*? is $*\"#$# 代表输入了几个参数echo \"this \\#? is $#\" 执行./demo.sh haha hehe之后输出如下12345678[root@cdh-master test]# ./demo.sh haha hehehaha./demo.shhahahehethis $? is 0this \\*? is haha hehethis \\#? is 2 循环for循环： 12345#!/bin/bashfor i in `seq 1 15`do echo \"数字 $i\"done seq代表取值，上面代码就是取1-15的值 for循环中的逻辑放在do和done的中间，运行上面的代码就会输出1-15之间的数字。 使用for循环求和： 1234567#!/bin/bashj=0for((i=0;i&lt;=100;i++))do j=`expr $i + $j`doneecho $j 使用加号需要用expr关键字来修饰 使用for循环，循环压缩文件123456#!/bin/bashj=0for i in `find /app/bigdata/test -name \"*.sh\"`do tar -cvf chs.tgz $idone 通过find命令找到某个文件夹下的所有.sh结尾的文件，然后通过tar命令来压缩。 while循环：1234567#!/bin/bashi=0while((i&lt;100))do echo \"数字 $i\" i=`expr $i + 1`done 也可以使用下面的方式1234567#!/bin/bashi=0while [[ $i -lt 100 ]]do echo \"数字 $i\" i=`expr $i + 1`done 使用while读取文件 1234567#!/bin/bashi=0while read linedo echo $line#小于号代表读取出来的内容指向哪里done&lt;/app/bigdata/test/text.txt 条件if语句： if语句后面不需要{},只需要;，语句的第一样一定要使用tab键输入，不能使用空格。空格在shell中不能随便写，代表一个特殊的分割符 12345678#!/bin/basha=300b=200if (($a&lt;$b));then echo \"a&lt;b\"else echo \"a&gt;b\"fi 例子： -d是判断目录是否存在 123456789101112131415#!/bin/bashif [[ ! -d /app/bigdata/hello ]];then mkdir -p /app/bigdata/helloelse echo \"目录已经存在\"fi-------------------#!/bin/bashdir=/app/bigdata/test/haha.txtif [[ ! -d $dir ]];then vi $direlse echo \"文件经存在\" cat $dirfi 算数运算 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 算数运算符 运算符 说明 例子 + 加法 `expr $a + $b` - 减法 `expr $a - $b` * 乘法 `expr $a * $b` / 除法 `expr $a / $b` % 取余 `expr $a % $b` = 赋值 a=$b == 相等 [ $a==$b ] != 不相等 [ $a!=$b ] 注意：条件表达式要放在中括号内，并且要有空格！ 算数运算符中我们不能直接使用运算符得到结果比如1+1，只会输出一个字符串“1+1”，想要得到结果有四种方式，建议使用第四种 使用$(()) $(( 4 + 5 )) 使用$[] $[ 4 + 5 ] 使用let命令 n=10 let n=n+1 使用expr外部程式 a=`expr 4 + 5` 命令 描述 例子 -eq 等于 [ $a -eq $b ] -ne 不等于 [ $a -ne $b ] -gt 大于 [ $a -gt $b ] -lt 小于 [ $a -lt $b ] -ge 大于等于 [ $a -ge $b ] -le 小于等于 [ $a -le $b ] 布尔运算符： 命令 描述 例子 ! 非运算 [ !false ] -a 与运算 [ $a -lt 20 -a $b -gt 100 ] -o 或运算 [$a -lt 20 -o $b -gt 100] 逻辑运算符 命令 描述 例子 &amp;&amp; 逻辑中的and [[ $a -lt 100 &amp;&amp; $b -gt 200]] ` ` 逻辑中的or [[ $a -lt 100 ` ` $b -gt 200]] 字符串运算符 命令 描述 例子 = 两个字符串相等 [ $a=$b ] != 两个字符串不等 [ $a!=$b ] -z 字符串长度是否为0 0返回true [ -z $a ] -n 字符串长度是否为0 非0返回true [ -n “$a” ] $ 字符串是否为空 非空返回true [ $a ] 文件测试运算符 $file代表文件的路径 命令 描述 例子 -b 文件是否是块设备文件 [ -f $file ] -c 文件是否是字符设备文件 [ -f $file ] -d 目录是否存在 [ -d $file ] -f 文件是否存在 [ -f $file ] -g 文件是否设置了SGID位 [ -f $file ] -k 文件是否设置粘着(Sticky Bit)位 [ -f $file ] -p 文件是否有名管道 [ -f $file ] -u 文件是否置了SUID位 [ -f $file ] -r 文件是否可读 [ -f $file ] -w 文件是否可写 [ -f $file ] -x 文件是否可执行 [ -f $file ] -s 文件是否为空 [ -f $file ] -e 文件(包括目录)是否存在 [ -f $file ] 重定向Linux中一切皆文件 描述符： 标准输入standard input0 (默认设备键盘) 标准输出standard input1 (默认设备显示器) 错误输出error input2 (默认设备显示器) 输出重定向&gt;比如cat 0&lt; text.txt 输出重定向&lt; 比如echo hello &gt; filename 方法函数定义一个函数 第一种：1234name(){ } 第二种：12345[ function ] funname [()]{ action; [return int;]} 例子：123456789101112#!/bin/bashaa=\"this is aa\"bb=\"this is bb\"function test(){ echo $1 cc=\"this. is cc\" dd=\"this is dd\" echo $cc echo \"我是一个函数\"}#调用函数并传参test 10 123456789101112#!/bin/basha=1;factorial(){#此处$1是西面调用的时候传过来的参数for i in `seq $1`do let a*=$idoneecho \"$1 的阶乘 $a \"}#此处$1是外部传入的参数factorial $1 函数的返回值 1234567#!/bin/bashfun2(){read -p \"请输入数值\" numlet 2*num}fun2echo \"fun2 return value: $?\" $?代表取上一条指令的返回值，上面的函数返回值为0。0代表执行成功，非0表执行失败（数值在0-255之间） 可以通过echo的方法返回一个数值 1234567#!/bin/bashfun2(){read -p \"请输入数值\" numecho $[2*$num]}result=`fun2`echo \"fun2 return value: $result\" 使用shell脚本编译FFmpeg FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。 FFmpeg是一个多媒体视频处理工具，具有非常强大的功能，包括视频采集功能，视频格式转换，视频抓图，给视频添加水印等。 FFmpeg组成部分 FFmpeg工具：1.FFmpeg 2.FFplay 3.FFprobe FFmpeg开发库： Libavcdec Libavutil Libavfrmat Libavdebice Libavfilter Libswscale Libswresample FFmpeg下载地址：http://www.ffmpeg.org/download.html 如果我们编译到Android中使用，需要用到Android的NDK NDK下载：1wget https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip 下载完NDK配置环境变量 vim /etc/profile12NDKROOT=/app/bigdata/test/android-ndk-r17cexport PATH=$NDKROOT:$PATH sorce /etc/profile 然后执行ndk-build如果打印下面的信息就说明配置OK123[root@cdh-master android-ndk-r17c]# ndk-buildAndroid NDK: Could not find application project directory ! Android NDK: Please define the NDK_PROJECT_PATH variable to point to it. 把下载的ffmpeg的压缩包上传到服务器 解压tar -xjf ffmpeg-4.1.3.tar.bz2报错12345[root@cdh-master test]# tar -xjf ffmpeg-4.1.3.tar.bz2 tar (child): bzip2: Cannot exec: No such file or directorytar (child): Error is not recoverable: exiting nowtar: Child returned status 2tar: Error is not recoverable: exiting now 因为没有安装bzip2,给它安装1yum install bzip2 在解压OK 下面开始编译ffmpeg，因为编译的时候需要指定很多参数，所以把它们写到一个shell脚本中方便查看和执行。 进入到ffmpeg-4.1.3的解压目录中，新建一个build.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bash#NDK的安装目录NDK_ROOT=/root/ndk/android-ndk-r17c#TOOLCHAIN 变量指向ndk中的交叉编译gcc所在的目录TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/#FLAGS与INCLUDES变量 可以从AS ndk工程的.externativeBuild/cmake/debug/armeabi-v7a/build.ninja中拷贝，需要注意的是**地址**FLAGS=\"-isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -std=c++11 -O0 -fPIC\"INCLUDES=\"-isystem $NDK_ROOT/sources/cxx-stl/llvm-libc++/include -isystem $NDK_ROOT/sources/android/support/include -isystem $NDK_ROOT/sources/cxx-stl/llvm-libc++abi/include\"#执行configure脚本，用于生成makefile#--prefix : 安装目录#--enable-small : 优化大小#--disable-programs : 不编译ffmpeg程序(命令行工具)，我们是需要获得静态(动态)库。#--disable-avdevice : 关闭avdevice模块，此模块在android中无用#--disable-encoders : 关闭所有编码器 (播放不需要编码)#--disable-muxers : 关闭所有复用器(封装器)，不需要生成mp4这样的文件，所以关闭#--disable-filters :关闭视频滤镜#--enable-cross-compile : 开启交叉编译（ffmpeg比较**跨平台**,并不是所有库都有这么happy的选项 ）#--cross-prefix: 看右边的值应该就知道是干嘛的，gcc的前缀 xxx/xxx/xxx-gcc 则给xxx/xxx/xxx-#disable-shared enable-static 不写也可以，默认就是这样的。#--sysroot: #--extra-cflags: 会传给gcc的参数#--arch --target-os :PREFIX=./android/armeabi-v7a2./configure \\--prefix=$PREFIX \\--prefix=$PREFIX \\--enable-small \\--disable-programs \\--disable-avdevice \\--disable-encoders \\--disable-muxers \\--disable-filters \\--enable-cross-compile \\--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\--disable-shared \\--enable-static \\--sysroot=$NDK_ROOT/platforms/android-21/arch-arm \\--extra-cflags=\"$FLAGS $INCLUDES\" \\--extra-cflags=\"-isysroot $NDK_ROOT/sysroot\" \\--arch=arm \\--target-os=android make cleanmake install 保存执行几分钟后，会看到生成了一个andorid目录，里面就是编译完成的文件。","link":"/2019/05/25/technology/shell语法练习/"},{"title":"Xfermode实现刮刮卡","text":"想要实现一个刮刮卡的效果，其中的一种方法就是使用图层混合模式Xfermode，想要很好的理解Xfermode，我们需要先结合着谷歌的例子来。 官方的源码我们可以在这里获得 https://github.com/THEONE10211024/ApiDemos/blob/master/app/src/main/java/com/example/android/apis/graphics/Xfermodes.java 将这里面的源码拿到自己的项目中运行我们就可以看到下面这张图片。 先绘制Dst在绘制Src，我们需要知道一点，使用Xfermode混合模式绘制后，受影响的区域永远是我们的src原图像区域。下面我们来看一下这16中混合模式的具体意思12345678910111213141516171819202122232425262728293031323334private static final Xfermode[] sModes = { //所绘制的不会提交到画布上 new PorterDuffXfermode(PorterDuff.Mode.CLEAR), //显示上层绘制的图片 new PorterDuffXfermode(PorterDuff.Mode.SRC), //显示下层绘制的图片 new PorterDuffXfermode(PorterDuff.Mode.DST), //上下层都显示，上层层居上 new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER), //上下层都显示，下层居上 new PorterDuffXfermode(PorterDuff.Mode.DST_OVER), //取两层绘制的交集，显示上层 new PorterDuffXfermode(PorterDuff.Mode.SRC_IN), //取两层绘制的交集，显示下层 new PorterDuffXfermode(PorterDuff.Mode.DST_IN), //取上层绘制的非交集部分，其余部分变成透明 new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT), //取下层绘制的非交集部分，其余部分变成透明 new PorterDuffXfermode(PorterDuff.Mode.DST_OUT), //取上层的交集部分和下层的非交集部分 new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP), //取下层交集部分和上层非交集部分 new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP), //除去两层的交集部分 new PorterDuffXfermode(PorterDuff.Mode.XOR), //取全部区域，交集部分颜色加深 new PorterDuffXfermode(PorterDuff.Mode.DARKEN), //取两图层全部区域，交集部分颜色点亮 new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN), //取两层交集部分，颜色加深 new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY), //取两图层全部区域，交集部分变为透明色 new PorterDuffXfermode(PorterDuff.Mode.SCREEN), }; 知道了上面的属性的意思，我们来想一下我们刮刮卡的思路一个图片上面蒙上一层，手指划过的区域让上层变成透明，就显示出下层的图片了。 我们去上面属性中找，就可以找到DST_OUT这个属性，它的意思是取下层绘制的非交集部分，交集部分变成透明 所以我们可以先绘制一个刮奖层，为dst层，手指一动的路径为src层。设置为DST_OUT属性，那么两者交集的地方就会变成透明了。 当然也可以是用SRC_OUT，使用SRC_OUT就是遮罩层绘制在path上面。使用DST_OUT就是遮罩层绘制在path下面 1234567891011121314151617private void init() { mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(30); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeCap(Paint.Cap.ROUND); //禁止硬件加速 setLayerType(LAYER_TYPE_SOFTWARE,null); //结果图片 mBitmapRes = BitmapFactory.decodeResource(getResources(), R.mipmap.guagua); //遮罩层图片 mSrcBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.gua); //创建一个可绘制path的bitmap mDstBitmap = Bitmap.createBitmap(mSrcBitmap.getWidth(),mSrcBitmap.getHeight(), Bitmap.Config.ARGB_8888); mCanvas = new Canvas(mDstBitmap); } 首先禁止硬件加速，有些手机不支持，然后初始化结果图片，遮罩层图片和一个可绘制path的bitmap 下面分别使用DST_OUT和SRC_OUT两种方式来实现绘制12345678910111213141516171819202122232425 protected void onDraw(Canvas canvas) { super.onDraw(canvas); //绘制结果图片 canvas.drawBitmap(mBitmapRes,0,0,null);// //第一种 先绘制遮罩层在绘制path,path的画笔使用DST_OUT模式// mCanvas.drawBitmap(mSrcBitmap,0,0,null);// mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));// mCanvas.drawPath(mPath,mPaint);// //绘制目标图像// canvas.drawBitmap(mDstBitmap,0,0,null); //第二种//遮罩层绘制在path上面，遮罩层的画笔使用SRC_OUT模式 //新建一个图层，不然会把原始图层也当成dst层了。上面的方法之所以不用起一个新图层，因为遮罩层和path都是绘制在新new的canvas中了。 int layerId = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); //绘制路径 mCanvas.drawPath(mPath,mPaint); //绘制目标图像 canvas.drawBitmap(mDstBitmap,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(mSrcBitmap,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); } 第一种先绘制遮罩层在绘制path,path的画笔使用DST_OUT模式，第二种遮罩层绘制在path上面，遮罩层的画笔使用SRC_OUT模式。 第二种方法使用canvas.saveLayer新建了一个图层，是因为如果不新建一个图层，就会把原始图层当成dst层了。第一种方式，因为我们先new了一个自己的Canvas，然后把遮罩层绘制在了new出来的画布上了，path也是绘制在这个画布上。 最后就是path的路径了，很简单通过onTouchEvent获得123456789101112131415161718192021 public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); switch (event.getAction()){ case MotionEvent.ACTION_DOWN: mEventX = event.getX(); mEventY = event.getY(); mPath.moveTo(mEventX,mEventY); break; case MotionEvent.ACTION_MOVE: float endX = (mEventX+event.getX())/2; float endY = (mEventY+event.getY())/2; //可以用lineTo也可以用quadTo一个是直线一个是以阶贝塞尔曲线 mPath.quadTo(mEventX,mEventY,endX,endY);// mPath.lineTo(event.getX(),event.getY()); mEventX = event.getX(); mEventY = event.getY(); invalidate(); break; } return true; } 如果有需求，当擦除一半的遮罩层后，抬起手自动全部消除，参考鸿洋的博客我们可以统计mDstBitmap的像素数据，被清除的像素变成0。统计为0的像素点跟总的像素点相除，大于某个值之后比如0.5就不绘制遮罩层了。 由于图片可能会很大，所以在子线程中处理统计的操作。在MotionEvent.ACTION_UP中启动线程计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243private Runnable mRunnable = new Runnable() { private int[] mPixels; @Override public void run() { int w = mDstBitmap.getWidth(); int h = mDstBitmap.getHeight(); float wipeArea = 0; float totalArea = w * h; Bitmap bitmap = mDstBitmap; mPixels = new int[w * h]; //拿到所有的像素信息 bitmap.getPixels(mPixels, 0, w, 0, 0, w, h); //遍历统计擦除的区域 for (int i = 0; i &lt; w; i++) { for (int j = 0; j &lt; h; j++) { int index = i + j * w; if (mPixels[index] == 0) { wipeArea++; } } } //根据所占百分比，进行一些操作 if (wipeArea &gt; 0 &amp;&amp; totalArea &gt; 0) { int percent = (int) (wipeArea * 100 / totalArea); if (percent &gt; 50) { isComplete = true; postInvalidate(); } } } }; 最后我们可以在OnMeasure方法中，将我们整个view的大小设置为我们背景图片的大小,就可以在布局文件中愉快的玩耍啦。不然在布局文件中总是已match_parent的形式存在。12345678910111213141516171819202122232425protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 宽的测量规格 int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); // 宽的测量尺寸 int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); // 高度的测量规格 int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); // 高度的测量尺寸 int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); //根据View的逻辑得到，比如TextView根据设置的文字计算wrap_content时的大小。 //这两个数据根据实现需求计算。 int wrapWidth = mBitmapRes.getWidth(); int wrapHeight = mBitmapRes.getHeight(); // 如果是是AT_MOST则对哪个进行特殊处理 if(widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, wrapHeight); }else if(widthSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, heightSpecSize); }else if(heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(widthSpecSize, wrapHeight); }} 最终效果图和源码： 源码位置","link":"/2019/03/27/technology/Xfermode实现刮刮卡/"},{"title":"增量更新","text":"增量更新 现在大多数热门应用中都使用了增量更新来更新新的功能。比如解压微信或者抖音的apk，在其lib文件夹下都能找到类似 libbspatch.so的动态库，这个就是用来增量更新的库。 Android NDK中为我们提供了一个工具可以查看动态库中的方法，工具在\\sdk\\ndk-bundle\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\bin 进入到此文件夹下面执行下面的方法就能看到so中的方法了。 1arm-linux-androideabi-nm.exe -D so的路径 增量更新使用到一个开源库bsdiff，bsdiff是一个查分算法，原理是旧文件跟新文件对比，尽可能多的利用old文件中已经有的内容，尽可能少的加入新的内容来构建new文件。 通常的做法是对旧文件和新文件做字符串匹配或者使用hash技术提取公共部分，然后把新文件的剩余部分打成patch包（差分包中记录着新内容相对旧内容的偏移地址），在Patch阶段中用copying和insertion两个操作把旧文件和patch文件合成新文件。 增量更新的流程：在服务器端，使用bsdiff工具把旧的apk和新的apk进行比对得到差分包patch包，通过网络下载到本地，通过bspatch工具把本地旧的apk和patch包合成新的apk包。最后安装新的apk bsdiff 下载地址:http://www.daemonology.net/bsdiff/ 现在最新的是bsdiff-4.3 将下载的文件上传到服务器，解压进入bsdiff-4.3文件夹，执行make命令编译文件，发现会出错。 是因为Makefile文件中的格式不正确1234567891011121314151617181920212223242526272829303132CFLAGS += -O3 -lbz2PREFIX ?= /usr/localINSTALL_PROGRAM ?= ${INSTALL} -c -s -m 555INSTALL_MAN ?= ${INSTALL} -c -m 444all: bsdiff bspatchbsdiff: bsdiff.cbspatch: bspatch.cinstall: ${INSTALL_PROGRAM} bsdiff bspatch ${PREFIX}/bin.ifndef WITHOUT_MAN ${INSTALL_MAN} bsdiff.1 bspatch.1 ${PREFIX}/man/man1.endif//上面是错误的 .ifndef和.endif前面需要TAB键缩进一下CFLAGS += -O3 -lbz2PREFIX ?= /usr/localINSTALL_PROGRAM ?= ${INSTALL} -c -s -m 555INSTALL_MAN ?= ${INSTALL} -c -m 444all: bsdiff bspatchbsdiff: bsdiff.cbspatch: bspatch.cinstall: ${INSTALL_PROGRAM} bsdiff bspatch ${PREFIX}/bin .ifndef WITHOUT_MAN ${INSTALL_MAN} bsdiff.1 bspatch.1 ${PREFIX}/man/man1 .endif 修改完后继续编译还是报错，找不到&lt;bzlib.h&gt;，因为bsdiff依赖了bzip库12fatal error: bzlib.h: No such file or directory #include &lt;bzlib.h&gt; 下安装bzip2123456//Linuxyum install bzip2-devel.x86_64//Ubuntuapt install libbz2-dev//Macbrew install bzip2 然后在执行make命令，成功,bsdiff-4.3文件夹下面生成了两个可执行文件bsdiff和bspatch 把old.apk和new.apk，上传到此文件夹，执行下面命令就可以生成差分包1bsdiff old.apk new.apk patch 将patch差分包下载到手机中跟旧的apk合并成新的安装包。 手机方面需要把bspatch继承到我们的项目中才能合并 AndroidStudio中新建一个C++文件，前面解压缩的bsdiff-4.3中有bspatch.c文件，将他拷贝到cpp文件夹下面。 编译之后会报错，因为前面我们知道bsdiff依赖了bzip库，linux系统中我们可以直接安装，AndroidStudio中，我们需要自己下载编译，可以在Linux中变异成静态文件导入，不过由于它的文件比较少，我们可以直接导入源码。 bzip2的地址：https://sourceforge.net/projects/bzip2/ http://www.bzip.org/downloads.html 下载之后解压，我们看到里面的文件也是挺多的，我们并不需要全部的文件，那需要哪些呢。我们可以看到它有一个Makefile文件，打开它，从代码中可以看到123456789libbz2.a: $(OBJS)OBJS= blocksort.o \\ huffman.o \\ crctable.o \\ randtable.o \\ compress.o \\ decompress.o \\ bzlib.o libbz2.a 这个静态文件可以通过OBJS中的这些文件编译成，所以我们只需要这几个c文件就好了。cpp下新建一个bzip文件夹。把他们也复制到该文件夹加下 下一步配置CMakeLists.txt1234567891011121314151617181920cmake_minimum_required(VERSION 3.4.1)file(GLOB bzip_source ${CMAKE_SOURCE_DIR}/bzip/*.c)add_library( bspatcher SHARED ${CMAKE_SOURCE_DIR}/bspatcher.cpp ${CMAKE_SOURCE_DIR}/bspatch.c ${bzip_source})find_library( log-lib log)target_link_libraries( bspatcher ${log-lib}) bspatcher是我们自己的cpp文件 下面开始编写自己的java文件和bspatcher这个cpp文件 12345678910111213141516public class BsPatcher { static { System.loadLibrary(\"bspatcher\"); } /** * 合成安装包 * * @param oldApk 旧版本安装包，如1.1.1版本 * @param patch 差分包，Patch文件 * @param output 合成后新版本apk的输出路径 */ public static native void bsPatch(String oldApk, String patch, String output);} bspatcher文件123456789101112131415161718192021222324252627#include &lt;jni.h&gt;#include &lt;string&gt;#include&lt;android/log.h&gt;// extern 声明在 bspatch.cextern \"C\" {extern int p_main(int argc, const char *argv[]);}extern \"C\"JNIEXPORT void JNICALLJava_com_chs_bsdiff_BsPatcher_bsPatch(JNIEnv *env, jclass type, jstring oldApk_, jstring patch_, jstring output_) { // 将Java字符串转为C/C++的字符串，转换为UTF-8格式的char指针 const char *oldApk = env-&gt;GetStringUTFChars(oldApk_, 0); const char *patch = env-&gt;GetStringUTFChars(patch_, 0); const char *output = env-&gt;GetStringUTFChars(output_, 0); __android_log_print(ANDROID_LOG_ERROR,\"BSPATCH\",oldApk,patch,output); // bspatch, oldfile, newfile, patchfile const char *argv[] = {\"\", oldApk, output, patch}; p_main(4, argv); // 释放指向Unicode格式的char指针 env-&gt;ReleaseStringUTFChars(oldApk_, oldApk); env-&gt;ReleaseStringUTFChars(patch_, patch); env-&gt;ReleaseStringUTFChars(output_, output);} 非常简单，从java层把old.apk的路径，patch包的路径，new.apk的说出路径传进来然后传入bspatch.c的main方法中即可完成合并。我们把p_main中的main方法改个名字改成p_main，方便和main方法区分。 最后在Activity中开启线程下载patch包到本地，合成新包，并安装新包，比如使用AsyncTask下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 new AsyncTask&lt;Void, Void, File&gt;() { @Override protected File doInBackground(Void... voids) { String patch = new File(Environment.getExternalStorageDirectory(), \"patch\").getAbsolutePath(); // 获取旧版本路径（正在运行的apk路径） String oldApk = getApplicationInfo().sourceDir; String output = createNewApk().getAbsolutePath(); if (!new File(patch).exists()) { return null; } BsPatcher.bsPatch(oldApk, patch, output); return new File(output); } @Override protected void onPostExecute(File file) { super.onPostExecute(file); Log.e(\"output----&gt;&gt;\", \"onPostExecute\"); // 已经合成了，调用该方法，安装新版本apk if (file != null) { if (!file.exists()) return; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { Uri fileUri = FileProvider.getUriForFile(MainActivity.this, MainActivity.this.getApplicationInfo().packageName + \".fileprovider\", file); intent.setDataAndType(fileUri, \"application/vnd.android.package-archive\"); } else { intent.setDataAndType(Uri.fromFile(file), \"application/vnd.android.package-archive\"); } MainActivity.this.startActivity(intent); } else { Toast.makeText(MainActivity.this, \"差分包不存在！\", Toast.LENGTH_LONG).show(); } } }.execute(); private File createNewApk() { File newApk = new File(Environment.getExternalStorageDirectory(), \"new.apk\"); if (!newApk.exists()) { try { newApk.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } return newApk; } 到这里就更新完成了。 缺点： 我们不能保证所有用户都能升级完成，比如我们最新的patch包是2.0版本和3.0版本差分出来的，如果用户此时用的1.0版本，那就无法升级成功，所以还要做一个1.0和3.0之间的差分包。随着版本的越来越多，需要做的差分包也越来越多。可以在Linux中写一个自动的脚本来完成。 如果差分包在下载的过程中被篡改也无法合成成功，可以下载完后通过md5 或者其他方式对patch包进行完整性的校验。","link":"/2019/06/02/technology/增量更新/"},{"title":"理解属性动画从仿写开始","text":"属性动画的本质： 改变某一个View某一个时间点的属性值，比如一个View在0.1秒的时候在100px的位置，0.2秒的时候到了200px的位置，这就会让我们感觉到一个动画的效果，实际上就时每隔一段时间调用view.setX()方法。 看一下系统属性动画的简单用法12345Button button = findViewById(R.id.button); ObjectAnimator animator = ObjectAnimator.ofFloat(button,\"translationX\",0,200); animator.setDuration(2000); animator.start(); animator.setInterpolator(new LinearInterpolator()); 通过上面的方法，就会让一个button移动起来。下面我们自己来实现一个这个效果。 动画是需要时间来完成的，不同的时间节点，控件的状态也不一样。所以需要把一个动画分解成一个一个的关键帧。 看下面的流程图 此图是我自己的理解，如果问题欢迎指正。 当我们开始调用一个动画的时候，比如ObjectAnimator.ofFloat(button,&quot;translationX&quot;,0,200); 首先会把我们传入的View保存起来 然后会初始化一个Holder对象，这个Holder对象是用来干啥的呢？我们传入了一个translationX值，Holder对象中提供一个方法，把translationX拼接成一个set方法，setTranslationX，然后通过反射找到View中的此方法。当数值计算出来之后，执行获取的这个方法。 KeyframeSet是一个关键帧的集合，最后我们传入0-200就是关键帧 插值器，用来计算某一时间中动画长度播放的百分比 估值器，根据插值器计算的百分比，来计算某个时间，动画所要更新的值。然后交给Holder执行动画 属性动画会监听系统发出的VSYNC信号，每收到一次信号就执行一次。 什么是FPS？FPS代表每秒的帧数，当FPS&gt;=60的时候，我们的肉眼就不会感觉到卡顿了，FPS=60是个什么概念呢，1000/60≈16.6也就是说，想要不卡顿，我们需要在16毫秒以内绘制一帧出来。 什么是VSYNC？VSYNC是垂直同步的缩写，每16毫秒发送一个VSYNC信号，系统拿到这个信号之后开始刷新屏幕。 OK上面的概念大体了解了开干吧。 先来个简单的实体类Keyframe，这里以FloatKeyframe为例1234567891011121314151617181920212223public class MyFloatKeyframe { float mFraction; Class mValueType; float mValue; public MyFloatKeyframe(float fraction, float value) { mFraction = fraction; mValueType = float.class; mValue = value; } public float getValue() { return mValue; } public void setValue(float value) { mValue = value; } public float getFraction() { return mFraction; }} 它就是个实体类，只要包含三个对象，当前执行的百分比，关键帧中的值的类型和动画在mFraction时刻的值 下面在来个对象，关键帧的集合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyKeyframeSet { /** * 类型估值器 */ TypeEvaluator mEvaluator; /** * 第一帧 */ MyFloatKeyframe mFirstKeyframe; /** * 帧的集合 */ List&lt;MyFloatKeyframe&gt; mKeyframes; private MyKeyframeSet(MyFloatKeyframe ... keyframes){ mKeyframes = Arrays.asList(keyframes); mEvaluator = new FloatEvaluator(); mFirstKeyframe = keyframes[0]; } public static MyKeyframeSet ofFloat(float[] values) { //开始组装每一帧 int numKeyframes = values.length; MyFloatKeyframe keyframes[] = new MyFloatKeyframe[numKeyframes]; //先放入第一帧 keyframes[0] = new MyFloatKeyframe(0, values[0]); for (int i = 1; i &lt; numKeyframes; i++) { keyframes[i] = new MyFloatKeyframe((float)i/(numKeyframes-1),values[i]); } return new MyKeyframeSet(keyframes); } /** * 根据当前百分比获取响应的值 * @param fraction 百分比 * @return */ public Object getValue(float fraction){ MyFloatKeyframe preKeyFrame = mFirstKeyframe; for (int i = 1; i &lt; mKeyframes.size(); ++i) { MyFloatKeyframe nextKeyFrame = mKeyframes.get(i); if(fraction&lt;nextKeyFrame.getFraction()){ return mEvaluator.evaluate(fraction,preKeyFrame.getValue(),nextKeyFrame.getValue()); } preKeyFrame = nextKeyFrame; } return null; }} 这里面有两个比较关键的方法 ofFloat：这是个静态的方法，用于构造帧集合对象，根据我们传入的关键帧的个数，来组件一个关键帧的数组，然后创建出关键帧帧集合对象并传入创建的关键帧数组。 getValue：根据当前百分比调用估值器获取响应的值，这里的估值器直接使用系统的估值器里面实现很简单源码如下 123456public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; { public Float evaluate(float fraction, Number startValue, Number endValue) { float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); }} 我们知道估值器返回的是当前View需要移动的距离，上面的估值器就是返回开始的值加上（还剩的值乘以需要执行的百分比）就是当前View需要执行的数值。 OK，下面来看我们的入口类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyObjectAnimator implements VSYNCManager.AnimatorFrameCallBack{ /** * 动画执行的时长 */ private long mDuration = 0; /** * 插值器 */ private TimeInterpolator interpolator; private MyFloatPropertyValuesHolder mPropertyValuesHolder; /** * View是个比较重量级的对象，放到WeakReference中方便回收 */ private WeakReference&lt;View&gt; target; private Long mStartTime = -1L; /** * 执行到哪里 */ private float index = 0; public void setDuration(long duration) { mDuration = duration; } public void setInterpolator(TimeInterpolator interpolator) { this.interpolator = interpolator; } private MyObjectAnimator(View view,String propertyName, float... values){ target = new WeakReference&lt;&gt;(view); mPropertyValuesHolder = new MyFloatPropertyValuesHolder(propertyName,values); } public static MyObjectAnimator ofFloat(View view,String propertyName, float... values){ return new MyObjectAnimator(view,propertyName,values); } public void start() { mPropertyValuesHolder.setupSetter(target); mStartTime = System.currentTimeMillis(); VSYNCManager.getInstance().add(this); } @Override public void doAnimator(long currentTime) { float total= mDuration / 16; //执行的百分比 float fraction = (index++)/total; //通过插值器，改变百分比的值 if(interpolator != null){ interpolator.getInterpolation(fraction); } //循环播放 if(index&gt;=total){ index = 0; } mPropertyValuesHolder.setAnimatedValue(target.get(),fraction); }} 它实现了一个VSYNCManager的对调对象，用来在回调方法doAnimator中执行动画 构造方法中将传入的View保存起来，View是个比较重量级的对象，放到WeakReference中方便回收 然后初始化了Holder对象，开始的时候我们知道Hodler对象是用来找到我们传入View的相关属性的set方法的。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyFloatPropertyValuesHolder { String mPropertyName; Class mValueType; MyKeyframeSet mKeyframes; Method mSetter = null; public MyFloatPropertyValuesHolder(String propertyName, float... values) { mPropertyName = propertyName; mValueType = float.class; mKeyframes = MyKeyframeSet.ofFloat(values); } /** * 执行View 的相关的set 方法 * @param target view */ public void setupSetter(WeakReference&lt;View&gt; target) { //第一个字符大写 比如传过来的 translationX char firstLetter = Character.toUpperCase(mPropertyName.charAt(0)); String theRest = mPropertyName.substring(1); //拼成 setTranslationX 方法 String methodName = \"set\"+firstLetter+theRest; try { //通过反射拿到这个View的setTranslationX方法 mSetter = View.class.getMethod(methodName, float.class); } catch (NoSuchMethodException e) { e.printStackTrace(); } } /** * 设置动画的值 执行setTranslationX方法 * @param target view * @param fraction 百分比 */ public void setAnimatedValue(View target, float fraction) { Object value = mKeyframes.getValue(fraction); try { mSetter.invoke(target,value); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } }} Holder类中有两个方法： setupSetter：就是通过我们传入的字符串，拼接成一个set方法，然后通过反射找到这个方法，保存到成员变量中。 setAnimatedValue：找到当前动画需要设置的值，然后调用目标View的相关set方法。 最后是VSYNC信号，由于我们无法拿到系统的VSYNC信号，这里通过一个线程来模拟发从信号。1234567891011121314151617181920212223242526272829303132333435363738394041public class VSYNCManager { AnimatorFrameCallBack mAnimatorFrameCallBack; /** * 可能会有多个动画同事使用，所以弄个集合 */ private List&lt;AnimatorFrameCallBack&gt; list = new ArrayList&lt;&gt;(); private VSYNCManager(){ new Thread(mRunnable).start(); } public static VSYNCManager getInstance(){ return new VSYNCManager(); } public void add(AnimatorFrameCallBack callBack){ list.add(callBack); } Runnable mRunnable = new Runnable() { @Override public void run() { while (true){ try { Thread.sleep(16); } catch (InterruptedException e) { e.printStackTrace(); } for (AnimatorFrameCallBack callback : list) { callback.doAnimator(System.currentTimeMillis()); } } } }; interface AnimatorFrameCallBack{ void doAnimator(long currentTime); }} 很简单，开启一个线程，每睡16毫秒执行一个回调方法。因为可能不止一个View在监听这个信号，所以这里使用一个集合来保存回调对象，发送信号的时候循环遍历执行回调。 类中有个回调接口供我们的入口类MyObjectAnimator实现，发送信号的时候，执行回调方法doAnimator。 下面在看一下MyObjectAnimator中的回调方法doAnimator12345678910111213141516171819202122232425262728293031323334 public void doAnimator(long currentTime) { float total= mDuration / 16; //执行的百分比 float fraction = (index++)/total; //通过插值器，改变百分比的值 if(interpolator != null){ interpolator.getInterpolation(fraction); } //循环播放 if(index&gt;=total){ index = 0; } mPropertyValuesHolder.setAnimatedValue(target.get(),fraction); } //系统的匀速插值器public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory { public LinearInterpolator() { } public LinearInterpolator(Context context, AttributeSet attrs) { } public float getInterpolation(float input) { return input; } /** @hide */ @Override public long createNativeInterpolator() { return NativeInterpolatorFactoryHelper.createLinearInterpolator(); }} 我们传入的时间除以16，就是总共需要执行的次数 使用index来表示我们当前已经走了的次数，它跟总次数相除就是当前执行的百分比 通过插值器，改变百分比的值，如果是匀速的，当前的插值器返回的就是当前的值不变，从上面系统的匀速插值器LinearInterpolator中的getInterpolation方法也可以看到，我们传入啥就返回啥。如果不是匀速的，返回的百分比的值也就不一样，后面通过这个百分比算出来的需要执行的值也就不一样，我们看到的View动画执行速度也就不是匀速了。 最后调用mPropertyValuesHolder.setAnimatedValue方法传入百分比来执行动画。 OK，简易的动画到这里就写完了，怎么用呢，来到Activity中1234MyObjectAnimator animator = MyObjectAnimator.ofFloat(button, \"translationX\", 0, 200); animator.setInterpolator(new LinearInterpolator()); animator.setDuration(2000); animator.start(); 执行效果： 源码地址","link":"/2019/04/14/technology/理解属性动画从仿写开始/"},{"title":"自定义控件神器--PathMeasure","text":"自定义控件神器–PathMeasure 我们平时自定义View的时候，经常会绘制path，想要求出path路径上的某个点的位置，很难通过一般的数学函数来计算，幸好系统给我们提供了一个PathMeasure可以用来测量一个path的路径，我们可以根据测量得到的值来绘制一些别的效果。 PathMeasure有两个构造方法12345678public PathMeasure() { mPath = null; native_instance = native_create(0, false); }public PathMeasure(Path path, boolean forceClosed) { mPath = path; native_instance = native_create(path != null ? path.readOnlyNI() : 0,forceClosed); } 一个是有参数的，一个是没参数的 有参数的构造方法中第一个很好理解就是需要测量的path，第二个参数的意思是是否计算path路径闭合的路径。如果是true，那么不管我们path是不是闭合了，它都会去计算闭合的路径。如果是false就不会计算。 没有参数创建出来之后，可以通过 pathMeasure.setPath(mPath,false);方法把path和forceClosed这两个参数传进去 下面来看PathMeasure中的几个比较常用的方法 getSegment 给定一个起始点，一个结束点和一个空path对象，把给定的起点到终点的路径赋值给这个空的path。public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)。最后一个参数startWithMoveTo表示起点是否使用moveTo，用来保证截取的path第一个点的位置不变。从而保证截取的片段不会变形 它返回的是一个boolean值，如果截取到的路径长度是0就返回false，不是0就返回true。 下面来看一下使用getSegment的简单案例,在onDraw方法中123456789101112mPath.reset();mFloat += 0.01;if (mFloat &gt;= 1){ mFloat = 0;}mPath.addCircle(getWidth()/2,getHeight()/2,200,Path.Direction.CW);mDst.reset();pathMeasure.setPath(mPath,false);float distance = pathMeasure.getLength() * mFloat;pathMeasure.getSegment(0, distance , mDst, true);canvas.drawPath(mDst, mPaint);invalidate(); 使用一个0-1的成员变量mFloat来控制当前截取比例，每次调用invalidate的时候mFloat的值都会改变，这样就可以弄个简单的动画效果 效果如下 上面一直是从0来时截取如果我们改一下截取的位置1pathMeasure.getSegment(2*distance/3, distance, mDst, true); 第一个参数改成了2*distance/3，效果如下，类似一个加载动画的效果，这个参数可以随便改，更改的不同截取效果就不同 前面两个我们只绘制了我们截取的path，下面把原path也绘制上，截取的部分换一种颜色绘制，效果如下 getPosTan getPosTan方法，可以获得path路径上某个点的位置和这个点的切线的值。public boolean getPosTan(float distance, float pos[], float tan[]) distance是当前需要截取的长度，pos是一个数组，如果不为空，可以给这个数组赋值，pos[0]是x坐标pos[1]是y坐标，tan跟也是个数组，tan[0],tan[1]代表切线的值，通过Math.atan2()方法传入tan[0],tan[1]可以获取到当前切线的角度。 下面看一个简单的例子1234567891011121314151617181920212223mPath.reset(); mFloat += 0.01; if (mFloat &gt;= 1){ mFloat = 0; } mPath.addCircle(getWidth()/2,getHeight()/2,200,Path.Direction.CW); pathMeasure.setPath(mPath,false); //用来记录位置 float []pos = new float[2]; //用来记录切点的位置 float []tan = new float[2]; float distance = pathMeasure.getLength() * mFloat; pathMeasure.getPosTan(distance,pos,tan); //计算出当前图片要旋转的角度 float degree = (float) (Math.atan2(tan[1], tan[0]) * 180 / Math.PI); mMatrix.reset(); //设置旋转角度和旋转中心 mMatrix.postRotate(degree,mBitmap.getWidth() / 2,mBitmap.getHeight() / 2); //设置绘制的中心点与当前图片中心点重合 mMatrix.postTranslate(pos[0]-mBitmap.getWidth() / 2,pos[1]-mBitmap.getHeight()/2); canvas.drawPath(mPath, mPaint); canvas.drawBitmap(mBitmap,mMatrix, mPaint); 效果如下： 通过getPosTan方法，获取到当前的角度，通过Matrix方法把一个图片旋转这个角度，然后绘制到圆圈上 除了使用getPosTan之外，还有一个稍微简单的方法可以获取到pos和tan的值，通过pathMeasure.getMatrix方法 public boolean getMatrix(float distance, Matrix matrix, int flags) 前两个值好理解，最后一个值flag，用来指定矩阵中需要返回那些参数，有两个值 public static final int POSITION_MATRIX_FLAG = 0x01; public static final int TANGENT_MATRIX_FLAG = 0x02; 这两个值分别代表前面的pos和tan，例如下面的代码123456789101112131415161718mPath.reset(); mFloat += 0.01; if (mFloat &gt;= 1){ mFloat = 0; } //路径 mPath.lineTo(0, 200); mPath.lineTo(300, 200); mPath.quadTo(450,100,600,200); mPath.lineTo(900, 200); pathMeasure.setPath(mPath,false); //将pos信息和tan信息保存在mMatrix中 pathMeasure.getMatrix(pathMeasure.getLength() * mFloat, mMatrix, PathMeasure.POSITION_MATRIX_FLAG | PathMeasure.TANGENT_MATRIX_FLAG); //将图片的旋转坐标调整到图片中心位置 mMatrix.preTranslate(-mBitmap.getWidth() / 2, -mBitmap.getHeight() / 2); canvas.drawPath(mPath, mPaint); canvas.drawBitmap(mBitmap,mMatrix, mPaint); 效果： 下面使用PathMeasure制作一个支付宝支付的动画，效果如下主要用到getSegment这个方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181public class PathMeasurePay extends View { private Paint mPaint = new Paint(); private Path mPath = new Path(); private Path mCircleDst = new Path(); private Path mLineDst1 = new Path(); private Path mLineDst2 = new Path(); private Path mLineDst = new Path(); private PathMeasure pathMeasure; private int mCircleRadius; /** * 圆的中心点 */ private float circleX,circleY; /** * 绘制类型 1是对号 2是叉号 */ private int mType; /** * 动画控制的圆取值范围0-1 */ private float mCircleValue; /** * 动画控制的直线取值范围0-1 * mType==1的时候代表对号的线 * mType==2的时候代表叉号的第一条线 */ private float mLineValue; /** * 动画控制的叉号第二条线的取值范围0-1 */ private float mLineValue2; /** * mType==1的时候代表是否绘制对号 * mType==2的时候代表是否绘制叉号的第一条线 */ private boolean isDrawLine = false; /** * 是否绘制叉号的第二条线 */ private boolean isDrawLine2 = false; private ValueAnimator animatorCircle; private ValueAnimator animatorLine; private ValueAnimator animatorLine2; private int strockWidth = 6; public PathMeasurePay(Context context) { this(context,null); } public PathMeasurePay(Context context, @Nullable AttributeSet attrs) { this(context, attrs,0); } public PathMeasurePay(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context,attrs); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); circleX = w/2f; circleY = h/2f; mCircleRadius = Math.min(w/2-strockWidth,h/2-strockWidth); } private void init(Context context,AttributeSet attrs) { TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.PathMeasurePay); int paintColor = a.getColor(R.styleable.PathMeasurePay_color, Color.BLACK); mType = a.getInt(R.styleable.PathMeasurePay_type,1); a.recycle(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(paintColor); mPaint.setStrokeWidth(strockWidth); pathMeasure = new PathMeasure(); animatorCircle = ValueAnimator.ofFloat(0,1); animatorCircle.setDuration(1000); animatorLine = ValueAnimator.ofFloat(0,1); animatorLine.setDuration(mType==1?1000:500); animatorLine2 = ValueAnimator.ofFloat(0,1); animatorLine2.setDuration(500); animatorCircle.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { mCircleValue = (float) valueAnimator.getAnimatedValue(); invalidate(); } }); animatorCircle.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); isDrawLine = true; animatorLine.start(); } }); animatorLine.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mLineValue = (float) animation.getAnimatedValue(); invalidate(); } }); animatorLine.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); isDrawLine2 = true; if(mType == 2){ animatorLine2.start(); } } }); animatorLine2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mLineValue2 = (float) animation.getAnimatedValue(); invalidate(); } }); animatorCircle.start(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); mPath.reset(); mPath.addCircle(getWidth()/2f,getHeight()/2f,mCircleRadius,Path.Direction.CW); mCircleDst.reset(); pathMeasure.setPath(mPath,false); float distance = pathMeasure.getLength() * mCircleValue; pathMeasure.getSegment(0, distance , mCircleDst, true); canvas.drawPath(mCircleDst, mPaint); if(mType == 1){ if(isDrawLine){ mPath.reset(); mLineDst.reset(); mPath.moveTo(circleX-mCircleRadius/2f,circleY); mPath.lineTo(circleX-mCircleRadius/10f,circleY+mCircleRadius/2f); mPath.lineTo(circleX+mCircleRadius/2f,circleY-mCircleRadius/4f); pathMeasure.setPath(mPath,false); float dis = pathMeasure.getLength()*mLineValue; pathMeasure.getSegment(0,dis,mLineDst,true); canvas.drawPath(mLineDst,mPaint); } }else { if(isDrawLine){ mPath.reset(); mLineDst1.reset(); mPath.moveTo(circleX - mCircleRadius/2f,circleY - mCircleRadius/2f); mPath.lineTo(circleX+mCircleRadius/2f,circleY + mCircleRadius/2f); pathMeasure.setPath(mPath,false); float dis = pathMeasure.getLength()*mLineValue; pathMeasure.getSegment(0,dis,mLineDst1,true); canvas.drawPath(mLineDst1,mPaint); } if(isDrawLine2){ mPath.reset(); mLineDst2.reset(); mPath.moveTo(circleX+mCircleRadius/2f,circleY - mCircleRadius/2f); mPath.lineTo(circleX - mCircleRadius/2f,circleY +mCircleRadius/2f); pathMeasure.setPath(mPath,false); float dis = pathMeasure.getLength()*mLineValue2; pathMeasure.getSegment(0,dis,mLineDst2,true); canvas.drawPath(mLineDst2,mPaint); } } } public void reset(){ isDrawLine = false; isDrawLine2 = false; animatorCircle.start(); }} 源码地址 参考：https://www.jianshu.com/p/3efa5341abcc","link":"/2019/04/13/technology/自定义控件神器-PathMeasure/"},{"title":"Binder机制","text":"Binder机制 Binder概述Binder在我们大Android中是无处不在的，无论是调用媒体服务，传感器，还有我们经常在用的startActivity ，startService等等都在使用着Bindder来完成相应的功能。整个Android系统就可以看成一个基于Binder的C/S架构，binder英文意思是粘合剂，Binder就是这个粘合剂，把各个组件系统粘合在一起。Binder这么重要，作为Android开发者我们也更有必要搞懂它。 下面开始学习Binder之旅吧。 Binder是用来做进程间通信的，Android系统是基于Linux的，在Linux中已经有一些进程间通信的解决方案了，比如管道，共享内存，socket等，为啥Android又弄了个Binder呢？那我们就需要了解一下他们的优缺点了 管道 就比如A到B之间有一个管道，A把数据拷贝到管道中，B从管道中读取数据，这个过程需要建立管道并需要两次数据的拷贝 而且管道是半双工的也就是数据只能往一个方向流动，如果想要双方通信，就需要建立两个管道 所以管道比较耗费性能 共享内存 多个进程之间共享一块内存区域，这个过程中无需拷贝，效率非常高，但是由于这块内存对所有进程都可见，不好管理而且安全方面也不好 Socket Socket是一个通用的接口，主要用来进行网络之间的通信，虽然可以实现进程间通信，就是杀鸡用牛刀了，传输效率低，开销大，也需要两次的拷贝。 Binder 只需要一次数据拷贝，性能上仅次于共享内存。稳定性上Binder基于C/S架构模式，客户端有什么去求就丢给服务端去做，架构清晰职责明确。 安全方面，传统的进程间通信都没有做这一块，一个安卓系统中有那么多的APP存在，每个APP都运行在一个独立的进程中，我们不希望别的进程能够获取我们应用的信息。 Android为每个新安装的应用都分配了自己的UID，PID，这是通信时鉴别身份的重要凭证。 Binder中有4个比较重要的角色: Server Client ServiceManager Binder驱动 如上图所画 服务端通过Binder驱动在ServiceManager中注册我们的服务 客户端通过Bindr驱动查询ServiceManager中注册的服务 ServiceManager通过Binder驱动返回服务端的代理对象 客户端拿到服务器端的代理对象就可以进行进程间通讯了。 Client和Server是开发者自己来实现，Binder驱动和ServiceManager是系统提供的。 Binder核心原理 Client端发送数据到内核缓存区也就是拷贝 这个内核缓存区和Binder驱动中的数据缓存区存在映射关系 服务端和Bindr的数据缓存区有直接的内存映射关系。 这样就相当于把数据直接拷贝到了服务端 Binder源码（9.0） 下面的这些代码我自己也都是系统代码，我自己也云里雾里，不过我们也不需要深入了解，只需要通过这些地方来强化对其原理的理解就好了 1、打开Binder设备 源码位置：/frameworks/native/cmds/servicemanager/service_manager.c 在该文件中的main方法中有一句话 driver = &quot;/dev/binder&quot;; 这里就打开binder驱动设备 2、创建buffer用于进程间传递数据，开辟内存映射（128k） 第一步打开Binder驱动之后，紧接着一句代码bs = binder_open(driver, 128*1024);这里就是打开一个128k的内存映射 内存映射命令是mmap()，它在 /frameworks/native/cmds/servicemanager/binder.c文件中，进入可以看到 bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); 它是在系统启动的时候就会调用，在9.0系统源码/device/google/cuttlefish_kernel/4.4-x86_64/System.map文件中的25306行可以看到下面的指令ffffffff815dbf50 t binder_mmap来开启映射 3、ServiceManager启动 在系统源码位置 /system/core/rootdir/init.rc 文件中，可以找到start servicemanager指令 4、打包到Parcel中，数据写入binder设备copy_from_user 在系统源码：/frameworks/native/libs/binder/IServiceManager.cpp中可以看到parcel打包过程1234567891011virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated, int dumpsysPriority) { Parcel data, reply; data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); data.writeStrongBinder(service); data.writeInt32(allowIsolated ? 1 : 0); data.writeInt32(dumpsysPriority); status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); return err == NO_ERROR ? reply.readExceptionCode() : err; } 在系统文件 /frameworks/native/libs/binder/IPCThreadState.cpp中，找到err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); 将parcel中的信息封装成结构体并且写入到mOut中，并等待返回 5、服务注册，添加到链表svclist中 server向ServiceManager中注册 在系统代码：/frameworks/native/cmds/servicemanager/service_manager.c文件中 12345678if (!svc_can_register(s, len, spid, uid)) { ALOGE(\"add_service('%s',%x) uid=%d - PERMISSION DENIED\\n\", str8(s, len), handle, uid); return -1; } //去链表链表svclist中查找，看服务是否注册过 si = find_svc(s, len); .... 定义主线程中的线程池 在系统源码/frameworks/native/libs/binder/IPCThreadState.cpp文件中可以找到joinThreadPool方法。 这里就是定义一个主线程的线程池，，不停的读写 循环从mln和mOut中取出读写请求 mIn.setDataCapacity(256); mOut.setDataCapacity(256);他们默认是256字节的大小。 在talkWithDriver方法中，判断是否可以读写，最终发送到binder设备中。 这些代码真是看的云里雾里，只需要通过他们加深对Binder的执行原理就行了。 手撸AIDL直接操作Binder是比较麻烦的，Andorid中通过AIDL来简化我们使用Binder。 AIDL四个重要对象 IBinder： 一个接口，代表了一个跨进程通讯的能力 IInterance： 服务端进程有什么能力，可以提供哪些方法 Binder： Binder的本地对象 继承自IBinder Stub： 继承自Binder 实现了IInterance，本地实现的服务端的能力 例子：使用AIDL实现一个第三方的登录，现在有一个A应用和一个B应用，A应用调用B应用来实现登录。 最终效果如下图： A调用B的登录服务，B是服务端，我们先从B工程中创建一个aidl，直接在工程的main文件夹上右击鼠标创建即可，也可以创建到别的文件夹。 1234567package com.chs.binderb;interface ILoginInterface { void login(); void loginCallBack(boolean isSuccess,String user);} 创建两个方法一个登录方法，一个登录回调。 然后把这个AIDL的完整包名和文件都复制到A工程的相同位置。必须一模一样直接复制。 在B工程中创建一个LoginService来监听A工程发来的消息，跳转到第三方登录界面，注意跳转的时候需要设置Intent.FLAG_ACTIVITY_NEW_TASK这个flag12345678910111213141516171819public class LoginService extends Service { @Nullable @Override public IBinder onBind(Intent intent) { return new ILoginInterface.Stub() { @Override public void login() throws RemoteException { Intent intent = new Intent(getApplicationContext(), MainActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } @Override public void loginCallBack(boolean isSuccess, String user) throws RemoteException { } }; }} 然后在AndroidMainfest.xml文件中注册服务123456789 &lt;service android:name=\".service.LoginService\" android:enabled=\"true\" android:exported=\"true\" android:process=\":remote_server\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"BinderB_Action\"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/service&gt; android:enabled=”true” 表示可以被实例化 android:exported=”true” 表示可以被别的应用隐式调用 android:process=”:remote_server” 表示开启一个新进程，进程名字是remote_server action中的名字在 A应用隐式调用的时候使用 下面去A工程中写调用的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MainActivity extends AppCompatActivity { /** * 是否绑定了远程服务 */ private boolean isStartRemote; private ILoginInterface mILoginInterface; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initBinderService(); } /** * 通过隐示意图绑定B应用的service */ private void initBinderService() { Intent intent = new Intent(); //设置action intent.setAction(\"BinderB_Action\"); //设置B应用的包名 intent.setPackage(\"com.chs.binderb\"); //绑定服务 bindService(intent,cnn,BIND_AUTO_CREATE); isStartRemote = true; } ServiceConnection cnn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { //绑定成功，可以使用服务端的方法了 mILoginInterface = ILoginInterface.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { } }; public void startWeiXinLogin(View view) { if(mILoginInterface!=null){ try { mILoginInterface.login(); } catch (RemoteException e) { e.printStackTrace(); Toast.makeText(this,\"请先安装微信\",Toast.LENGTH_SHORT).show(); } } } @Override protected void onDestroy() { super.onDestroy(); if(isStartRemote){ unbindService(cnn); } }} 布局样式就是前面gif图中的样式，微信图标的点击方法是startWeiXinLogin方法。里面调用了ILoginInterface的login方法 先说一下ILoginInterface 当我们创建好AIDL文件，重新Rebuild一下工程之后，系统会给我们生成一个ILoginInterface文件，位置在 app\\build\\generated\\aidl_source_output_dir\\debug\\compileDebugAidl\\out\\com\\chs\\binderb\\ILoginInterface.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/* * This file is auto-generated. DO NOT MODIFY. * Original file: D:\\\\android\\\\A1\\\\BinderA\\\\app\\\\src\\\\main\\\\aidl\\\\com\\\\chs\\\\binderb\\\\ILoginInterface.aidl */package com.chs.binderb;public interface ILoginInterface extends android.os.IInterface { /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.chs.binderb.ILoginInterface { private static final java.lang.String DESCRIPTOR = \"com.chs.binderb.ILoginInterface\"; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.chs.binderb.ILoginInterface interface, * generating a proxy if needed. */ public static com.chs.binderb.ILoginInterface asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.chs.binderb.ILoginInterface))) { return ((com.chs.binderb.ILoginInterface) iin); } return new com.chs.binderb.ILoginInterface.Stub.Proxy(obj); } @Override public android.os.IBinder asBinder() { return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_login: { data.enforceInterface(descriptor); this.login(); reply.writeNoException(); return true; } case TRANSACTION_loginCallBack: { data.enforceInterface(descriptor); boolean _arg0; _arg0 = (0 != data.readInt()); java.lang.String _arg1; _arg1 = data.readString(); this.loginCallBack(_arg0, _arg1); reply.writeNoException(); return true; } default: { return super.onTransact(code, data, reply, flags); } } } private static class Proxy implements com.chs.binderb.ILoginInterface { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public void login() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_login, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } @Override public void loginCallBack(boolean isSuccess, java.lang.String user) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(((isSuccess) ? (1) : (0))); _data.writeString(user); mRemote.transact(Stub.TRANSACTION_loginCallBack, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } } static final int TRANSACTION_login = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_loginCallBack = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); } public void login() throws android.os.RemoteException; public void loginCallBack(boolean isSuccess, java.lang.String user) throws android.os.RemoteException;} 它继承了IInterface接口，所有可以在Binder中传输的接口都需要继承IInterface接口。同时它自己也是一个接口。 它声明了两个方法login()和loginCallBack就是我们在AIDL文件中写的两个方法。同时声明了两个整形id：TRANSACTION_login和TRANSACTION_loginCallBack来标识这两个方法。在onTransact方法中通过这两个id来识别客户端请求的是哪个方法 它内部有一个内部类Stub，这个就是一个Binder，跨进程通信的过程就由它的内部代理Proxy完成，它里面有几个重要的方法 asInterface 用于将服务端的Binder对象转化成客户端可以使用的AIDL接口类型的对象。这个转化是分进程的，如果客户端和服务端在同一个进程中就返回Stub本身，如果是在不同的进程中，就返回Stub.Proxy(obj)代理对象 asBinder 返回当前的Binder对象 onTransact 这个方法时重写的Binder类中的onTransact方法。它运行在服务端的Binder线程池中，远程客户端发起请求时，请求会经过系统包装后交给该方法来处理。它通过不同的code来判断调用哪个方法。然后执行方法并写入返回值 Proxy#login 这个方法运行在客户端，前面的MainActivity中我们调用asInterface方法其实就是拿到了这个Proxy对象，所以我们就能调用它的login方法，当客户端调用该方法的时候创建输入的Parcel对象_data和输出的Parcel对象 _reply，然后调用transact方法来发起远程调用请求，然后当前线程挂起，之后服务端的onTransact方法会被调用，直到完成并返回结果 Proxy#loginCallBack 和上面的login方法一样。 OK 现在回到MainActivity中，在onCreate方法中通过隐式的调用绑定B应用中的服务。 这样点击按钮的时候，B应用中的LoginService的onBind方法就会调用，然后就会打开登录的Activity。 到这里其实A到B的跨进程通信就已经完成了，但是我们在B应用中点击输入用户名和密码如果成功或者失败，应该反馈给A应用啊，怎么反馈呢。 方法就是跟A找B通信时一样的道理，在A中也写一个Service，让B去绑定A中的Service,执行完登录之后，调用A的远程方法。 代码如下1234567891011121314151617public class LoginService extends Service { @Nullable @Override public IBinder onBind(Intent intent) { return new ILoginInterface.Stub() { @Override public void login() throws RemoteException { } @Override public void loginCallBack(boolean isSuccess, String user) throws RemoteException { Log.i(\"登录情况\",\"状态:\"+isSuccess+\"&gt;&gt;&gt;&gt;&gt;user:\"+user); } }; }} A中也写一个LoginService，在回调方法中打印一下回调状态和用户名，并在AndroidMasfet.xml中注册 B中模拟登录并调用A中服务的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class MainActivity extends AppCompatActivity { private static final String NAME = \"chs\"; private static final String PWD = \"123\"; private EditText etName; private EditText etPwd; /** * 是否绑定了远程服务 */ private boolean isStartRemote; private ILoginInterface mILoginInterface; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etName = findViewById(R.id.et_name); etPwd = findViewById(R.id.et_pwd); initBinderService(); } /** * 通过隐示意图绑定A应用的service */ private void initBinderService() { Intent intent = new Intent(); //设置action intent.setAction(\"BinderA_Action\"); //设置B应用的包名 intent.setPackage(\"com.chs.bindera\"); //绑定服务 bindService(intent,cnn,BIND_AUTO_CREATE); isStartRemote = true; } ServiceConnection cnn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { //绑定成功，可以使用服务端的方法了 mILoginInterface = ILoginInterface.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { } }; public void qqLogin(View view) { final String name = etName.getText().toString(); final String pwd = etPwd.getText().toString(); //ProgressDialog dialog = new ProgressDialog(this); //dialog.setTitle(\"正在登录\"); new Thread(){ @Override public void run() { super.run(); SystemClock.sleep(1000); runOnUiThread(new Runnable() { @Override public void run() { boolean isSuccess = false; if(name.equals(NAME)&amp;&amp;pwd.equals(PWD)){ isSuccess = true; showToast(\"登录成功\"); finish(); }else { showToast(\"登录失败\"); } try { mILoginInterface.loginCallBack(isSuccess,name); } catch (RemoteException e) { e.printStackTrace(); } } }); } }.start(); } private void showToast(String text) { Toast.makeText(this,text,Toast.LENGTH_SHORT).show(); } @Override protected void onDestroy() { super.onDestroy(); if(isStartRemote){ unbindService(cnn); } }} OK代码完成，运行之后就是前面gif中的效果了。A中LoginService中的回调打印如下。 122019-07-10 21:51:27.225 10173-10191/com.chs.bindera:remote_a I/登录情况: 状态:false&gt;&gt;&gt;&gt;&gt;user:2019-07-10 21:51:35.343 10173-10191/com.chs.bindera:remote_a I/登录情况: 状态:true&gt;&gt;&gt;&gt;&gt;user:chs","link":"/2019/07/13/architecture/Binder机制/"},{"title":"Gradle之Groovy","text":"Gradle之Groovy 作为一名Android开发者，每天使用AndroidStudio,对于项目中build.gradle文件肯定不陌生，里面有各种各样的配置。对于一些常用的配置我们肯定烂熟于心，不过有时候去看一些大厂的代码的时候，经常会发现他们的项目中有很多的gradle的代码，我们往往因为不了解这些而对了解优秀的项目而带来一些障碍。 百度百科：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 1 DSL语言介绍domain specific language(领域特定语言 ) DSL语言特点：解决计算机某一特定领域的问题 核心思想：求专不求多 我们常见的UML,XML,HTML等都是DSL语言，他们都是专注于特定的领域来解决特定的问题。比如HTML就是为了布局UI。因为专注，所以有很多优点比如代码少，效率高。 2 groovy语言啥是groovy groovy是一种基于JVM的敏捷开发语言 结合了Python Ruby Smalltalk等语言的强大特性 groovy可以和Java完美结合，可以使用Java所有的类库，也能用于扩展现有代码。 groovy的特性 语法上支持动态类型，闭包等新一代语言的特性 可以无缝集成左右已经存在的Java的类库 即支持面向对象编程，也支持面向过程编程 groovy的优势 它是一种更加敏捷的编程语言，可以用更少的代码完成Java同样的功能 对于Java程序员来说，入门容易，功能强大 即可以作为编程语言，也可以作为脚本语言 3 groovy环境搭建官网：http://www.groovy-lang.org/ https://groovy.apache.org/download.html 安装JDK 到官网下载groovySDK,解压到合适位置 配置环境变量 无论mac/linux还是window都是这三步只不过每个平台上的步骤不一样，学啥语言的都跑不过这几步。 4 Hello Groovy学习一个语言基本都是从Hello World开始 开发一个Groovy程序可以使用intellij idea这个编译器，https://www.jetbrains.com/idea/ 直接去官网下载社区版就可以了，社区版支持Groovy程序的开发。 Groovy和Java完全兼容，所以我们完全可以使用Java代码来编写Groovy程序 在intellij idea中新建一个Groovy程序（在新建项目面板的右上角，Groovy library选项中添加下载的groovySDK的路径），在src文件夹下面新建一个Groovy的class类，写下面Java代码12345class GroovyTest { public static void main(String[] args){ System.out.print(\"Hello Groovy\"); }} 可以直接运行，输出： Hello Groovy 不过我们是来学Groovy语言的，当然用Groovy来写会更简单，简单到啥程度呢，把上面代码全删了，写下面一句。1print(\"Hello Groovy\") 直接运行 输出：Hello Groovy 看起来很爽啊！ 5 Groovy 语法练习5.1 变量groovy中的变量包括 基本类型 ，对象类型，不过groovy中所有类型都是对象类型。基本类型也会被自动装箱成对象类型比如：1234int a = 2;print(a.class)输出结果：class java.lang.Integer 变量的定义： 定义一个变量不仅可以使用强类型定义，也可以使用弱类型定义。比如即可以使用int,double这些来修饰一个变量，也可以直接用def来修饰一个变量，使用def修饰，系统会自动推导类型，比如：1234567891011def b = 3println b.classdef c = 3.14println c.classdef d = \"groovy\"println d.class输出结果：class java.lang.Integerclass java.lang.Integerclass java.math.BigDecimalclass java.lang.String 一般情况下，如果我们是自己在写一个程序，使用def来定义一个变量会很简单，如果程序还需要提供给外部人员使用，那使用强类型来定义比较好，不然外部人员可能会比较疑惑需要传什么类型的变量。 5.2 字符串Java中是String Groovy中是GString 5.2.1 Groovy常用的定义方式： 使用单引号def name1 = 'i am name1'效果和java中一模一样（不可扩展） 使用三个引号def name = '''i am name''',使用三个引号的字符串我们可以在字符串内部保留字符串的格式，比如可以随便换行 使用双引号定义字符串 def name3 = &quot;i am name3&quot;（可扩展） 12345678910111213141516171819202122232425def name1 = 'i am name1'def name2 = '''i am name2hello name2hai name2'''println(name2)def name3 = \"i am name3\"def name4 = \"${name3} 哈哈\"println(name4)//${}中可以是任意的表达式，比如def sum = \"2加3=${2+3}\"println(sum)println(name3.class)println(sum.class)输出：i am name2hello name2hai name2i am name3 哈哈2加3=5class java.lang.Stringclass org.codehaus.groovy.runtime.GStringImpl 从上面的输出内容还可以看出：一个双引号定义的字符串的类型是java.lang.String，当经过${}符号运算过之后变成了org.codehaus.groovy.runtime.GStringImpl类型。虽然类型变了，在平时的程序中这两个类型一般可以互相使用。 5.2.2 GString的操作符GString的操作符比Java中的String中的方法多，只要来源是： java.long.String DefaultGroovyMethods StringGroovyMethods（继承DefaultGroovyMethods）包括普通类型的参数和闭包类型的参数 常用的普通类型参数： 12345678910111213141516171819202122232425def str = \"hello groovy\"def str1 = \"hello\"def str2 = \"123\"println(str.center(15,'a'))//总长度15，在原字符串两端加aprintln(str.padLeft(15,'a'))//总长度15，在原字符串左边加aprintln(str&gt;str1)println(str[0])println(str[0..1])println(str.reverse())println(str.capitalize())println(str2.isNumber())println(str2.toInteger())输出：ahello groovyaaaaahello groovytruehheyvoorg ollehHello groovytrue123 5.3 逻辑控制switch/case 和java中不一样 比java中更强大 123456789101112131415161718192021def x = 12def resswitch (x){ case 'string': res = 'string' break case [3,4,5,6,\"haha\"]://列表类型 res = 'string' break case Integer: res = 'Integer' break case BigDecimal: res = 'BigDecimal' break case 9..30: //表示一个范围 res = 'string' break default: 'default'}println(res) for循环12345678910111213//循环一个范围for (i in 0..9){ println(i)}//循环一个listfor (i in [3,4,5,6,7,8,9,0]){ println(i)}//循环一个mapfor (i in [\"lily\":18,\"divad\":19,\"xiaoming\":20]){ println(i.key) println(i.value)} while循环、if/else和java中一样 5.4 闭包闭包是groovy最强大的功能之一 5.4.1 闭包的概念：就是一个代码块闭包的定义和调用：1234def closure = {println \"hello groovy\"}//两种调用的方法closure.call()closure() 闭包的参数：1234def closure2 = { println \"hello ${it}\"}closure2(\"groovy\")def closure1 = {String name,int age -&gt; println \"hello ${name},age ${age}\"}closure1(\"groovy\",15) 会有一个默认的参数，可以使用it这个关键字来接收，如果有多个参数可以使用-&gt;来隔开 闭包的返回值123def closure2 = { return \"hello ${it}\"}def b = closure2(\"groovy\")println(b) 如果不定义return，默认返回的是null 5.4.2 闭包的使用闭包与基本类型结合使用： 常用方法：12345678910111213141516171819202122232425def x = 5//求阶乘def jiecheng(int num){ int res = 1 //upto里面实现了循环 1.upto(num,{n -&gt; res*=n}) return res}//求阶乘def jiecheng1(int num){ int res = 1 num.downto(1){ n -&gt; res *= n } return res}//累加def leijia(int num){ int res = 1 num.times {n -&gt; res +=n} return res}println(jiecheng(x))println(jiecheng1(x))println(leijia(5)) 闭包与字符串结合使用： 常用方法12345678910111213def str = 'hello groovy 1 2 3'//each 遍历str.each { String tem -&gt; println(tem.capitalize()) }//找到第一个满足条件的 并返回println str.find{ String tem -&gt; tem.isNumber()}//找到所有满足条件的 并返回println str.findAll(){ String tem -&gt; tem.isNumber()}//只要字符串中存在数字 就返回trueprintln str.any{ String s -&gt; s.isNumber()}//字符串每个元素都是数字 就返回trueprintln(str.every {String s -&gt; s.isNumber()})//搜集所有字符 并大写 放到list中返回println str.collect {String s -&gt; s.toUpperCase()} 5.4.3 闭包的进阶闭包关键变量 this， owner，delegate 12345678910def clouser = { println(\"this:\" + this) println(\"owner:\" + owner) println(\"delegate:\" + delegate)}clouser.call()输出：this:GroovyTest@741a8937owner:GroovyTest@741a8937delegate:GroovyTest@741a8937 从打印来看都是一样的，那他们有什么区别呢？ this：代表闭包定义处的类 owner：代表闭包定义处的类或者对象 delegate：代表任意对象 默认是owner 12345678910111213def outClouser = { def innerClouser = { println(\"this:\" + this) println(\"owner:\" + owner) println(\"delegate:\" + delegate) } innerClouser.call()}outClouser.call()输出：this:GroovyTest@306e95ecowner:GroovyTest$_run_closure1@43dac38fdelegate:GroovyTest$_run_closure1@43dac38f 闭包的委托策略： delegate可以动态的改变，改变之后可以让一个对象指向另一个对象。 123456789101112131415161718class Teacher{ String name def nameStr = {\"my name is ${name}\"} @Override String toString() { return nameStr.call() }}class Student{ String name}Teacher teacher = new Teacher(name: \"teacher\")Student student = new Student(name: \"student\")teacher.nameStr.delegate = studentteacher.nameStr.resolveStrategy = Closure.DELEGATE_FIRSTprintln teacher.toString()输出：my name is student 5.5 常用的数据结构5.5.1 列表列表的定义 1234567//java的方式定义def list = new ArrayList()//groovy的方式定义 它默认也是一个ArrayListdef list1 = [1,2,3]//定义一个数组def arr = [1,2,3] as int[]int[] arr1 = [1,2,3] 列表的操作 增删 123456789101112def list = [3,2,4,1,5,9,7,8]list.add(0)//追加list.leftShift(6)//追加list &lt;&lt; 6//删除//list.remove(1)//list.removeAt(1)//删除所有偶数list.removeAll {return it%2==0}println(list) 排序操作 1234567891011121314151617181920212223242526272829303132333435//java中的排序----------def sortList = [3,5,2,1,-3,-6,-4]//Collections.sort(sortList)//println(sortList)//自定义排序规则//Comparator comparator = {a,b-&gt;a==b?0:Math.abs(a)&gt;Math.abs(b)?1:-1}//Collections.sort(sortList,comparator)//println(sortList)//groovy中的排序-----------sortList.sort()//自定义排序规则sortList.sort(){a,b-&gt;a==b?0:Math.abs(a)&gt;Math.abs(b)?1:-1}println(sortList)//字符串列表def stringList = ['hello','ab','a','cde','groovy']stringList.sort(){it -&gt; return it.size()}println(stringList)def findList = [5,6,3,2,1,9,8]//查找第一个奇数def res = findList.find(){return it%2 == 1}//查找所有的奇数def res1 = findList.findAll(){return it%2 == 1}//判断是否有奇数def res2 = findList.any(){return it%2 == 1}//判断是不是全是奇数def res3 = findList.every(){return it%2 == 1}println(res3)println(findList.min())println(findList.max())println(findList.min{return Math.abs(it)})//统计查找偶数的个数def num = findList.count{ return it%2==0 }println(num) 5.5.1 MapMap的定义和使用 123456789101112//java方式def map = new HashMap()//groovy方式 def map1 = ['lily':15,'jack':16,'divad':17]//查找元素println(map1['lily'])//添加元素map1.xiaoming = 18println(map1.toMapString())//添加不同类型的元素map1.sub = ['a':1,'b':2]println(map1.toMapString()) groovy中的Map默认是Java中LinkedHashMap Map的常用操作1234567891011121314151617181920212223def map = ['lily':15,'jack':16,'divad':17,'xiao':14]//遍历map.each {def person -&gt; println \"key:${person.key} value:${person.value}\"}map.each {key,value -&gt; println \"key:${key} value:${value}\"}//有下标的遍历map.eachWithIndex {def person ,int index -&gt; println \"key:${person.key} value:${person.value} index:${index}\"}map.eachWithIndex{key,value,index -&gt; println \"key:${key} value:${value} index:${index}\"}//查找第一个年龄大于15的def res = map.find{def person -&gt; person.value&gt;15}//查找所有年龄大于15的def res1 = map.findAll{def person -&gt; person.value&gt;15}//统计大于年龄15的个数def num = map.count {return it.value&gt;15}//查找并分组def group = map.groupBy {return it.value&gt;15?'man':'child'}println(group.toMapString())//排序def sort = map.sort{ def v1,def v2 -&gt; return v1.value == v2.value?0:v1.value&gt;v2.value?1:-1}println(sort) 5.6 范围 RangeRange是一个轻量级的list，在有些简单的地方使用会比list更加方便 Range的定义和使用 1234567891011121314151617181920212223242526def range = 1..10println(range[0])println(range.from)println(range.to)println(range.contains(11))range.each {println(it)}for (i in range) { println(i)}def res = getGrade(85)println(res)def getGrade(int num){ def result switch (num){ case 0..60: result = '及格' break case 60..80: result = '良好' break case 80..100: result = '优秀' break } return result} 5.7 面向对象类默认都是public的 12345678910111213141516171819202122232425interface IAction { void eat() void drink()}class Person implements IAction{ String name int age def increaseAge(int num){ this.age += num } @Override void eat() { } @Override void drink() { }}def person = new Person(name: 'lily',age: 15)person.increaseAge(10)println(\"name: ${person.name} age: ${person.age}\") groovy中元编程 当调用一个类的方法的时候： 该类中是否有此方法 有直接调用，没有去MetaClass中查找是否有 MetaClass中有调用MeatClass中的方法，没有看是否重写了methodMissing()方法，写了调用该方法，没写，看是否重写了invoke()方法 写了自行invoke方法，没写抛出异常（MissingMethodExecption） 动态添加属性或者方法，可以扩展一些引入的第三方包中的类 1234567891011121314151617def person = new Person(name: 'lily',age: 15)person.increaseAge(10)person.cry()//给一个类动态注入一个属性Person.metaClass.sex = 'male'def person1 = new Person(name: 'lily',age: 15)println(person1.sex)//给一个类动态添加一个方法Person.metaClass.sexUpperCase = { -&gt; sex.toUpperCase()}def person2 = new Person(name: 'lily',age: 15)println(person2.sexUpperCase())//给一个类动态添加一个静态方法Person.metaClass.static.createPerson = { name,age -&gt; return new Person(name:name,age: age)}def person3 = Person.createPerson('lily',15)println(\"name:${person3.name}\") 6 Groovy高级语法6.1 groovy 对 json的操作groovy中自带的操作json的方式非常简单 123456789def list = [new Person(name: 'lily',age: 15),new Person(name: 'jack',age: 16)]//对象转成jsonString json = JsonOutput.toJson(list)println(json)//json转成对象def jsonSlurper = new JsonSlurper()println jsonSlurper.parseText(json)//parse方法有很多重载的方法，可传入不同的值jsonSlurper.parse() jsonSlurper.parse()方法有很多重载的方法，可传入不同的值 6.2 groovy处理xml解析xml的数据12345678910111213141516171819202122232425262728293031final String xml = '''&lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;Google Maps&lt;/name&gt; &lt;virsion&gt;1.0&lt;/virsion&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;2&lt;/id&gt; &lt;name&gt;Chrome&lt;/name&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;3&lt;/id&gt; &lt;name&gt;Google Play&lt;/name&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/app&gt;&lt;/apps&gt;'''def xmlSlurper = new XmlSlurper()//返回的是xml的根节点def apps = xmlSlurper.parseText(xml)println(apps.app[0].name.text())//深度遍历def res = apps.depthFirst().findAll { app -&gt; return app.name.text()}def res1 = apps.children().findAll { app -&gt; app.name() == 'app' }.collect { app -&gt; return app.name.text()}println(res)println(res1) 生成xml的数据12345678910111213141516171819202122import groovy.xml.MarkupBuilderdef sw = new StringWriter()def xmlBuilder = new MarkupBuilder()xmlBuilder.apps(type:'1'){ app(){ id(1) name('Google Maps') version(2.0) } app(){ id(2) name('Chrome') version(1.0) } app(){ id(3) name('Google Play') version(3.0) }}println(sw) 通过类自动生成xml1234567891011121314151617181920212223242526import groovy.xml.MarkupBuilderdef sw = new StringWriter()def xmlBuilder = new MarkupBuilder()class apps{ String type = '1' def apps = [new appsub(id: 1,name: 'Google Play',version: '1.0'), new appsub(id: 1,name: 'java',version: '2.0'), new appsub(id: 1,name: 'Google map',version: '3.0')]}class appsub{ int id String name String version}def apps = new apps()xmlBuilder.apps(type:apps.type){ apps.apps.each { sub -&gt; appsub(){ id(sub.id) name(sub.name) version(sub.version) } }}println(sw) 6.3 groovy处理文件所有java中的处理文件的方式都可以使用groovy中也有自己的封装的简单的方法 读取项目跟目录下的一个文件并遍历12def file = new File('../MyGroovy.iml')file.each {line -&gt; println(line)} 读取内容为一个text12def text = file.getText()println(text) 读取部分内容123456def reader = file.withReader { reader -&gt; char[] buffer = new char[100] reader.read(buffer) return buffer}println(reader) 文件写入12345678910111213141516171819202122232425262728def copy(String fromDir,String toDir){ try { //创建目标文件 def toFile = new File(toDir) if(!toFile.exists()){ toFile.createNewFile() } //开始copy def fromFile = new File(fromDir); if(fromFile.exists()){ fromFile.withReader { reader -&gt; def lines = reader.readLines() toFile.withWriter { write-&gt; lines.each { line-&gt; write.append(line + \"\\r\\n\") } } } } return true }catch (Exception e){ e.printStackTrace() } return false}def copres = copy('../MyGroovy.iml','../MyGroovy.iml2')println(copres) 对象的保存和读取1234567891011121314151617181920212223242526272829303132333435363738//保存对象def saveObject(Object obj,String path){ try { //创建目标文件 def toFile = new File(path) if(!toFile.exists()){ toFile.createNewFile() } toFile.withObjectOutputStream {out-&gt; out.writeObject(obj) } return true }catch (Exception e){ e.printStackTrace() } return false}//读取对象def readObj(String path){ def obj = null try { def file = new File(path) if(file==null||!file.exists()) return null file.withObjectInputStream { input-&gt; obj = input.readObject() } return obj }catch (Exception e){ e.printStackTrace() } return null}def person = new Person(name: '大海',age: 15)def res = saveObject(person,'../person.bin')println(res)def personRes = (Person)readObj('../person.bin')println(personRes.name)","link":"/2019/11/21/architecture/Gradle之Groovy/"},{"title":"Handler机制","text":"Handler机制 Handler在我们日常开发中会经常用到，它主要用于处理异步消息，当发出一个消息之后，首先进入到一个消息队列，发送消息的函数即可返回，而另外一个部分在消息队列中逐一取出，然后对消息进行处理。 虽然经常用到它，但是用的方式不正确也会产生一些问题，下面先来了解一些Handler相关的问题并解决 Handler造成内存泄漏Andorid中一般都是在子线程中执行耗时的业务逻辑，然后通过Handler发从消息到主线程中去更新UI。 当使用内部类或者匿名内部类创建一个Handler的时候，它会隐式持有外部对象的引用，一般是Activity，如果我们在耗时线程还没完成的时候关闭了Activity，这时候线程还在运行，线程持有handler的引用，handler持有Activity的引用，导致Activity无法被回收从而造成内存泄漏。 另外，如果我们使用了 handler.postDelayed()方法，它会把Handler封装成一个Message对象，并把Message对象放入MessageQueue队列中，那么在延时时间到达之前，会有一个引用持有的链：MessageQueue-&gt;Message-&gt;Hanlder-&gt;Activity。从而导致Activity无法被回收，造成内存泄漏 解决办法： 在Activity的onDestroy方法中把线程停掉，把Handler直接制空，在使用Hanlder的地方先判断是否为空在执行后面的逻辑 将Hanlder设置为静态对象，Java中静态类不会持有外部类的引用，Activity就可以被回收了。不过这时候由于Handler不在持有Activity的引用也就不能更新UI了，这时候需要把Activity传入Handler中，Handler中使用弱引用保存Activity来保证Activity可以被回收。 为什么不能直接在子线程中创建空构造函数的Handler在子线程中直接new一个Handlernew Handler()会出错1java.lang.RuntimeException: Can&apos;t create handler inside thread[Thread..] that has not called Looper.prepare() 这是为什么呢？我们可以跟进代码看一下1234567891011121314151617public Handler() { this(null, false);}public Handler(Callback callback, boolean async) { .... mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;} 可以看到当mLooper为null的时候就会派出这个异常，也就是Looper.myLooper()这个方法返回null，它为什么会为null，跟进代码中12345static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); public static @Nullable Looper myLooper() { return sThreadLocal.get(); } 可以看到它是去ThreadLocal中去取这个looper，ThreadLocal相当与一个Map，key是当前线程，值就是looper，在子线程中直接new一个Handler,如果该线程在ThreadLocal中没有对象的looper那就会报错了 那主线程中为什么可以直接new呢，当然是主线程中已经在ThreadLocal中设置好了对应的looper对象了。我们知道Activity的主函数是在在ActivityThread类中，在ActivityThread的main方法中，可以看到这句话123456789101112131415161718192021222324 Looper.prepareMainLooper(); public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); } }private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); }public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } 可以看到在prepare方法中就给ThreadLocal中放置了Looper，key就是当前线程 我们可以给Hanlder传入一个Looper来防止出错比如 new Handler(Looper.getMainLooper());或者在new Handler之前调用Looper.prepare(); textview.setText()这句代码只能在主线程中执行吗？做我们大Android开发的都知道，不能再子线程中更新UI，但是如果我们new一个Thread在其run方法中调用textview.setText()方法，我们会发现竟然成功了并且不会报错，这是为什么呢？ 在我们setText刷新布局的时候，会执行到checkForRelayout()方法，这个方法最后会执行 requestLayout()和invalidate()方法来请求重新布局和重新绘制，跟进这两个方法会发现最后分别会来到ViewRootImpl这个类的requestLayout()这里面会有一个checkThread()方法。1234567891011121314151617181920212223242526272829private void checkForRelayout() { ... requestLayout(); invalidate();}//View中的requestLayout()public void requestLayout() { ... //mParent其实就是ViewRootImpl if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) { mParent.requestLayout(); } ...}//ViewRootImpl 中的requestLayout() @Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } }void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); } } checkThread()里面就会判断当前线程是不是主线程，如果不是就会抛出这个异常了。 为什么setText()不会抛这个异常呢，因为mThread是在是在ViewRootImpl的构造方法中赋值的，而ViewRootImpl 是在Activity 对象被创建完毕后才会被创建，而requestLayout()方法被调用之前都会判断一下ViewRootImpl是否为null，不为null才会执行。 如果setText()方法速度够快，在ViewRootImpl没有被创建之前就完成刷新，就不会报错了。 123456789final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { ... ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } ... } 所以如果我们setText的执行速度比创建ViewRootImpl的速度快，就不会执行到检查线程的方法了。就会绘制成功 new Handler()的两种写法有什么不同？两种写法123456Handler mHandler1 = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { return false; } }); 123456Handler mHandler2 = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); }}; 如果把这两个方法在写在AndroidStudio中会看到第二种方法会报黄色警告，所以推荐第一种写法。在Hanlder的dispatchMessage方法中123456789101112public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} msg.callback 其实就是一个 Runnable ，handleCallback(msg)方法其实就是执行它的run方法。如果mCallback不为null，就会执行它的handleMessage方法，这个mCallback就是第一种方法传过来的Callback。当前面两种情况都不成立的时候才会执行handleMessage它自己的方法。 第二种方法相当于创建了一个Handler的子类，并实现了父类的handleMessage方法。第一种方法相当于创建了一个Handler对象，传入一个回调。 ThreadLocal的原理1public class ThreadLocal&lt;T&gt; {......} ThreadLocal是一个本地线工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用 ThreadLocal相当于一个Map，它的key是当前线程，它的value是T，我们可以指定任意类型来保存。 12345678910111213public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } get()方法，首先通过当前线程去ThreadLocalMap中拿到ThreadLocalMap&lt;ThreadLocal, Object&gt;，然后通过当前ThreadLocal拿到值。如果拿不到调用setInitialValue()方法。12345678910private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } 这里面使用initialValue方法获取value然后保存，initialValue方法默认返回null，可以通过子类来实现需要保存的对象。12345678public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } set方法也是通过当前线程拿到ThreadLocalMap&lt;ThreadLocal, Object&gt;,然后把值存放到ThreadLocalMap中。如果ThreadLocalMap为空就创建一个 Handler源码分析Handler源码中主要有四个重要的对象Handler Looper Message MessageQueue （1）创建主线程Looper 12345678910111213141516171819 Looper.prepareMainLooper();static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); } } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 在ActivityThread类的main方法中调用Looer的静态方法prepareMainLooper，创建了一个Looper并放入ThreadLocal中保存。前面已经了解到每个线程都有自己的ThreadLocal，保存自己的私有变量，这里ActivityThread就是主线程中。1234private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 创建Looper的时候，创建了一个私有的消息队列 （2）创建Handler 123456Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; 这一步我们都很熟练了，在handleMessage中处理消息，看一下Handler的构造方法123456789101112131415161718public Handler() { this(null, false); }public Handler(Callback callback, boolean async) { ...... mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } public static @Nullable Looper myLooper() { return sThreadLocal.get(); } 拿到当前线程的Looper对象，把Looper中的消息队列赋值给自己的成员变量mQueue，如果传入了回调对象，给回调对象mCallback复制。 （3）发送消息 发送消息有好几方法 sendMessage，sendEmptyMessage，sendEmptyMessageDelayed，sendMessageAtTime等，最终都会进入下面的方法中调用enqueueMessage方法12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } enqueueMessage从名字就可以看出，是消息入队，mQueue就是前面从Looper中拿到的队列1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 这里把自己也就是Hanlder赋值给Message中的target，后面通过这个Handler的引用调用处理消息的方法。然后调用消息队列MessageQueue的入队方法123456789101112131415161718192021222324252627boolean enqueueMessage(Message msg, long when) { ... Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } ...} 可以看到Message是一个链表结构，这里把消息放入到链表的next中。 （4）消费消息 回到ActivityThread 的main方法中，在调用完Looper.prepareMainLooper();之后，又调用了Looper.loop();方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try { msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (slowDispatchThresholdMs &gt; 0) { final long time = end - start; if (time &gt; slowDispatchThresholdMs) { Slog.w(TAG, \"Dispatch took \" + time + \"ms on \" + Thread.currentThread().getName() + \", h=\" + msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what); } } if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); } msg.recycleUnchecked(); } } 上面的代码中，拿到当前线程的Looper，然后拿到Looper中的消息队列，然后开启一个死循环，通过Message msg = queue.next();不断取出消息然后调用msg.target.dispatchMessage(msg);方法处理消息。 前面enqueueMessage方法中我们知道msg.target就是Handler对象。所以这里调用的就是Handler中的dispatchMessage方法123456789101112public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 这里面有三个处理消息的方式，第二个和第三个分别对应文章开头的的两种创建Handler的方式。第一个msg.callback是啥呢，我们去Message中看到他是一个Runnable对象123456789101112131415handler.post(new Runnable() { @Override public void run() { } }) public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); }private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } 当我们调用handler.post()方法的时候，传入一个Runnable对象，其实就是我们传入的这个Runnable。 OK，Handler的流程分析完毕。 手写Handler练习前面已经了解了Handler原理，如果能手写一个简单的Handler那就真的掌握啦，现在就开始写一个吧 根据前面的分析，可以知道这里涉及到了几个类，ActivityThread,Message,MessageQueue,Handler,Looper。 因为Activity在启动后ActivityThread这个类的main方法就已经执行完了 所以我们直接在工程的test文件夹下面创建一个ActivityThread来模拟Activity的入口。 12345678910111213141516171819202122232425262728293031public class ActivityThread { @Test public void main(){ //准备looper Looper.prepareMainLooper(); //创建Handler final Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); //处理消息 System.out.println(msg.obj.toString()); } }; //开启一个线程 从子线程中发送消息 new Thread(){ @Override public void run() { super.run(); //发从消息 Message msg = new Message(); msg.obj = \"Hello Handler\"; handler.sendMessage(msg); } }.start(); //开启循环 Looper.loop(); }} 很简单就按照之前分析的四步来，(1)准备Looper，(2)创建Handler重写handleMessage方法处理消息，(3)发送消息，(4)开启循环处理消息。 Message类：123456789101112131415public class Message { public int what; public Handler target; /** * 消息对象 */ public Object obj; @Override public String toString() { return obj.toString(); }} MessageQueue类，使用一个阻塞队列ArrayBlockingQueue来模拟。12345678910111213141516171819202122public class MessageQueue { private ArrayBlockingQueue&lt;Message&gt; mMessages = new ArrayBlockingQueue&lt;Message&gt;(50); //消息入队 public void enqueueMessage(Message msg) { try { mMessages.put(msg); } catch (InterruptedException e) { e.printStackTrace(); } } //取消息 public Message next() { try { return mMessages.take(); } catch (InterruptedException e) { e.printStackTrace(); } return null; }} Looper类123456789101112131415161718192021222324252627282930313233343536public class Looper { static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); MessageQueue mQueue; public Looper() { mQueue = new MessageQueue(); } public static void prepareMainLooper() { prepare(); } private static void prepare() { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper()); } public static Looper myLooper() { return sThreadLocal.get(); } //开启循环 public static void loop() { Looper me = myLooper(); MessageQueue queue = me.mQueue; while (true){ Message msg = queue.next(); if(msg!=null){ if(msg.target!=null){ msg.target.dispatchMessage(msg); } } } }} OK完成啦，在ActivityThread这个测试类中直接运行代码可以看到日志中输出 Hello Handler 成功！","link":"/2019/07/07/architecture/Handler原理/"},{"title":"LeakCanary原理","text":"LeakCanary原理 前言Leakcanary是由Square公司开源的一款轻量的第三方检测内存泄露的工具 主要原理 watch一个即将要销毁的对象，比如监控一个activity处于什么状态。 先来看一下java内存中几个比较重要的部分 栈(stack) 存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中 堆(heap) 主要存放用new产生的数据，是垃圾回收器主要回收的部分 方法区 存储每个类的信息（包括类的名称、方法信息、字段信息）静态变量、常量以及编译器变异后的的代码等 为什么会产生内存泄露 当一个对象已经不再使用了，本应该回收，但是一个能到达GCRoot的对象还持有它的引用，导致它无法被回收，还停留在堆内存中，导致内存泄漏 LeakCanary原理： 当一个Activity Destory之后，将它放在一个WeakReference弱引用中中 把这个WeakReference关联到一个ReferenceQueue 查看ReferenceQueue中是否存在Activity的引用 如果Activity泄露了，就Dump出heap信息，然后去分析内存泄露的路径 java中的4中引用类型 强引用：不会被GC回收 软引用：内存不足的时候会被GC回收 弱引用：当下次GC的时候会回收 虚引用：任何情况都可以回收 ReferenceQueue 引用队列 软引用和弱引用都可以和它集合使用，如果软引用或者弱引用中的对象被垃圾回收了，java虚拟机会吧这个引用加入到与之关联的引用队列当中。 LeakCanary源码分析一般是在Application的onCreate方法中初始化12345678@Override public void onCreate() { super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) { return; } LeakCanary.install(this); } 进入install方法12345public static @NonNull RefWatcher install(@NonNull Application application) { return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall(); } 返回一个RefWatcher对象，这个对象是用来监视应该成为弱引用的对象。最终通过buildAndInstall()这个方法创建出来。12345678910111213141516171819202122public @NonNull RefWatcher buildAndInstall() { if (LeakCanaryInternals.installedRefWatcher != null) { throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\"); } RefWatcher refWatcher = build(); //如果是在别的进程中，会跟DISABLED相等 if (refWatcher != DISABLED) { if (enableDisplayLeakActivity) { LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); } //默认为true if (watchActivities) { ActivityRefWatcher.install(context, refWatcher); } //默认为true if (watchFragments) { FragmentRefWatcher.Helper.install(context, refWatcher); } } LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher;} 通过build方法创建出RefWatcher，如果是别的进程，就直接返回成员变量DISABLED，如果不是创建新的RefWatcher并返回。 如果允许显示内存泄露的Activity，就设置可显示，DisplayLeakActivity就是当有内存泄露的时候，LeakCanary给我们提供的可视化的那个界面 分别创建ActivityRefWatcher和FragmentRefWatcher，首先看ActivityRefWatcher.install方法123456789101112public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) { Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);}private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() { @Override public void onActivityDestroyed(Activity activity) { refWatcher.watch(activity); } }; 通过传入的context拿到Application ，并创建ActivityRefWatcher ，最后通过application注册Activity的生命周期回到函数，并传入自己的callback。ActivityLifecycleCallbacksAdapter继承自Android系统的Application.ActivityLifecycleCallbacks接口，主要为了简化代码，因为只用到了onActivityDestroyed这一个方法。这个接口是Andorid系统为我们提供的可以监听到每个Activity的生命周期。 在回调函数中可以看到，当监听到一个Activity销毁的时候，就通过refWatcher.watch(activity)方法把这个Activity关联到RefWatcher中。 在查看watch方法之前，先来看一下RefWatcher有哪些成员变量 1234567891011121314public final class RefWatcher { public static final RefWatcher DISABLED = new RefWatcherBuilder&lt;&gt;().build(); private final WatchExecutor watchExecutor; private final DebuggerControl debuggerControl; private final GcTrigger gcTrigger; private final HeapDumper heapDumper; private final HeapDump.Listener heapdumpListener; private final HeapDump.Builder heapDumpBuilder; private final Set&lt;String&gt; retainedKeys; private final ReferenceQueue&lt;Object&gt; queue; .... WatchExecutor： 用于执行内存泄露的检测 DebuggerControl： 判断是否是调试状态，调试状态是不用检测内存泄露的 GcTrigger： 用来处理GC，当检测到一个对象可能会内存泄露的时候，它会调用其中的方法在手动GC一下，看是否能回收这个对象，如果不能回收那这个对象就泄露了 HeapDumper： dump出内存泄露的堆文件 HeapDump.Listener： 用来分析产生heap文件的回调 HeapDump.Builder：HeapDump的构建者对象 Set： 集合，持有待检测的和已经产生内存泄露的引用的key ReferenceQueue： 判断弱引用所持有的对象是否执行了GC垃圾回收 OK，现在去查看watch方法 123456789101112131415161718public void watch(Object watchedReference) { watch(watchedReference, \"\"); }public void watch(Object watchedReference, String referenceName) { if (this == DISABLED) { return; } checkNotNull(watchedReference, \"watchedReference\"); checkNotNull(referenceName, \"referenceName\"); final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString(); retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); ensureGoneAsync(watchStartNanoTime, reference); } final class KeyedWeakReference extends WeakReference&lt;Object&gt; {} 创建了一个唯一key，然后放到成员变量set中保存，之后创建了一个KeyedWeakReference这个弱引用。用来保存需要分析的对象，最后执行异步方法ensureGoneAsync来分析这个弱引用对象。 1234567private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) { watchExecutor.execute(new Retryable() { @Override public Retryable.Result run() { return ensureGone(reference, watchStartNanoTime); } });} 在子线程中执行ensureGone方法来分析对象是否真的被回收了123456789101112131415161718192021222324252627282930313233343536373839404142Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) { long gcStartNanoTime = System.nanoTime(); //从我们调用watch方法到现在的总共使用的时间 long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); //清除set集合中 已经到达引用队列中的弱引用 removeWeaklyReachableReferences(); //如果在调试状态 就不需要分析 if (debuggerControl.isDebuggerAttached()) { // The debugger can create false leaks. return RETRY; } //改对象没有造成内存泄露 if (gone(reference)) { return DONE; } //手动调用GC gcTrigger.runGc(); //再次 清除set集合中 已经到达引用队列中的弱引用 removeWeaklyReachableReferences(); //如果此时引用集合set中还包含改对象，那么它就是个内存泄露的对象 if (!gone(reference)) { long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); //demp出一个 .hprof文件 File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) { // Could not dump the heap. return RETRY; } long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key) .referenceName(reference.name) .watchDurationMs(watchDurationMs) .gcDurationMs(gcDurationMs) .heapDumpDurationMs(heapDumpDurationMs) .build(); //分析内存泄露 heapdumpListener.analyze(heapDump); } return DONE;} 总结一下前面的代码： 创建一个RefWatcher并启动一个ActivityRefWatcher 通过ActivityLifecycleCallbacks接口，监听activity的回调，在onDestory中去将activity对象放入观察引用中去观察 先清除引用队列中的弱引用，接着检查对象是否到达引用队列，然后手动执行GC，如果GC完后还有未被回收的对象，调用analyze方法分析内存泄露 12345678910111213public interface Listener { Listener NONE = new Listener() { @Override public void analyze(HeapDump heapDump) { } }; void analyze(HeapDump heapDump); } @Override public void analyze(@NonNull HeapDump heapDump) { checkNotNull(heapDump, \"heapDump\"); HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass); } analyze是Listener接口中的一个方法，它的实现类是在ServiceHeapDumpListener中。最后调用了HeapAnalyzerService.runAnalysis方法。 123456789public static void runAnalysis(Context context, HeapDump heapDump, Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) { setEnabledBlocking(context, HeapAnalyzerService.class, true); setEnabledBlocking(context, listenerServiceClass, true); Intent intent = new Intent(context, HeapAnalyzerService.class); intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName()); intent.putExtra(HEAPDUMP_EXTRA, heapDump); ContextCompat.startForegroundService(context, intent); } HeapAnalyzerService 继承自 ForegroundService ， ForegroundService 继承自 IntentService，runAnalysis方法中就是开启了一个前台的IntentService。最后会执行IntentService的onHandleIntent方法，这里面又执行了抽象方法onHandleIntentInForeground，这个方法在HeapAnalyzerService类中实现。123456789101112131415@Override protected void onHandleIntentInForeground(@Nullable Intent intent) { if (intent == null) { CanaryLog.d(\"HeapAnalyzerService received a null intent, ignoring.\"); return; } String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA); HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA); HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses); AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey, heapDump.computeRetainedHeapSize); AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);} 从intent中拿到className和HeapDump，然后通过HeapAnalyzer这个类的checkForLeak方法进行分析。最后通过sendResultToListener方法返回。12345678910111213141516171819202122232425262728293031323334353637public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile, @NonNull String referenceKey, boolean computeRetainedSize) { long analysisStartNanoTime = System.nanoTime(); if (!heapDumpFile.exists()) { Exception exception = new IllegalArgumentException(\"File does not exist: \" + heapDumpFile); return failure(exception, since(analysisStartNanoTime)); } try { listener.onProgressUpdate(READING_HEAP_DUMP_FILE); //将heap文件封装成MemoryMappedFileBuffer HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile); //创建hprof解析器，解析hprof文件 HprofParser parser = new HprofParser(buffer); listener.onProgressUpdate(PARSING_HEAP_DUMP); //解析生成快照 Snapshot snapshot = parser.parse(); listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS); //去除重复的内容 deduplicateGcRoots(snapshot); listener.onProgressUpdate(FINDING_LEAKING_REF); //找到泄露对象 Instance leakingRef = findLeakingReference(referenceKey, snapshot); // False alarm, weak reference was cleared in between key check and heap dump. if (leakingRef == null) { String className = leakingRef.getClassObj().getClassName(); return noLeak(className, since(analysisStartNanoTime)); } //找到泄露对象的最短路径 return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize); } catch (Throwable e) { return failure(e, since(analysisStartNanoTime)); }} checkForLeak方法就是LeakCanary中的核心方法了，这里面用到了Square的另一个开源库haha库，地址 https://github.com/square/haha 通过HprofParser类将hprof转换为Snapshot内存快照。Snapshot中包含所有对象引用的路径，就能查找到内存泄露的路径了 优化GCRoot 通过deduplicateGcRoots方法删除重复的路径 findLeakingReference找出泄露的对象 findLeakTrace方法找出泄露对象的最短路径 findLeakingReference方法 1234567891011121314151617181920212223private Instance findLeakingReference(String key, Snapshot snapshot) { ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName()); if (refClass == null) { throw new IllegalStateException( \"Could not find the \" + KeyedWeakReference.class.getName() + \" class in the heap dump.\"); } List&lt;String&gt; keysFound = new ArrayList&lt;&gt;(); for (Instance instance : refClass.getInstancesList()) { List&lt;ClassInstance.FieldValue&gt; values = classInstanceValues(instance); Object keyFieldValue = fieldValue(values, \"key\"); if (keyFieldValue == null) { keysFound.add(null); continue; } String keyCandidate = asString(keyFieldValue); if (keyCandidate.equals(key)) { return fieldValue(values, \"referent\"); } keysFound.add(keyCandidate); } throw new IllegalStateException( \"Could not find weak reference with key \" + key + \" in \" + keysFound);} 在内存快照Snapshot中找到第一个弱引用KeyedWeakReference，这就是内存泄露的对象。 遍历这个对象的所有的实例 如果找到的key值和最开始保存的key值一样，那么这个对象就是内存泄露的对象 findLeakTrace方法 12345678910111213141516171819202122232425262728293031323334353637383940private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot, Instance leakingRef, boolean computeRetainedSize) { listener.onProgressUpdate(FINDING_SHORTEST_PATH); ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs); ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef); String className = leakingRef.getClassObj().getClassName(); // False alarm, no strong reference path to GC Roots. if (result.leakingNode == null) { return noLeak(className, since(analysisStartNanoTime)); } listener.onProgressUpdate(BUILDING_LEAK_TRACE); LeakTrace leakTrace = buildLeakTrace(result.leakingNode); long retainedSize; if (computeRetainedSize) { listener.onProgressUpdate(COMPUTING_DOMINATORS); // Side effect: computes retained size. snapshot.computeDominators(); Instance leakingInstance = result.leakingNode.instance; retainedSize = leakingInstance.getTotalRetainedSize(); // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer if (SDK_INT &lt;= N_MR1) { listener.onProgressUpdate(COMPUTING_BITMAP_SIZE); retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance); } } else { retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED; } return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize, since(analysisStartNanoTime)); } 通过findPath方法，GCroot开始往下寻找 LeakTrace就是内存泄露的调用栈 getTotalRetainedSize()方法，计算内存泄露的内存空间大小 OK Activity的监控流程就看完啦，下面看一下Fragment的。其实跟Activity差不多。从install开始 1234567891011121314151617181920212223242526public static void install(Context context, RefWatcher refWatcher) { List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;(); // 如果大于Anroid 26，需要增加AndroidOFragmentRefWatcher if (SDK_INT &gt;= O) { fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher)); } // 通过反射添加SupportFragmentRefWatcher try { Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME); Constructor&lt;?&gt; constructor = fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class); FragmentRefWatcher supportFragmentRefWatcher = (FragmentRefWatcher) constructor.newInstance(refWatcher); fragmentRefWatchers.add(supportFragmentRefWatcher); } catch (Exception ignored) { } if (fragmentRefWatchers.size() == 0) { return; } Helper helper = new Helper(fragmentRefWatchers); Application application = (Application) context.getApplicationContext(); application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks); } 通过反射找到SupportFragmentRefWatcher，它类需要在build.gradle中添加debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'加入引用。 最后注册ActivityLifecycleCallbacks，来监听activity的回调12345678private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { for (FragmentRefWatcher watcher : fragmentRefWatchers) { watcher.watchFragments(activity); } } }; 可以看到这里监听的是activity的onActivityCreated这个生命周期函数，然后把当前的activity的对象传入FragmentRefWatcher中,执行接口watchFragments。SupportFragmentRefWatcher和AndroidOFragmentRefWatcher是FragmentRefWatcher的实现类。最终会回调实现类的watchFragments方法1234@Override public void watchFragments(Activity activity) { FragmentManager fragmentManager = activity.getFragmentManager(); fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true); } 通过Activity找到FragmentManager，然后注册系统的Fragment的生命周期回调监听1234567891011121314private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks = new FragmentManager.FragmentLifecycleCallbacks() { @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) { View view = fragment.getView(); if (view != null) { refWatcher.watch(view); } } @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) { refWatcher.watch(fragment); } }; Fragment的回调主要监听了onFragmentViewDestroyed和onFragmentDestroyed两个回调方法。最终都会调用RefWatcher中的watch方法，这里面跟前面activity中是一样的啦。","link":"/2019/07/28/architecture/LeakCanary原理/"},{"title":"Hook式插件化","text":"Hook式插件化 上一篇文章中，通过Hook系统源码实现了不经过AndroidManifest注册也能跳转到对应Activity的功能。这一篇来分析一下怎么通过Hook的方式来实现插件化 从Android类加载的源码开始分析 本文是按照Android9.0源码来，不同系统可能不一样 我们平时跳转Activity的时候比如从MainActivity跳转到LoginActivity中，都是这么写12Intent intent = new Intent(this,LoginActivity.class);startActivity(intent); 其实还有一种方法，也是可以成功跳转的123Intent intent = new Intent();intent.setComponent(new ComponentName(\"com.hsm.hookplugin\",\"com.hsm.hookplugin.LoginActivity\"));startActivity(intent); 上一篇文章Hook进阶中我们已经实现了不经过AndroidManfiest注册就能正常跳转的功能，那如果我们直接传入一个插件包中的包名和类名可以可以完成跳转呢，直接写当然不行，因为我们不知道插件包在哪里，不过我们可以写一下，看看错误信息，然后根据错误信息继续分析 直接写插件包中的包名和全类名 123Intent intent = new Intent(); intent.setComponent(new ComponentName(\"com.hsm.plugin_package\",\"com.hsm.plugin_package.PluginMainActivity\")); startActivity(intent); 错误信息如下123456789101112java.lang.RuntimeException: Unable to instantiate activityComponentInfo{com.hsm.plugin_package/com.hsm.plugin_package.PluginMainActivity}:java.lang.ClassNotFoundException: Didn't find class\"com.hsm.plugin_package.PluginMainActivity\" on path: DexPathList[[zip file\"/data/app/com.hsm.hookplugin-6IZNq_xfampALDCZjZ6YZw==/base.apk\"],nativeLibraryDirectories=[/data/app/com.hsm.hookplugin-6IZNq_xfampALDCZjZ6YZw==/lib/x86, /system/lib]]at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:134) at java.lang.ClassLoader.loadClass(ClassLoader.java:379)at java.lang.ClassLoader.loadClass(ClassLoader.java:312)at android.app.AppComponentFactory.instantiateActivity(AppComponentFactory.java:69)at android.app.Instrumentation.newActivity(Instrumentation.java:1215)at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:28 1) 说是在DexPathList这个集合中找不到要跳转的Activity的实例，ClassNotFoundException也就是说在实例化这个Activity的时候找不到它，那我们需要去找一下Activity到底是在哪里实例化的，这就得看一下Activity的启动流程了。（报错信息中已经提示了在BaseDexClassLoader的第134行，不过我们还需要了解到底怎么走到这里，和为啥报错） Activity的启动流程可以看之前的两篇文章Activity启动流程（上）和Activity启动流程（下） 最终会走到ActivityThread中的performLaunchActivity123456789101112131415161718private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... //ContextImpl类继承自Context抽象类, ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) {...} ...} 这里就能看到拿到ClassLoader然后交给mInstrumentation去创建Activity实例并返回,newActivity方法中传入了ClassLoader，ClassName和intent。 123456789101112131415 @Overridepublic ClassLoader getClassLoader() { return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader()); }public static ClassLoader getSystemClassLoader() { return SystemClassLoader.loader; }static private class SystemClassLoader { public static ClassLoader loader = ClassLoader.createSystemClassLoader(); }private static ClassLoader createSystemClassLoader() { String classPath = System.getProperty(\"java.class.path\", \".\"); String librarySearchPath = System.getProperty(\"java.library.path\", \"\"); return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance()); } 通过跟踪源码，可以知道这个ClassLoader是一个PathClassLoader 这时候我们需要了解一下Android中的ClassLoader了，Andorid中的ClassLoader主要有三种 BootClassLoader：继承自ClassLoader 主要用来加载FrameWork层的dex文件 BaseDexClassLoader：继承自ClassLoader PathClassLoader：继承自BaseDexClassLoader，用来加载已经安装到系统中的apk中的dex文件 DexClassLoader：继承自BaseDexClassLoader，用来加载指定的目录中的dex文件（.apk,.zip） 然后在看newActivity这个方法1234567891011121314public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException { String pkg = intent != null &amp;&amp; intent.getComponent() != null ? intent.getComponent().getPackageName() : null; return getFactory(pkg).instantiateActivity(cl, className, intent); }//className就是我们最开始通过Intent传过来的public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className, @Nullable Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException { return (Activity) cl.loadClass(className).newInstance(); } 最后通过cl.loadClass(className).newInstance()方法来实例化Activity，cl前面也知道了它就是一个PathClassLoader。className就是我们最开始的时候通过Intent传过来的插件包中的Activity的全类名，因为插件包中的这个类找不到所以就会报前面的错误啦。 继续跟下去看看会进入到ClassLoader类中 12345678910111213141516171819202122232425262728293031public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); }public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } return c; } 这里面使用了双亲委托模式 findLoadedClass(name)检查这个类是否被加载过，最终执行到native方法去查找 如果没有并且其父类不为空，执行父类的loadClass()方法 如果最终还是没有找到，就执行findClass(name)方法自己去加载这个类。 前面创建PathClassLoader的方法中传入了BootClassLoader.getInstance()这个就是给parent赋值，我们知道BootClassLoader是用来加载系统FrameWork的文件，这里加载我们Activty返回空，最终会走到最后的findClass方法123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } 是一个空方法，最终交给子类BaseDexClassLoader来实现,BaseDexClassLoader在AndroidStudio中看的不全，可以在 https://www.androidos.net.cn/android/9.0.0_r8/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java 这里看到全部代码，而BaseDexClassLoader的两个子类PathClassLoader和DexClassLoader两个子类都只有构造方法。可以在 https://www.androidos.net.cn/android/9.0.0_r8/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java 和 https://www.androidos.net.cn/android/9.0.0_r8/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java 中看到。所以最终就是执行的BaseDexClassLoader中的findClass方法。1234567891011121314@Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } 到这里就可以看到最开始的报错信息了，当c==null的时候抛出这个错误。也就是pathList.findClass方法返回null，pathList变量是DexPathList，所以去DexPathList中看一下findClass方法 https://www.androidos.net.cn/android/9.0.0_r8/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java123456789101112public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) { for (Element element : dexElements) { Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } Element是DexPathList的静态内部类，1234public Class&lt;?&gt; findClass(String name, ClassLoader definingContext, List&lt;Throwable&gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null; 当dexFile不为null的时候才会调用它的loadClassBinaryName方法，否则直接返回null。loadClassBinaryName方法最终会执行到native中。 在DexPathList类中可以看到1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext, isTrusted); private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) { Element[] elements = new Element[files.size()]; int elementsPos = 0; /* * Open all files and load the (direct or contained) dex files up front. */ for (File file : files) { if (file.isDirectory()) { elements[elementsPos++] = new Element(file); } else if (file.isFile()) { String name = file.getName(); DexFile dex = null; if (name.endsWith(DEX_SUFFIX)) { // Raw dex file (not inside a zip/jar). try { dex = loadDexFile(file, optimizedDirectory, loader, elements); if (dex != null) { elements[elementsPos++] = new Element(dex, null); } } catch (IOException suppressed) { System.logE(\"Unable to load dex file: \" + file, suppressed); suppressedExceptions.add(suppressed); } } else { try { dex = loadDexFile(file, optimizedDirectory, loader, elements); } catch (IOException suppressed) { suppressedExceptions.add(suppressed); } if (dex == null) { elements[elementsPos++] = new Element(file); } else { elements[elementsPos++] = new Element(dex, file); } } if (dex != null &amp;&amp; isTrusted) { dex.setTrusted(); } } else { System.logW(\"ClassLoader referenced unknown path: \" + file); } } if (elementsPos != elements.length) { elements = Arrays.copyOf(elements, elementsPos); } return elements; } dexElements数组是通过传入的一个dexPath的路径来获得的。这时候我们需要分析一下我们的apk文件，直接使用AndroidStudio打开一个apk文件可以看到如图： 这里可以看到一个classes.dex文件，如果我们的应用做了分包处理，这里会看到很多.dex文件，他们的路径会传到上面的代码中，最终解析成为一个Element数组。 这时候我们就知道了，它现在解析的只是当前应用apk下面的.dex文件，而插件apk下面的.dex文件不在这里面，所以上面代码中的返回的Element数组中也就不包含插件中对应的的Element，最终循环完找不到就返回null了。 所以我们可以有这样一个方案，自己解析出插件apk中的Element数组，然后通过反射拿到宿主中的Element数组，把他们两个合成一个在设置回宿主中去，这样宿主中就可以找到对应的类了。 这里还会用到上一篇 Andorid Hook进阶中的一些代码，因为插件中的Activity是在宿主中没有注册的，加载的时候需要绕过AMS的检查。所以可以接着上一篇的代码继续来。 在Application中在添加一个融合Element的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 插件中的Element融入到宿主中 */ private void pluginToAppAction() throws Exception{ //1. 找到宿主中的dexElements数组 PathClassLoader pathClassLoader = (PathClassLoader) getClassLoader(); Class&lt;?&gt; baseDexClassLoaderClass = Class.forName(\"dalvik.system.BaseDexClassLoader\"); Field pathListField = baseDexClassLoaderClass.getDeclaredField(\"pathList\"); pathListField.setAccessible(true); Object dexPathList = pathListField.get(pathClassLoader); Field dexElementsField = dexPathList.getClass().getDeclaredField(\"dexElements\"); dexElementsField.setAccessible(true); Object appDexElements = dexElementsField.get(dexPathList); //2. 找到插件中的dexElements数组 File pluginFile = new File(Environment.getExternalStorageDirectory() + File.separator + \"p.apk\"); if (!pluginFile.exists()) { Log.i(TAG,\"插件包不存在\"); return; } String pluginPath = pluginFile.getAbsolutePath(); File pluginDir = this.getDir(\"pluginDir\",MODE_PRIVATE); DexClassLoader dexClassLoader = new DexClassLoader(pluginPath,pluginDir.getAbsolutePath(),null,getClassLoader()); Class&lt;?&gt; pluginBaseDexClassLoaderClass = Class.forName(\"dalvik.system.BaseDexClassLoader\"); Field pluginPathListField = pluginBaseDexClassLoaderClass.getDeclaredField(\"pathList\"); pluginPathListField.setAccessible(true); Object pluginDexPathList = pluginPathListField.get(dexClassLoader); Field dexElementsFieldPlugin = pluginDexPathList.getClass().getDeclaredField(\"dexElements\"); dexElementsFieldPlugin.setAccessible(true); Object pluginDexElements = dexElementsFieldPlugin.get(pluginDexPathList); //3. 把两个数组合并成一个新的数组 newElement int appLength = Array.getLength(appDexElements); int pluginLength = Array.getLength(pluginDexElements); int sum = appLength+pluginLength; //创建一个新的数组 两个参数，一个是类型 一个是长度 Object newDexElement = Array.newInstance(appDexElements.getClass().getComponentType(), sum); //进行融合 for (int i = 0; i &lt; sum; i++) { if(i&lt;appLength){ Array.set(newDexElement,i,Array.get(appDexElements,i)); }else { Array.set(newDexElement,i,Array.get(pluginDexElements,i-appLength)); } } //4. 把新的数组设置回宿主中 dexElementsField.set(dexPathList,newDexElement); //5. 处理布局文件 handlePluginLayout(); } private void handlePluginLayout() throws Exception{ assetManager = AssetManager.class.newInstance(); // 把插件的路径 给 AssetManager File pluginFile = new File(Environment.getExternalStorageDirectory() + File.separator + \"p.apk\"); if (!pluginFile.exists()) { Log.i(TAG,\"插件包不存在\"); return; } String pluginPath = pluginFile.getAbsolutePath(); //执行addAssetPath方法吧路径添加进去 assetManager才能加载资源 Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod(\"addAssetPath\",String.class); addAssetPathMethod.setAccessible(true); addAssetPathMethod.invoke(assetManager,pluginPath); //宿主的Resources Resources r = getResources(); //创建新的resources用来加载插件中的资源 resources = new Resources(assetManager,r.getDisplayMetrics(),r.getConfiguration()); } private Resources resources; private AssetManager assetManager; @Override public Resources getResources() { return resources == null ? super.getResources() : resources; } @Override public AssetManager getAssets() { return assetManager == null ? super.getAssets() : assetManager; } 全部代码就在上面了目的很明确 找到宿主中的dexElements数组 通过PathClassLoader寻找 找到插件中的dexElements数组 通过DexClassLoader寻找 把两个数组合并成一个新的数组 newElement 把新的数组设置回宿主中 处理布局文件，我们需要创建自己的Resources和AssetManager来加载插件的布局文件 创建完之后，重写系统的getResources和getAssets方法，如果自己创建的不为空就使用自己创建的来加载。 将插件打包成apk放到根目录下，运行宿主app 效果：","link":"/2019/08/21/architecture/Hook式插件化/"},{"title":"使用ASM完成编译时插桩","text":"使用ASM完成编译时插桩 ASM，是一个跟AspectJ功能类似比AspectJ更强大的编译时插桩框架。功能虽强大，不过用起来比AspectJ麻烦不少。 其实这个框架在Java中用的很多，对于Android开发者来说如果之前没有开发过Java就有点陌生了 官网 https://asm.ow2.io/ ASM是一个通用的Java字节码操作和分析框架，可以用它来动态的生成类后者增强现有类的功能。 ASM可以直接产生二进制的class文件，也可以在类被加载到Java虚拟机之前动态改变类的行为。 Java Class的类文件的信息存储在.class文件中，ASM可以读取.class文件中的类信息，改变类行为，分析类信息，甚至生成新的类。 Andorid java文件打包流程: .java文件-&gt;.class文件-&gt;.dex文件。想要编译时插桩一般有两种方式 更改java文件：APT，AndroidAnnotation 都是这个层面的dagger,butterknife等框架就是这个层面的应用。 更改class文件：AspectJ，ASM，javassisit等，功能更加强大 下面练习一个小例子，使用ASM来统计Application中onCreate执行的时间。 我们需要两大步来完成： 第一步拿到所有的.class文件，第二步交给ASM动态插入代码。 第一步找到class文件如何能拿到呢？Google官方在Adnroid Gradle1.5.0版本提供了Transform API，允许第三方Plugin在打包dex文件之前的编译过程中操作.class文件。所以我们就可以使用Transform，拿到所有的.class文件。 想要使用Transform API，这时候就得自定义一个Gradle的插件了 新建一个项目，然后建一个新的module来写插件代码 因为gradle是用groovy写的，所以需要在main文件夹下在新建一个入口文件夹groovy。 告诉gradle哪个是我们自定义的插件，在main目录下新建resources目录，然后在resources目录里面再新建META-INF目录，再在META-INF里面新建gradle-plugins目录。最后在gradle-plugins目录里面新建properties文件 properties文件的名字可以随便取，后面用到的时候就用这个取好的名字。在properties文件中指明我们自定义的插件的类implementation-class=com.hsm.asmplugin.AsmPlugin 最后的目录结构是这样的 下面去到当前module下面的build.gradle添加相关的依赖123456789101112131415161718192021222324252627282930313233343536apply plugin: 'groovy'apply plugin: 'maven'repositories { mavenCentral() jcenter()}dependencies { //gradle sdk implementation gradleApi() //groovy sdk implementation localGroovy() implementation 'com.android.tools.build:gradle:3.5.0' //ASM相关依赖 implementation 'org.ow2.asm:asm:7.1' implementation 'org.ow2.asm:asm-commons:7.1'}//uploadArchives是将已经自定义好了插件打包到本地Maven库里面去了，// 你也可以选择打包到远程服务器中。其中，// group和version是我们之后配置插件地址时要用到的。group='com.chs.asm.plugin'version='1.0'uploadArchives { repositories { mavenDeployer { //本地的Maven地址:当前工程下 repository(url: uri('./my-plugin')) //提交到远程服务器： // repository(url: \"http://www.xxx.com/repos\") { // authentication(userName: \"admin\", password: \"admin\") // } } }} 因为打包的时候需要用到maven，所以添加maven相关的依赖，uploadArchives是将已经自定义好了插件打包到本地Maven库里面去，也可以打包到远程服务器。group和version是使用的时候需要的组名和版本信息。 配置完成了，下面开始写代码，在groovy文件夹下写我们自己的插件继承Plugin12345678910111213141516package com.hsm.asmpluginimport com.android.build.gradle.AppExtensionimport org.gradle.api.Pluginimport org.gradle.api.Projectimport org.jetbrains.annotations.NotNullpublic class AsmPlugin implements Plugin&lt;Project&gt; { @Override public void apply(@NotNull Project project) { def android = project.extensions.getByType(AppExtension) println '----------- 开始注册 &gt;&gt;&gt;&gt;&gt; -----------' AsmTransform transform = new AsmTransform() android.registerTransform(transform) }} 获取project中的AppExtension类型extension，然后注册我们自己定义的Transform。 啥是AppExtension，我们app的gradle中最上面都有这个插件apply plugin: 'com.android.application如果依赖了这个插件，AppExtension就存在。 下面来看AsmTransform123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.hsm.asmpluginimport com.android.build.api.transform.*import com.android.build.gradle.internal.pipeline.TransformManagerimport com.chs.asm.LogVisitorimport org.apache.commons.codec.digest.DigestUtilsimport org.apache.commons.io.FileUtilsimport org.apache.commons.io.IOUtilsimport org.objectweb.asm.ClassReaderimport org.objectweb.asm.ClassVisitorimport org.objectweb.asm.ClassWriterimport java.util.jar.JarEntryimport java.util.jar.JarFileimport java.util.jar.JarOutputStreamimport java.util.zip.ZipEntrypublic class AsmTransform extends Transform { // 设置我们自定义的Transform对应的Task名称 // 编译的时候可以在控制台看到 比如：Task :app:transformClassesWithAsmTransformForDebug @Override public String getName() { return \"AsmTransform\" } // 指定输入的类型，通过这里的设定，可以指定我们要处理的文件类型 // 这样确保其他类型的文件不会传入 @Override public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() { return TransformManager.CONTENT_CLASS; } // 指定Transform的作用范围 @Override public Set&lt;? super QualifiedContent.Scope&gt; getScopes() { return TransformManager.SCOPE_FULL_PROJECT } @Override public boolean isIncremental() { return false } @Override public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException { long startTime = System.currentTimeMillis() println '----------- startTime &lt;' + startTime + '&gt; -----------' //拿到所有的class文件 Collection&lt;TransformInput&gt; inputs = transformInvocation.inputs; TransformOutputProvider outputProvider = transformInvocation.outputProvider; if (outputProvider != null) { outputProvider.deleteAll() } //遍历inputs Transform的inputs有两种类型，一种是目录，一种是jar包，要分开遍历 inputs.each { TransformInput input -&gt; //遍历directoryInputs(文件夹中的class文件) directoryInputs代表着以源码方式参与项目编译的所有目录结构及其目录下的源码文件 // 比如我们手写的类以及R.class、BuildConfig.class以及R$XXX.class等 input.directoryInputs.each { DirectoryInput directoryInput -&gt; //文件夹中的class文件 handDirectoryInput(directoryInput, outputProvider) } //遍历jar包中的class文件 jarInputs代表以jar包方式参与项目编译的所有本地jar包或远程jar包 input.jarInputs.each { JarInput jarInput -&gt; //处理jar包中的class文件 handJarInput(jarInput, outputProvider) } } } //遍历directoryInputs 得到对应的class 交给ASM处理 private static void handDirectoryInput(DirectoryInput input, TransformOutputProvider outputProvider) { //是否是文件夹 if (input.file.isDirectory()) { //列出目录所有文件（包含子文件夹，子文件夹内文件） input.file.eachFileRecurse { File file -&gt; String name = file.name //需要插桩class 根据自己的需求来------------- 这里判断是否是我们自己写的Application if (\"MyApp.class\".equals(name)) { ClassReader classReader = new ClassReader(file.bytes) //传入COMPUTE_MAXS ASM会自动计算本地变量表和操作数栈 ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) //创建类访问器 并交给它去处理 ClassVisitor classVisitor = new LogVisitor(classWriter) classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES) byte[] code = classWriter.toByteArray() FileOutputStream fos = new FileOutputStream(file.parentFile.absolutePath + File.separator + name) fos.write(code) fos.close() } } } //处理完输入文件后把输出传给下一个文件 def dest = outputProvider.getContentLocation(input.name, input.contentTypes, input.scopes, Format.DIRECTORY) FileUtils.copyDirectory(input.file, dest) } //遍历jarInputs 得到对应的class 交给ASM处理 private static void handJarInput(JarInput jarInput, TransformOutputProvider outputProvider) { if (jarInput.file.getAbsolutePath().endsWith(\".jar\")) { //重名名输出文件,因为可能同名,会覆盖 def jarName = jarInput.name def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath()) if (jarName.endsWith(\".jar\")) { jarName = jarName.substring(0, jarName.length() - 4) } JarFile jarFile = new JarFile(jarInput.file) Enumeration enumeration = jarFile.entries() File tmpFile = new File(jarInput.file.getParent() + File.separator + \"classes_temp.jar\") //避免上次的缓存被重复插入 if (tmpFile.exists()) { tmpFile.delete() } JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(tmpFile)) //用于保存 while (enumeration.hasMoreElements()) { JarEntry jarEntry = (JarEntry) enumeration.nextElement() String entryName = jarEntry.getName() ZipEntry zipEntry = new ZipEntry(entryName) InputStream inputStream = jarFile.getInputStream(jarEntry) //需要插桩class 根据自己的需求来------------- if (\"androidx/fragment/app/FragmentActivity.class\".equals(entryName)) { //class文件处理 println '----------- jar class &lt;' + entryName + '&gt; -----------' jarOutputStream.putNextEntry(zipEntry) ClassReader classReader = new ClassReader(IOUtils.toByteArray(inputStream)) ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) //创建类访问器 并交给它去处理 ClassVisitor cv = new LogVisitor(classWriter) classReader.accept(cv, ClassReader.EXPAND_FRAMES) byte[] code = classWriter.toByteArray() jarOutputStream.write(code) } else { jarOutputStream.putNextEntry(zipEntry) jarOutputStream.write(IOUtils.toByteArray(inputStream)) } jarOutputStream.closeEntry() } //结束 jarOutputStream.close() jarFile.close() //获取output目录 def dest = outputProvider.getContentLocation(jarName + md5Name, jarInput.contentTypes, jarInput.scopes, Format.JAR) FileUtils.copyFile(tmpFile, dest) tmpFile.delete() } }} 上面类上的注释很清楚啦，Transform的inputs有两种类型，一种是源码目录，一种是jar包，分别遍历这两个，找到我们需要处理的class类型。比如上面的代码中源码部遍历筛选的是我们自己的Application-&gt;MyApp.class。jar包部分处理所有的FragmentActivity。这些都可以根据自己的需求来筛选。 然后通过ClassReader读取，通过ClassWriter交给我们自定义的类访问器LogVisitor来处理 ASM核心类 ClassReader 用来解析编译过的字节码文件 ClassWriter 用来重新构建编译后的类，比如修改类名，属性，方法或者生成新类的字节码文件 ClassVisitor 用来访问类成员信息，包括标记在类上的注解，类的构造方法，类的字段，方法，静态代码块 MethodVisitor 用来访问方法的信息，用来进行具体的方法字节码操作。 AdviceAdapter 用来访问方法的信息，用来进行具体的方法字节码操作。是MethodVisitor的增强实现 第二步动态插入代码第一步中通过Transform，遍历所有的class文件，筛选出我们想要处理的class，然后交给了类访问器来处理，下面就来看怎么处理1234567891011121314151617181920212223242526272829303132333435363738package com.chs.asm;import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;public class LogVisitor extends ClassVisitor { private String mClassName; public LogVisitor(ClassVisitor classVisitor) { super(Opcodes.ASM5, classVisitor); } @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) { System.out.println(\"LogVisitor : visit -----&gt; started:\" + name); this.mClassName = name; super.visit(version, access, name, signature, superName, interfaces); } //定义一个方法， 返回的MethodVisitor用于生成方法相关的信息 @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions); if (\"com/hsm/asmtext/MyApp\".equals(this.mClassName)) { if (\"onCreate\".equals(name)) { //处理onCreate System.out.println(\"LogVisitor : visitMethod method ----&gt; \" + name); return new OnCreateVisitor(mv); } } return mv; } //访问结束 @Override public void visitEnd() { System.out.println(\"LogVisitor : visit -----&gt; end\"); super.visitEnd(); }} 在visitMethod方法中筛选出我们想要操作的方法。比如这里操作onCreate方法。筛选出来之后交给自定义的方法访问者OnCreateVisitor来处理 怎么处理呢？假如我们想要在Application的onCreate方法执行前插入一行记录时间的代码，在onCreate之后在插入一行代码如下 12345678910public class MyApp extends Application { @Override public void onCreate() { long startTime = System.currentTimeMillis(); super.onCreate(); ...一堆操作.. long interval = System.currentTimeMillis()-startTime; }} 那么使用ASM插入的方式如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.chs.asm;import org.objectweb.asm.Label;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;public class OnCreateVisitor extends MethodVisitor { public OnCreateVisitor(MethodVisitor methodVisitor) { super(Opcodes.ASM5, methodVisitor); } //开始访问方法 @Override public void visitCode() { super.visitCode(); mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); mv.visitVarInsn(Opcodes.LSTORE, 1); } @Override public void visitInsn(int opcode) { //判断内部操作指令 //当前指令是RETURN，表示方法内部的代码已经执行完 if (opcode == Opcodes.RETURN) { mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); mv.visitVarInsn(Opcodes.LLOAD, 1); mv.visitInsn(Opcodes.LSUB); mv.visitVarInsn(Opcodes.LSTORE, 3); Label l3 = new Label(); mv.visitLabel(l3); mv.visitLineNumber(20, l3); mv.visitLdcInsn(\"TAG\"); mv.visitTypeInsn(Opcodes.NEW, \"java/lang/StringBuilder\"); mv.visitInsn(Opcodes.DUP); mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/StringBuilder\", \"&lt;init&gt;\", \"()V\", false); mv.visitLdcInsn(\"interval:\"); mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); mv.visitVarInsn(Opcodes.LLOAD, 3); mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(J)Ljava/lang/StringBuilder;\", false); mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false); mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"android/util/Log\", \"i\", \"(Ljava/lang/String;Ljava/lang/String;)I\", false); mv.visitInsn(Opcodes.POP); } super.visitInsn(opcode); } @Override public void visitEnd() { super.visitEnd(); //访问结束 }} 其实到这里就完事了，之后就是打包发布到maven然后供我们的主工程使用了，不过上面的代码是个什么鬼，啥意思啊，我们该怎么写出来啊。 想要弄懂上面的代码，需要对java字节码和JVM的指令有一定的了解，上面就是组装一个方法的代码，需要用到包名啊，方法签名等。 如果我们不了解JVM指令可以写出上面的代码吗？当然可以，有牛逼的前辈早已经写出了插件来生成这样的代码，上面的代码就是生成出来的。 打开AndroidStudio的安装插件的界面，搜索ASM Bytecode Outline这个插件安装。 怎么使用呢 先写一个空的Application如下1234567public class MyApp extends Application { @Override public void onCreate() { super.onCreate(); }} 然后鼠标右击，选择Show Bytecode Outline，就能看到这几行代码的字节码了。 然后在里面加上我们要插入的代码，在执行同样的操作12345678910public class MyApp extends Application { @Override public void onCreate() { long startTime = System.currentTimeMillis(); super.onCreate(); long interval = System.currentTimeMillis()-startTime; Log.i(\"TAG\",\"interval：\"+interval); }} 又能看到当前几行代码的字节码。然后牛逼的功能又来了，点击ASMified这个tab，里面有个show differences 就能看到前后两次操作生成的指令的区别在哪里了。这样就能很清晰的知道该怎么写了如下。 OK，下面开始发布上传，之前build.gradle中已经配置好了maven的本地仓库地址了。下面直接使用AndroidSrudio的快捷键上传 打开最右边的Gradle面板，然后点击uploadArchives上传， OK之后就可以在对应目录看到我们上传的jar包了。本项目配置的仓库在当前目录下的my-plugin文件夹，最后生成目录如下 在当前工程目录引入本地maven仓库地址和我们自己写的插件，插件的包名和版本号就是之前插件build.gradle中配置的12345678910111213141516171819202122232425262728buildscript { repositories { google() jcenter() maven { //本地仓库地址 url uri('D:/androiddemo/5/ASMText/asmplugin/my-plugin') } } dependencies { classpath 'com.android.tools.build:gradle:3.5.0' //自己写的插件 classpath 'com.chs.asm.plugin:asmplugin:1.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }}allprojects { repositories { google() jcenter() maven { //本地仓库地址 url uri('D:/androiddemo/5/ASMText/asmplugin/my-plugin') } }} 然后去app中build.gradle中引入插件1apply plugin: &apos;com.chs.asm-plugin&apos; OK大工完成，在onCreate中添加个耗时代码用来测试，运行app12345678910111213public class MyApp extends Application { @Override public void onCreate() { super.onCreate(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行结果如下12019-09-26 11:09:28.838 28745-28745/com.hsm.asmtext I/TAG: interval:1002 到这里ASM的简单用法就算入门了，想要自如的操控我们的代码，还需要继续系统的学习一下gradle和ASM的知识。多多练习多熟悉。 参考博文 在AndroidStudio中自定义Gradle插件 【Android】函数插桩（Gradle + ASM） Android ASM自动埋点方案实践","link":"/2019/09/28/architecture/使用ASM完成编译时插桩/"},{"title":"Flutter 动画","text":"Flutter 动画 Flutter动画中用到的基本概念Flutter动画中有4个比较重要的角色：Animation、Controller、Curve、Tween，先来了解一下这四个角色 1.1 AnimationAnimation是Flutter动画库中的核心类，用于插入指导动画的值 Animation对象知道动画当前的状态（比如开始还是停止），可以使用addListener和addStatusListener监听动画状态改变。 12345678910111213141516171819202122animation.addListener((){ //调用setState来刷新界面 setState(() { }); }); animation.addStatusListener((status){ debugPrint('status $status'); switch (status){ //动画一开始就停止了 case AnimationStatus.dismissed: break; //动画从头到尾都在播放 case AnimationStatus.forward: break; //动画从结束到开始倒着播放 case AnimationStatus.reverse: break; //动画播放完停止 case AnimationStatus.completed: break; } }); addListener： 每一帧都会调用，调用之后一般使用setState来刷新界面 addStatusListener：监听动画当前的状态 如动画开始、结束、正向或反向 在Flutter中，Animation对象本身和UI渲染没有任何关系。Animation是一个抽象类，它拥有其当前值和状态（完成或停止）。其中一个比较常用的Animation类是Animation&lt;double&gt;,还可以生成除double之外的其他类型值，如：Animation&lt;Color&gt; 或Animation&lt;Size&gt; 。 1.2 AnimationController用来管理Animation，它继承自Animation，是个特殊的Animation，屏幕每刷新一帧，它都会生成一个新值，需要一个vsync参数，vsync的存在可以防止后台动画消耗不必要的资源。 vsync的值怎么获得，可以让stateful对象扩展使用TickerProviderStateMixin比如：123456class AnimationDemoHome extends StatefulWidget { @override _AnimationDemoHomeState createState() =&gt; _AnimationDemoHomeState();}class _AnimationDemoHomeState extends State&lt;AnimationDemoHome&gt; with TickerProviderStateMixin{...} AnimationController在默认情况下，在给定的时间段内，AnimationController会生成0.0到1.0的数字。 它可以控制动画，比如使用.forward()方法可以启动一个动画，.stop()可以结束一个动画，.reverse()启动反向动画。 12345678910AnimationController({ double value, this.duration, this.reverseDuration, this.debugLabel, this.lowerBound = 0.0, this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, @required TickerProvider vsync,}) 看一下AnimationController的构造方法，有一个必须的参数TickerProvider，就是前面给定的TickerProviderStateMixin 在StatefulWidget中创建一个AnimationController对象123456 animationController = AnimationController(// lowerBound: 32.0,// upperBound: 100.0, duration: Duration(milliseconds: 2000), vsync: this ); 1.3 CurvedAnimation定义动画曲线,运动过程，比如匀速，先加速在减速等等 12345CurvedAnimation({ @required this.parent, @required this.curve, this.reverseCurve, }) 它有两个必要的参数parent和curve。parent就是前面的AnimationController对象，curve就是动画运行的曲线，相当于Android属性动画中的插值器curve都有哪些取值呢 curve曲线 动画过程 linear|匀速的decelerate|匀减速ease|先加速后减速easeIn|开始慢后面快easeOut|开始快后面慢easeInOut|先慢在快在慢 上面是常用的一些曲线，还有很多中曲线运动的方式可以去curve.dart源码中去看，源码注释中有mp4的链接，可以清楚的看到动画运动的视频。 1234567891011121314151617abstract class Curve { const Curve(); double transform(double t) { assert(t &gt;= 0.0 &amp;&amp; t &lt;= 1.0); if (t == 0.0 || t == 1.0) { return t; } return transformInternal(t); } @protected double transformInternal(double t) { throw UnimplementedError(); } ...} 如果系统提供的运动曲线仍然无法满足我们的需求，那就可以继承Curve来自己实现一个。上面的代码可以看到Curve是一个抽象类，继承它并重写transform方法即可。比如我们可以自己在里面实现一个sin或者cos函数的曲线。例如123456class ShakeCurve extends Curve { @override double transform(double t) { return math.sin(t * math.PI * 2); }} 创建一个CurvedAnimation对象 12CurvedAnimation curvedAnimation =CurvedAnimation(parent: animationController,curve: Curves.bounceOut); 1.4 Tween：给动画对象插入一个范围值 默认情况下，AnimationController对象的范围从0.0到1.0，如果我们想要更大的范围，就需要使用到Tween了。比如1Tween tween = Tween(begin: 32.0,end: 100.0); class Tween&lt;T extends dynamic&gt; extends Animatable&lt;T&gt;Tween继承自Animatable，接收一个begin和一个end值，Tween的职责就是定义从输入范围到输出范围的映射。所以这两个值必须能进行加减乘的运算。 要使用Tween对象，调用其animate()方法，传入一个控制器对象，返回一个Animation对象。例如， 12Animation animation = Tween(begin: 32.0,end: 100.0).animate(curvedAnimation);Animation animationColor = ColorTween(begin: Colors.red,end: Colors.green).animate(curvedAnimation); 动画的使用2.1 Animation动画动画的四个角色都了解了，下面开始使用这些角色来构建一个动画，动画效果如下图 有一个心形的button，点击的时候放大并且颜色渐变，在点击的时候原路返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class AnimateDemo1 extends StatefulWidget { @override _AnimateDemo1State createState() =&gt; _AnimateDemo1State();}class _AnimateDemo1State extends State&lt;AnimateDemo1&gt; with SingleTickerProviderStateMixin{ AnimationController animationController; Animation animationSize; Animation animationColor; CurvedAnimation curvedAnimation; //Tween sizeTween; //Tween colorTween; @override void initState() { super.initState(); animationController = AnimationController( duration: Duration(milliseconds: 1000), vsync: this ); //设置插值器 这里使用一个默认的插值器bounceInOut curvedAnimation = CurvedAnimation(parent: animationController,curve: Curves.bounceOut); animationSize = Tween(begin: 32.0,end: 100.0).animate(curvedAnimation); animationColor = ColorTween(begin: Colors.red,end: Colors.green).animate(curvedAnimation); animationController.addListener((){ //刷新界面 setState(() {}); }); } @override void dispose() { super.dispose(); animationController.dispose(); } @override Widget build(BuildContext context) { return Center( child: IconButton( icon: Icon(Icons.favorite), iconSize: animationSize.value, color: animationColor.value, //iconSize: sizeTween.evaluate(curvedAnimation), //color: colorTween.evaluate(curvedAnimation), onPressed: (){ switch(animationController.status){ case AnimationStatus.completed: animationController.reverse(); break; default: animationController.forward(); } }, ), ); }} 通过animation.value可以拿到动画当前的值，然后赋值给当前需要动画的控件的相关属性即可 需要在addListener中调用setState来刷新界面，否则没效果 需要注意 animationController需要在dispose()页面销毁的时候释动画资源。 如果没有调用Tween的animate方法来构建一个Animation，可以在使用的地方使用如上面代码中sizeTween.evaluate(curvedAnimation)的方式来获取当前值。 2.2使用AnimatedWidget2.1中每次写动画都需要在addListener中设置setState来更新UI，有点麻烦，系统给提供了一个AnimatedWidget，它内部封装了addListener和setState的逻辑，我们只需要传给它AnimationController和Animation就行了。 而且我们可以自定义一个Widget继承它，让动画跟原来的视图代码分离 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class AnimationDemo2 extends StatefulWidget { @override _AnimationDemo2State createState() =&gt; _AnimationDemo2State();}class _AnimationDemo2State extends State&lt;AnimationDemo2&gt; with SingleTickerProviderStateMixin{ AnimationController animationController; Animation animationSize; Animation animationColor; CurvedAnimation curvedAnimation; @override void initState() { super.initState(); animationController = AnimationController( duration: Duration(milliseconds: 1000), vsync: this ); //设置插值器 这里使用一个默认的插值器bounceInOut curvedAnimation = CurvedAnimation(parent: animationController,curve: Curves.bounceOut); animationSize = Tween(begin: 32.0,end: 100.0).animate(curvedAnimation); animationColor = ColorTween(begin: Colors.red,end: Colors.green).animate(curvedAnimation); } @override void dispose() { super.dispose(); animationController.dispose(); } @override Widget build(BuildContext context) { return Center( child: AnimationHeart( animations: [ animationSize,animationColor ], controller: animationController, ), ); }}//动画代码抽离class AnimationHeart extends AnimatedWidget{ AnimationController controller; List animations; AnimationHeart({ this.animations, this.controller,}):super(listenable:controller); @override Widget build(BuildContext context) { return IconButton( icon: Icon(Icons.favorite), iconSize: animations[0].value, color: animations[1].value, onPressed: (){ switch(controller.status){ case AnimationStatus.completed: controller.reverse(); break; default: controller.forward(); } }, ); }} 自定义一个AnimationHeart继承自AnimatedWidget，在构造方法中将AnimationController和Animation传过来。其余的跟2.1中一样，最终效果也一样。 2.3使用AnimatedBuilderFlutter中还可以使用AnimatedBuilder来构建一个动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class AnimateDemo3 extends StatefulWidget { @override _AnimateDemo3State createState() =&gt; _AnimateDemo3State();}class _AnimateDemo3State extends State&lt;AnimateDemo3&gt; with SingleTickerProviderStateMixin{ AnimationController animationController; Animation animationSize; Animation animationColor; CurvedAnimation curvedAnimation; @override void initState() { super.initState(); animationController = AnimationController( duration: Duration(milliseconds: 1000), vsync: this ); //设置插值器 这里使用一个默认的插值器bounceInOut curvedAnimation = CurvedAnimation(parent: animationController,curve: Curves.bounceOut); animationSize = Tween(begin: 32.0,end: 100.0).animate(curvedAnimation); animationColor = ColorTween(begin: Colors.red,end: Colors.green).animate(curvedAnimation); } @override void dispose() { super.dispose(); animationController.dispose(); } @override Widget build(BuildContext context) { return AnimatedBuilder( animation: animationController, builder: (context,child){ return Center( child: IconButton( icon: Icon(Icons.favorite), iconSize: animationSize.value, color: animationColor.value, onPressed: (){ switch(animationController.status){ case AnimationStatus.completed: animationController.reverse(); break; default: animationController.forward(); } }, ), ); }, ); }} 实例化四个动画元素的代码跟前面还是一样，主要是在build代码块中使用AnimatedBuilder构建，传入animation对象。看起来比2.2中的方式也没有简单多少，不过看一下它的构造方法，系统还给提供了一个可选的参数child，让它天然就支持封装。123456const AnimatedBuilder({ Key key, @required Listenable animation, @required this.builder, this.child, }) 必需要一个Listenable，Animation就是Listenable 必需要一个builder，前面的代码中知道builder中需要传一个context和一个child 可以传一个child。传入的这个child最终会传入到builder中 上面的例子中我们是直接在builder中创建了一个控件，既然child可以传进来，那么我们可以把一个类型的动画封装一下比如缩放动画，渐变动画等，以后只要把需要此动画的小部件传进来，这个小部件就有这个动画了。 比如下面定义一个可以缩放的小部件。12345678910111213141516171819class ScaleAnimate extends StatelessWidget { final Animation animation; final Widget child; ScaleAnimate({@required this.animation,@required this.child}); @override Widget build(BuildContext context) { return AnimatedBuilder( animation: animation, builder: (context,child){ return SizedBox( width: animation.value, height: animation.value, child: child, ); }, child: child, ); }} Hero动画Hero动画很简单不过在平时的项目中也经常用到，主要用在路由页面之间切换。比如一个头像点击看大图，或者新闻列表页面，点击看详情，这种共享式的无缝切换。 动画效果如下图 1234567891011121314151617181920212223242526272829303132class AnimateDemo4 extends StatefulWidget { @override _AnimateDemo4State createState() =&gt; _AnimateDemo4State();}class _AnimateDemo4State extends State&lt;AnimateDemo4&gt; { @override Widget build(BuildContext context) { return Center( child: InkWell( child: Hero( tag: \"avator\", child: ClipOval( child: Image.network('http://ww1.sinaimg.cn/large/0065oQSqly1fsfq1k9cb5j30sg0y7q61.jpg',width: 100,), ), ), onTap: (){ Navigator.of(context).push(MaterialPageRoute(builder: (context){ return Scaffold( body: Center( child: Hero( tag: \"avator\", child: Image.network('http://ww1.sinaimg.cn/large/0065oQSqly1fsfq1k9cb5j30sg0y7q61.jpg'), ), ), ); })); }, ), ); }} 当前页面的圆形小图和详情页面的大图都使用Hero包裹。 必须使用相同的tag，Flutter Framework通过tag来确定他们之间的关系。 交织动画有时候我们需要实现一组复杂的动画，比如在0.1-0.2秒缩放，从0.2-0.4秒颜色渐变，从0.4-0.8秒左右移动，这时候使用交织动画可以方便的完成，使用交织动画需要注意下面几点 需要使用多个Animation对象 一个AnimationController控制所有的动画对象 给每一个动画对象指定时间间隔（Interval） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class AnimateDemo5 extends StatefulWidget { @override _AnimateDemo5State createState() =&gt; _AnimateDemo5State();}class _AnimateDemo5State extends State&lt;AnimateDemo5&gt; with TickerProviderStateMixin{ AnimationController _controller; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this ); } @override void dispose() { super.dispose(); _controller.dispose(); } @override Widget build(BuildContext context) { return Center( child: Column( children: &lt;Widget&gt;[ SizedBox(height: 30,), Center( child: StaggerAnimation(controller: _controller,), ), SizedBox(height: 30,), RaisedButton( child: Text(\"点击开始\"), onPressed: () { _play(); }, textColor: Theme.of(context).primaryColor, splashColor: Colors.grey[400], ) ], ), ); } void _play() async{ //先正向执行动画 await _controller.forward().orCancel; //再反向执行动画 await _controller.reverse().orCancel; }}class StaggerAnimation extends StatelessWidget { final AnimationController controller; Animation&lt;double&gt; width,height; Animation&lt;EdgeInsets&gt; padding; Animation&lt;Color&gt; color; Animation&lt;BorderRadius&gt; borderRadius; StaggerAnimation({Key key,this.controller}): super(key:key){ height = Tween&lt;double&gt;( begin: 0, end: 200) .animate(CurvedAnimation(parent: controller, curve: Interval(0.0,0.4,curve: Curves.ease))); width = Tween&lt;double&gt;( begin: 50, end: 200) .animate(CurvedAnimation(parent: controller, curve: Interval(0.0,0.4,curve: Curves.ease))); padding = Tween&lt;EdgeInsets&gt;( begin:EdgeInsets.only(left: .0), end:EdgeInsets.only(left: 100.0), ).animate(CurvedAnimation(parent: controller, curve: Interval(0.6, 1.0, curve: Curves.ease)),); color = ColorTween( begin:Colors.green , end:Colors.red, ).animate(CurvedAnimation(parent: controller, curve: Interval(0.0, 0.4, curve: Curves.ease,))); borderRadius = BorderRadiusTween( begin: BorderRadius.circular(3), end: BorderRadius.circular(35), ).animate(CurvedAnimation(parent: controller, curve: Interval(0.4, 0.6,curve: Curves.ease,),)); } @override Widget build(BuildContext context) { return AnimatedBuilder( animation: controller, builder: (context,child){ return Container( alignment: Alignment.bottomCenter, padding:padding.value , child: Container( width: width.value, height: height.value, decoration: BoxDecoration( color: color.value, border: Border.all(color: Colors.blue,width: 3), borderRadius:borderRadius.value ), ), ); }, ); }} StaggerAnimation中定义了5个动画，宽，高，颜色，左边距，圆角 使用Interval来定义某个动画执行的时机 最后异步启动动画。","link":"/2019/11/28/flutter/Flutter-动画/"},{"title":"Android Jetpack之LiveData","text":"Android Jetpack之LiveData LiveData概述LiveData是一个可观察的数据持有者类，和常规的observable不同，它是用来感知生命周期的，这意味着它遵守其他应用组件（activity、fragment、service等）的生命周期。这就确保它只会更新处于活动状态的组件。 如果一个类实现了android.arch.lifecycle.Observer，那么LiveData就认为这个类是STARTED或者RESUMED状态。LiveData只会通知活动的观察者更新信息，不处于活动状态的观察者不会受到信息。 我们可以注册一个observer和实现了LifecycleOwner的类一起使用（在Support Library 26.1.0 和以上的版本中，activity和fragment已经默认实现了LifecycleOwner接口）。当生命周期改变的时候，可以删除观察者，这对activity和fragment非常有用，它们可以安全的观察LiveData而不用担心内存泄露。当activity和fragment的生命周期执行到destroyed的时候立即取消订阅。 使用LiveData 创建一个LiveData用来保存特定的类型数据的实例，这通常在ViewModel中完成 创建一个Observer，定义onChanged()方法当数据改变的时候会执行这个方法，我们可以在activitt、fragment等UI控制器中创建这个Observer。 使用observe()方法把Observer添加到LiveData上。这个方法持有一个LifecycleOwner对象，一般在 activity 或 fragment中添加 可以通过observeForever(Observer)这个方法，注册一个永久的观察者，那么这个观察者就被认为是永远活动的，它也就一直能收到变化的通知，可以使用removeObserver(Observer)方法将它删除 LiveData是一个包装器，可以和任何对象使用。包括实现了Collections的对象，比如List，一个LiveData对象一般存在一个ViewModel中，通过一个getter方法获得。 示例123456789101112public class NameViewModel extends ViewModel {private MutableLiveData&lt;String&gt; currentName; // 创建一个String类型的LiveData public MutableLiveData&lt;String&gt; getCurrentName() { if (currentName == null) { currentName = new MutableLiveData&lt;String&gt;(); } return currentName; }} 确保存在LiveData中的数据不是activity和fragment，原因是他们是用来显示数据的而不是保存数据的状态。并且把LiveData和activity和fragment分离，并允许LiveData对象在配置更改后继续存在 观察LiveData对象多数情况下，我们在app组件的onCreate()方法中来观察LiveData对象。原因如下 确保activity和fragment不会再onResume()中进行冗余的调用 确保activity和fragment在变为活动状态的时候能立即收到并显示数据 LiveData一般情况下只在数据发生改变的时候才会通知在活动状态下的activity或者fragment更新，还有当观察者从非活动状态变为活动状态的时候也会改变。此外，如果观察者第二次从非活动状态更改为活动状态，则只有在自上次活动状态以来该值发生更改时才会收到更新。 更新LiveData对象 LiveData没有公开的方法来更新它存储的对象，它的子类MutableLiveData提供了setValue(T) 和postValue(T)两个方法来更新数据，setValue(T)是在主线程中更新数据，postValue(T)是在子线程中更新数据 例子：12345678910111213141516171819202122232425262728293031323334353637383940414243public class NameViewModel1 extends ViewModel { private MutableLiveData&lt;String&gt; currentName; public MutableLiveData&lt;String&gt; getCurrentName() { if (currentName == null) { currentName = new MutableLiveData&lt;String&gt;(); loadData(); } return currentName; } private void loadData() { Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { currentName.postValue(\"Lily\"); } }, 1000); }}public class NameActivity extends AppCompatActivity { private NameViewModel1 mViewModel; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_name); final TextView textView = findViewById(R.id.tv_name); //// 获取ViewModel. mViewModel = ViewModelProviders.of(this).get(NameViewModel1.class); // 观察LiveData,传入当前的LifecycleOwner和观察者 mViewModel.getCurrentName().observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { textView.setText(s); } }); }} 上面例子中，ViewModel中模拟一秒钟之后改变MutableLiveData中的值，NameActivity中也会跟着改变。 使用LiveData的优点 确保UI跟数据匹配，LiveData遵循观察者模式，可以在数据更改时更改UI 没有内存泄漏，观察者绑定Lifecycle对象，会在其销毁的时候自行清理 不会因为stopped activities而崩溃，如果观察者处于非活动状态，那么它是不会收到任何的LiveData的事件 不用在手动处理生命周期，UI组件只观察相关的数据，不会停止或者恢复观察，LiveData会自动管理数据，它在观察UI组件的时候，可以感知到生命周期的变化。 始终保持最新数据，后台activity返回前台时，可以立即接收到数据 共享资源，我们可以扩展LiveData对象，使用单例模式包装系统服务，这样就可以在app中共享服务，只要LiveData 连接到系统服务，其他要使用系统服务的观察者只需观察这个LiveData对象即可。 扩展LiveData直接看官网的例子，继承LiveData之后，重写其onActive()和onInactive()方法，在onActive()中注册一个监听，在onInactive()方法中取消这个监听。 12345678910111213141516171819202122232425262728293031323334public class StockLiveData extends LiveData&lt;BigDecimal&gt; { private StockManager stockManager; private SimplePriceListener listener = new SimplePriceListener() { @Override public void onPriceChanged(BigDecimal price) { setValue(price); } }; public StockLiveData(String symbol) { stockManager = new StockManager(symbol); } @Override protected void onActive() { stockManager.requestPriceUpdates(listener); } @Override protected void onInactive() { stockManager.removeUpdates(listener); }}public class MyFragment extends Fragment { @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); LiveData&lt;BigDecimal&gt; myPriceListener = ...; myPriceListener.observe(this, price -&gt; { // Update the UI. }); }} onActive()，当LiveData对象处于活动状态的时候会回调此方法 onInactive()，当LiveData对象没有活动的观察者的时候回调此方法，我们可以做一些清除操作 setValue(T)，更新LiveData实例的值，并通知其他处于活动状态的观察者改变 LiveData可以感知生命周期，这意味着我们可以在多个activity、fragment、service中共享它为了保持实例的一致性，可以把它设置成单例的1234567891011121314151617181920212223242526272829303132333435363738394041public class StockLiveData extends LiveData&lt;BigDecimal&gt; { private static StockLiveData sInstance; private StockManager stockManager; private SimplePriceListener listener = new SimplePriceListener() { @Override public void onPriceChanged(BigDecimal price) { setValue(price); } }; @MainThread public static StockLiveData get(String symbol) { if (sInstance == null) { sInstance = new StockLiveData(symbol); } return sInstance; } private StockLiveData(String symbol) { stockManager = new StockManager(symbol); } @Override protected void onActive() { stockManager.requestPriceUpdates(listener); } @Override protected void onInactive() { stockManager.removeUpdates(listener); }}public class MyFragment extends Fragment { @Override public void onActivityCreated(Bundle savedInstanceState) { StockLiveData.get(symbol).observe(this, price -&gt; { // Update the UI. }); }} 多个activity和fragment都可以观察上面自定义LiveData的实例，LiveData只会更新当前处于活动状态的组件。 转换LiveData在LiveData对象把更新的数据分发给观察者之前，我们可以通过转换操作，对数据进行加工。android.arch.lifecycle类中提供了转换的方法。 Transformations.map() 可转换LiveData的输出 上面NameActivity的例子中我们可以更改一下123456789101112131415161718192021 protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_name); final TextView textView = findViewById(R.id.tv_name); mViewModel = ViewModelProviders.of(this).get(NameViewModel1.class); LiveData&lt;String&gt; userNameMap = Transformations.map(mViewModel.getCurrentName(), new Function&lt;String, String&gt;() { @Override public String apply(String input) { return input + \"哈哈哈\"; } }); userNameMap.observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { textView.setText(s); } });} 上面代码会在在name后面拼接一个哈哈哈，这只是最简单的逻辑，我们可以在map函数中添加更多的逻辑，比如我们的LiveData接收的是一个User对象，最后输出的是名字的字符串等 Transformations.switchMap() 更改被LiveData观察的对象 和map()方法类似，区别是switchMap()给出的是LiveData，而map给出的是具体值。123456private LiveData&lt;User&gt; getUser(String id) { ...;}LiveData&lt;String&gt; userId = ...;LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) ); 比如上面的方法，通过switchMap，把用户的id和LiveData相关联，当用户的id发生改变的时候，会重新调用查找用户的方法，最后返新用户的LiveData的数据，这样不管查询多少个用户，界面都只需观察生成的LiveData一次 MediatorLiveData 提供自定义的转换 可以使用MediatorLiveData来自定义转换，该类监听其他LiveData对象并处理它们发出的事件。MediatorLiveData正确地将其状态传播到LiveData对象，更多参考Transformations MediatorLiveData是LiveData的子类，允许合并多个LiveData源。MediatorLiveData只要任何原始LiveData源对象发生更改，就会触发对象的观察者。 例如，如果LiveDataUI中有一个可以从本地数据库或网络更新的对象，则可以将以下源添加到该 MediatorLiveData对象： LiveData与存储在数据库中的数据关联的对象。 LiveData与从网络访问的数据关联的对象。 LiveData源码： 上面的内容大部分都是官网的文档，通过看文档，知道了LiveData怎么用，下面来看看它的实现原理。 从注册开始（LiveData.observe()方法） 1234567891011121314151617public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { assertMainThread(\"observe\"); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper);} 此方法传入的两个对象其实就是被观察者和观察者 如果当前生命周期是销毁状态，直接返回 把被观察者和观察者包装成一个LifecycleBoundObserver对象。 mObservers是一个链表，用来缓存包装对象，这里判断一下当前的包装对象是否已经存在了。 最后把这个包装对象注册到生命周期组件（被观察者owner）中，addObserver方法在上一篇lifcycles中看过了。 上一篇Lifecyles中我们知道，当被观察者owner(fragment、activity等)生命周期变化的时候，会调用传入的观察者的onStateChanged方法。这里传入的是LifecycleBoundObserver，所以会调用LifecycleBoundObserver的onStateChanged方法，它里面又调用了我们传入的observer的onChanged方法，我们就能拿到数据了。 下面看看这个LifecycleBoundObserver 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver { @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) { super(observer); mOwner = owner; } @Override boolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); } @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) { if (mOwner.getLifecycle().getCurrentState() == DESTROYED) { removeObserver(mObserver); return; } activeStateChanged(shouldBeActive()); } @Override boolean isAttachedTo(LifecycleOwner owner) { return mOwner == owner; } @Override void detachObserver() { mOwner.getLifecycle().removeObserver(this); }}private abstract class ObserverWrapper { final Observer&lt;? super T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;? super T&gt; observer) { mObserver = observer; } abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) { return false; } void detachObserver() { } void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) { onActive(); } if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) { onInactive(); } if (mActive) { dispatchingValue(this); } }} LifecycleBoundObserver继承自抽象类ObserverWrapper，实现了LifecycleEventObserver接口，LifecycleEventObserver中有个onStateChanged方法。当生命周期组件的生命周期发生变化的时候，就调用这个onStateChanged方法。 onStateChanged中，判断如果当前是销毁状态，移除当前观察者并返回，这里它自动移除了观察者，我们也就不用手动移除观察者了。如果不是调用父类ObserverWrapper中的activeStateChanged方法。 前面看文档我们知道，LiveData只有在activiy或者fragment等生命周期组件处于前台的时候才会收到事件。就在activeStateChanged这个方法中判断了是不是活动状态 onActive();和 onInactive();这两个是空方法，前面文档中如果我们自定义一个LiveData，就会重写这两个方法。 如果是活动状态，调用dispatchingValue方法分发事件,传入当前包装对象 1234567891011121314151617181920212223void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { considerNotify(initiator); initiator = null; } else { for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false;} 如果正在分发着事件返回 如果传入的包装对象为空，就去前面说的链表mObservers中遍历，如果找到了或者我们传入的不为空，就调用considerNotify方法通知观察者。 123456789101112131415private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData); } 如果mLastVersion小于当前的mVersion值才会继续往下执行。mVersion在setValue方法中++的，调用一个setValue方法，mVersion就+1，所以，当生命周期发生了变化，即使我们调用了considerNotify方法，但是当前的值没有改变，也不会执行观察者的onChanged方法。 observer.mObserver就是我们最开始传入的观察者，调用它的onChanged方法传入data，我们在activity或者fragment中就能收到这个data值了。 mData的值是在setValue方法中被赋值的。LiveData中有两种赋值的方法：setValue方法。和postValue，一个是在主线程中赋值，一个是在子线程中赋值。postValue其实就是在一个Runnable中地哦啊用setValue方法。 123456protected void setValue(T value) { assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null);} 可以看到没次setValue,mVersion都会加一，并且调用dispatchingValue方法进行消息分发。 Ok到这里源码就看完了。下面思考一下，前面文档中我们知道，如果一个activity或者fragment在后台，他是收不到数据更新的。当切换到前台拿上就能收到。怎么实现的呢？ 前面activeStateChanged方法中我们知道，只有activity或者fragment是活动状态才能会调用 dispatchingValue方法，如果它们在后台，这时候不调用dispatchingValue方法。当它们切换回到前台的时候，生命周期发生改变，会调用LifecycleBoundObserver中的onStateChange方法，然后又会进入到activeStateChanged方法中，这时候状态是活动的就可以调用dispatchingValue方法分发了。","link":"/2019/04/20/technology/Android-Jetpack之LiveData/"},{"title":"CMake","text":"CMake 什么是CMake 在Android Studio2.2和以上版本，构建原生库的默认工具是CMake CMake是一个跨平台的构建工具，可以使用简洁的语句来描述所有平台的安装(编译过程)。能够输出各种各样的makefile或者project文件。CMake并不直接构建出最终的软件，而是产生其他工具脚本比如makefile，然后在依据这个工具的构建方式使用。 CMake是一个比make更高级的编译配置工具，它可以根据不同的平台，不同的编译器，生成相应的makefile或者vcproj项目，从而达到跨平台的目的。Android Studio利用CMake生成的是ninja。ninja是一个小型的关注速度的构建系统。我们一般不需要关心ninja的脚本，只需要知道怎么配置CMake就行了 CMake是一个跨平台的支持产出各种不同的构建建脚本的一个工具。 CMake源文件 CMake源文件包含命令、注释、空格和换行 已CMakeLists.txt命名或者以.cmake为扩展名 可以通过add_subdirectory()命令吧子目录的CMake源文件添加进来 CMake源文件中所有有效的语句都是命令，可以是内置命令或者自定义的函数或宏命令。 CMake的注释 单行注释使用 # ,多行注释使用#[[]]1234#单行注释#[[多行注释多行注释]] CMake变量 CMake中所有变量都是string类型。可以使用set()和unset()命令来生命或者移除一个变量 变量的引用使用${变量名} 变量名是大小写敏感的 想要看到message命令打印的信息，build工程然后在路径app\\externalNativeBuild\\cmake\\debug\\armeabi-v7a\\cmake_build_output.txt.txt中就能看到 1234#声明变量set(name 123)#引用变量 message是打印命令message(&quot;name = ${name}&quot;) CMake列表 列表也是字符串，可以把列表看成一个特殊的变量，它有多个值 语法格式：set(列表名 值1 值2…) 引用：${列表名}123456#声明列表set(list_var 1 2 3 4 5 )#或者set(list_1 &quot;1;2;3;4;5&quot;)#打印message(&quot;list_var=${list_var}&quot;) Cmake操作符 类型 名称 一元 EXIST，COMMAND,DEFINED 二元 EQUAL,LESS,LESS_EQUAL,GREATER,GREATER_EQUAL,STREQUAL,STRLESS,STRLESS_EQUAL,STRGREATER,STRGREATER_EQUAL,VERSION_EQUAL,VERSION_GREATER,VERSION_GREATER_EQUAL,MATCHES 逻辑 NOT,AND,OR 这些操作符都是大小写敏感的。优先级带括号的&gt;一元&gt;二元&gt;逻辑 布尔常量值 类型 值 true 1,ON,YES,TRUE,Y,非0的值 false 0,OFF,FALSE,N,IGNORE,NOTFOUUND,空字符串，以-NOTFOUND结尾的字符串 条件命令 if(表达式) elseif123456set(if_tap OFF)set(elseif_tap ON)if(${if_tap}) message(&quot;if&quot;)elseif(${elseif_tap}) message 循环命令 while(表达式) endwhile(表达式) break()可以跳出整个循环。continue()可以跳出当前循环。 12345set(a &quot;&quot;)while(NOT a STREQUAL &quot;XXX&quot;) set(a &quot;${a}x&quot;) message(&quot;a = ${a}&quot;)endwhile() 循环遍历 第一种：foreach(循环变量 参数1 参数2…)endforeach(循环变量)。break()可以跳出整个循环。continue()可以跳出当前循环123foreach(item 1 2 3) message(&quot;item = ${item}&quot;)endforeach(item) 第二种：foreach(循环变量 RANGE total) endforeach(循环变量)。循环范围从0到total123foreach(item RANGE 3) message(&quot;item = ${item}&quot;)endforeach(item) 第三种：foreach(循环变量 RANGE start stop step) endforeach(循环变量)。循环变量从start到stop，每次增量为step12345foreach(item RANGE 0 7 3) message(&quot;item = ${item}&quot;)endforeach(item)--------打印为0 3 6 第四种：foreach(循环变量 IN LISTS 列表)endforeach(循环变量)1234set(list_var 1 2 3)foreach(item IN LISTS list_var) message(&quot;item = ${item}&quot;)endforeach(item) 自定义函数命令 自定义函数命令格式：function([arg1[arg2[arg3]]]) endfunction() 函数命令调用：name(实参列表)12345678910function(func x y z) message(&quot;call function func&quot;) message(&quot;x = ${x}&quot;) message(&quot;y = ${y}&quot;) message(&quot;z = ${z}&quot;) message(&quot;ARGC = ${ARGC}&quot;) message(&quot;agr1 = ${ARGV0} arg2 = ${ARGV1} arg3 = ${ARGV2}&quot;)endfunction(func)func(1 2 3) ARGC：表示传入产出的个数 ARGV: 表示所有参数列表 ARGV0: 第一个参数 ARGV1：第二个参数 ARGV2 第二个参数 自定义宏命令 自定义宏命令格式：macro([arg1[arg2[arg3]]]) endfunction() 宏命令用：name(实参列表) 计算机科学里的宏（Macro)，是一种批量批处理的称谓。一般说来，宏是一种规则或模式，或称语法替换12345678macro(ma x y z) message(&quot;call macro ma&quot;) message(&quot;x = ${x}&quot;) message(&quot;y = ${y}&quot;) message(&quot;z = ${z}&quot;)endmacroma(1 2 3) CMake作用域 全局层：cache变量 在整个项目范围可见，一般在set定义变量时，指定CACHE参数就能定义为cache变量 目录层：在当前目录CMakeLists.txt中定义，以及在该文件包含的其他cmake源文件中定义的变量 函数层：在命令哈数中定义的变量，属于函数作用域内的变量 CMakeLists.txt中命令解析使用AndoridStudio创建一个C++工程后，系统会默认给我们创建一个CMakeLists.txt文件1234567891011121314151617#指定cmake最低支持的版本cmake_minimum_required(VERSION 3.4.1)#add_library( native-lib SHARED native-lib.cpp)find_library( log-lib log)target_link_libraries( native-lib ${log-lib}) cmake_minimum_required(VERSION 3.4.1) 是指定cmake最低支持的版本 aux_source_directory(. DIR_SRCS) 第一个参数传入一个目录的路径，.代表查找当前目录所有源文件，并将云文件名称列表保存到第二个参数DIR_SRC变量，不能查找子目录。 add_library 添加一个库或者导入预编译的库 添加一个库： 添加一个库文件，名称为 指定STATIC,SHSRED,MODULE参数来指定库的类型，STATIC:静态库；SHARED:动态库；MODULE:在使用dyld的系统中有效，如果不支持dyld等同于SHARED EXCLUDE_FORM_ALL:表示该库不会被默认构建 sorece1 sorece2….sourceN用来指定库的源文件 12add_library(&lt;name&gt; [STATIC|SHARED|MODULE][EXCLUDE_FROM_ALL] source1 source2...sourceN) 导入预编译的库 添加一个已存在的预编译的库名为 一般配合set_target_properties使用 12345678add_library(&lt;name&gt; &lt;SHARED|STATIC|MODULE|UNKNOWN&gt; IMPORTED)#比如add_library(test SHARED IMPORTED)set_target_projecties( test#指明目标库的名称 #指明要设置的参数库路径 #/${ANDROID_ABI}/libtest.so#导入库的路径 PROPRETIES IMPORTED_LOCATION) set 设置CMake变量1234567891011#设置可执行文件的输出路径(EXCUTABLE_OUTPUT_PATH是全局变量)set(EXECUTABLE_OUT_PATH [out_path])#设置库文件的输出路径(LIBRARY_OUT_PATH是全局变量)set(LIBRARY_OUT_PATH [output_path])#设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)set(CMAKE_CXX_FLAGS &quot;-Wall std=c++ll&quot;)#设置源文件集合(SOURCE_FILES是本地变量即自定义变量)set(SOURCE_FILES main.cpp test.cpp...) include_directories 设置头文件目录，相当于g++选项中的-l参数12#可以用相对路径或者绝对路径，也可以使用自定义的变量值include_directories(./include ${MY_INCLUDE}) add_executable 添加可执行文件12#第一个参数文件名 第二个路径add_executable(&lt;name&gt; #{SRC_LIST}) target_link_libraries 将若干个文件链接到目标库文件，链接的顺序应该符合gcc链接顺序规则。 123456789target_link_libraries(&lt;name&gt; lib1 lib2 lib3)#如果出现互相依赖的静态库，CMake会允许依赖图中包含循环依赖比如：add_library(A STATIC a.c)add_library(B STATIC b.c)target_link_libraries(A B)target_link_libraries(B A)add_executable(main main.c)target_link_libraries(main A) 被链接的库放在依赖它的库的后面，即如果上面的命令中lib1依赖于lib2,lib2又依赖于lib3，则在前面的命令中，必须严格按照lib1 lib2 lib3的顺序排列否则会报错 add_definitions 添加编译参数。为当前路径以及子目录文件假如有D引入的define falg1add_definitions(-DFOO -DDEBUG ...) add_subdirectory 如果当前目录下还有子目录时，可以使用add_subdirectory,子目录中也需要包含有CMakeLists.txt123#dub_dir:指定包含CMakeLists.txt和源码文件的子目录的位置#binary_dir:是输出路径，一般可以不指定add_definitions(sub_dir [binary_dir]) file 文件操作命令12345678910111213141516171819202122232425262728293031323334#将message写入filename文件中，会覆盖文件原有内容file(WRITE filename &quot;message&quot;)#将message写入filename文件中，会追加在文件末尾file(APPEND filename &quot;message&quot;)#从filename文件中读取内容并存储到var变量中，如果指定了numBytes和offset#则从offset处开始最多度numBytes个字节#另外如果指定了HEX参数，则内容会以十六进制形式存储在var变量中file(READ filename var [LIMIT numBytes] [OFFSET offset] [HEX])#重命名文件file(RENME &lt;oldname&gt; &lt;newname&gt;)#删除文件 等于rm命令file(REMOVE [file1...])#根据指定url下载文件#timeout超市事件；下载状态会保存到status中；#下载日志会被保存到log;#sum指定多下载文件预期的MD5值#如果指定hi自定进行比对，#如果不一致则返回一个错误：SHOW_PROGRESS#进度信息会以状态信息的形式被打印出来file(DOWNLOAD url file [TIMEOUT timeout] [STATUS status] [LOG log] [EXPECTED_MD5 sum][SHOW_PROGRESS])#创建目录FILE(MAKE_DIRECTORY [dir1 dir2 ...])#会把path转换为以unix的/开头的cmake风格路径保存在result总file(TO_CMAKE_PATH pathresult)#会把cmake风格的路径转换为本地路径风格window下用“\\” unix下用“/”file(TO_NATIVE_PATH path result)#将会为所有匹配查询表达式的文件生成一个文件list#并将该list存储进变量variable里面#如果一个表达式指定了RELATIVE,返回的结果#将会是相对于给定路径的相对路径#查询表达式例子：*.cxx,*.vt?#NOTE:按照官方文档说法，不建议使用file的GLOB指令来收集工程的源文件。file(GLOB variable [RELATIVE path] [globbing expressions]) set_directory_properties() 设置某个路径的一种属性1set_directory_properties(PROPERITIES prop1 value1 prop2 value2) prop1 prop2，取值范围INCLUDE_DIRECTORIES,LINK_DIRECTORIES,INCLUDE_REGULAR_EXPRESSION,ADDITIONNAL_MAKE_CLEAN_FILES set_property():在给定的作用域内设置一个命名的属性 1234567set_property(&lt;GLOBAL | DIRECTORY [dir] |TARGET [target...] |SOURCE [src1...] |TEST [test1...] |CACHE [entry1 ...]&gt;[APPENT]PROPERTY &lt;name&gt; [value...]) PROPERTY参数是必须的；第一个参数决定了属性可以影响的作用域： GLOBAL:全局作用域 DIRECTORY:默认当前路径，也可以用[dir]指定路径 TARGET:目标作用域，可以是0个或多个已有目标 SOURCE:源文件作用域，可以是0个或多个源文件,源文件只对同目录有用 TEST:测试作用域，可以是0个或多个已有的测试 CACHE:必须指定0个或多个cache中已有的条目 如果源文件很多，把所有文件一个一个加入很麻烦，可以使用aux_source_directory命令或file命令，会查找指定目录下的所有源文件，然后将结果存进指定的变量名中。12345678910#查找当前目录多有源文件 并将名称到存到DIR_SRCS#中，不能查找子目录aux_source_directory(. DIR_SRCS)#也可以使用#file(GLOB DIR_SRCS *.c *.cpp)add_library(native-lib SHARED ${DIR_SRCS}) 多目录多源文件处理 主目录中的CMakeList.txt中添加add_subdirectory(child)命令，指明本项目包含一个子项目child并在target_link_libraries指明本项目所需要链接一个名为chlid的库 子目录child中创建CMakeLists.txt，这里child编译为共享库 主目录：1234567891011cmake_minimum_required(VERSION 3.4.1)aux_source_directory(. DIR_SRCS)#添加child子目录下的CMakeLists.txtadd_subdirectory(child)add_library( native_lib SHARED ${DIR_SRCS})target_link_libraries(native-lib child) child目录：1234567cmake_minimum_required(VERSION 3.4.1)aux_source_directory(. DIR_LIB_SRCS)add_library( child SHARED ${DIR_SRCS}) 添加预编译库 假如项目中引入了libimported-lib.so 添加add_library命令，第一个参数是模块名，第二个参数SHARED表示动态库，第三个参数IMPORTED表示以导入的形式添加 添加set_targetOproperties命令设置导入路径属性到target_link_libraries命令参数中，表示native-lib需要连接imported-lib模块 Android 6.0之前1234567891011121314151617181920cmake_minimum_required(VERSION 3.4.1)#使用IMPORTED标志告诉CMake 只希望将库导入到项目中#如果静态库则将shared改为staticadd_library( imported-lib SHARED IMPORTED)#参数分别为库、属性、导入地址、库所在地址set_target_properties( imported-lib PROPERTIES IMPORTED_LOCATION &lt;路径&gt;/libimported-lib.so )aux_source_directory(. DIR_SRCS)add_library( native-lib SHARED ${dir_SECS})target_link_lbraries(native-lib imported) Android 6.0之后12345#set命令定义一个变量#CMAK_C_FLAGS:c的参数会传递给编译器#付过是c++文件，需要用CMAKE_CXX_FLAGS#-L:库的查找路径set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -L[SO所在目录]&quot;) 添加头文件的目录 为了确保CMake可以在编译时定位头文件，使用include_directories，相当于g++选项中的-l参数。这样就可以使用#include&lt;xx.h&gt;，否则需要使用#include”path/xx.h”1234567891011cmake_minimum_required(VERSION 3.4.1)#设置头文件目录include_directiories(&lt;文件目录&gt;)set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -L[SO所在目录]&quot;)aux_source_directory(. DIR_SRCS)add_library( native-lib SHARED ${dir_SECS})target_link_lbraries(native-lib imported) build.gradle配置12345678910111213141516171819202122android { defaultConfig { externalNativeBuild { cmake { //使用编译器clang/gcc //cmake默认就是gnustl_static arguments &quot;-DANDROID_TOOLCHAIN=clang&quot;,&quot;-DANDROID_STL=gnustl_static&quot; //指定cflags和cppflags，效果和cmakelist使用一样 cppFlags &quot;&quot; cppFlags &quot;&quot; //指定需要编译的cpu架构 abiFilters &quot;armeabi-v7a&quot; } } } externalNativeBuild { cmake { path &quot;src/main/cpp/CMakeLists.txt&quot; version &quot;3.10.2&quot; } }} 练习使用AndoridStudio新建一个C++项目，系统会为我们建好一个CmakeLists.txt文件 12345678910111213141516#指定cmake最小支持版本cmake_minimum_required(VERSION 3.4.1)#添加一个库，根据native-lib.cpp文件编译一个native-lib动态库add_library( native-lib SHARED native-lib.cpp)#查找系统库，这里查找的是系统日志库#默认会到 skd的ndk路径下面去找比如：sdk\\ndk-bundle\\platforms\\android-28\\arch-arm\\usr\\libfind_library( log-lib log)#设置依赖的库，第一个参数必须为依赖的模块，顺序不能改target_link_libraries( native-lib ${log-lib}) 如何集成第三方库比如现在继承fmod库到自己的项目（fmod是一个音频引擎，可以制作各种各样的魔幻声音） 首先去官网下载sdk https://www.fmod.com/download 它有各个平台的这里选择Android的 下载之后解压进入到api/core目录可以看到3个文件夹examples(例子)，inc(头文件)，lib(动态库) 先把头文件复制到我们工程的cpp目录下面 然后在cpp目录的同级新建jinLibs文件夹，把动态库都复制进去，lib文件夹中有个fmod.jar，这个jar包也放到我们工程的libs文件中引入，防止运行的时候找不到类。 等会使用模拟器测试，所以app.gradle中配置cpu的类型为x86123456789externalNativeBuild { cmake { abiFilters &quot;x86&quot; } } ndk { abiFilters &apos;x86&apos; } 配置CMakeLists.txt文件 12345678910111213141516171819202122#指定cmake最小支持版本cmake_minimum_required(VERSION 3.4.1)#设置头文件目录include_directories(${CMAKE_SOURCE_DIR}/inc)#添加一个库，根据native-lib.cpp文件编译一个native-lib动态库add_library( native-lib SHARED native-lib.cpp)#设置第三方so库的路径set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/../jniLibs/${CMAKE_ANDROID_ARCH_ABI}&quot;)#查找系统库，这里查找的是系统日志库#默认会到 skd的ndk路径下面去找比如：sdk\\ndk-bundle\\platforms\\android-28\\arch-arm\\usr\\libfind_library( log-lib log)#设置依赖的库，第一个参数必须为依赖的模块，顺序不能改。fmod和fmodL是动态库的名字target_link_libraries( native-lib fmod fmodL ${log-lib}) 到我们自己的cpp文件中编写代码 这里引入fmod的头文件，然后打印一下其版本号12345678910111213141516171819#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;fmod.hpp&gt;#include &lt;android/log.h&gt;using namespace FMOD;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_chs_cmake_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { System *system; System_Create(&amp;system); unsigned version; system-&gt;getVersion(&amp;version); __android_log_print(ANDROID_LOG_ERROR,&quot;text&quot;,&quot;FMOD_VERSION:%08x&quot;,version); return env-&gt;NewStringUTF(hello.c_str());} 运行项目可以在log中看到打印日志12019-05-25 15:37:50.261 29585-29585/com.chs.cmake E/text: FMOD_VERSION:00020001 OK继承成功。","link":"/2019/05/25/technology/CMake/"},{"title":"Makefile相关","text":"Makefile相关 编译过程编译过程分为四大过程： 预处理：完成宏替换，文件引入，除去空行、注释等，为下一步编译做准备。使用,命令gcc -E test.c -o test.i-E指gcc在预处理完成后停止后序的操作，-o指定输出的文件。 编译：将预处理后的代码编译成汇编代码，在这个阶段中，首先要检查代码的规范性、是否有语法错误等，检查无误后把代码翻译成汇编语言；编译程序执行的时候，会先分析语法，词法语义生成中间代码，最后对代码优化。大多数编译程序会直接产生可执行的机器码，有些是先产生汇编语言一级符号代码文件，在调用汇编程序加工处理产生机器可执行的目标文件。使用命令gcc -S test.i -o test.s -S表示gcc在编译后停止后面的操作 汇编：把编译阶段生成的.s文件转成二进制目标代码也就是机器码（01序列）。使用命令gcc -c test.s -o test.o -c表示gcc在汇编处理后停止后面的链接操作 连接：将多个目标文件以及所需的库文件连接生成可执行目标文件的过程。使用命令gcc text.o -o test最后生成可执行文件test 最后执行./test即可执行该文件 例子： 现在linux中的一个文件夹下面有一个test.c的源文件，里面就一个输出hello world的方法123456789[root@cdh-master test]# lstest.c---------------------------[root@cdh-master test]# cat test.c#include &lt;stdio.h&gt;int main(){ printf(&quot;hello world&quot;); return 0;} 第一步：执行预处理使用命令gcc -E test.c -o test.i会输出一个test.i文件123[root@cdh-master test]# gcc -E test.c -o test.i[root@cdh-master test]# lstest.c test.i 第二步：执行编译命令gcc -S test.i -o test.s会输出一个test.s文件123[root@cdh-master test]# gcc -S test.i -o test.s[root@cdh-master test]# lstest.c test.i test.s 第三步：执行汇编命令gcc -c test.s -o test.o会输出一个test.o文件。123[root@cdh-master test]# gcc -c test.s -o test.o[root@cdh-master test]# lstest.c test.i test.o test.s 第四步：执行链接命令gcc test.o -o test生成一个名为test的可执行文件。123[root@cdh-master test]# gcc test.o -o test[root@cdh-master test]# lstest test.c test.i test.o test.s 最后通过./test执行文件，输出hello world12[root@cdh-master test]# ./testhello world 上面的步骤是分开来做的，我们可以通过gcc -o test test.c命令直接生成一个test可执行文件 静态库和动态库静态库： 静态库就是一些目标文件（一般以.o结尾）的集合，静态库一般以.a结尾，只用于生成可执行文件阶段。 在链接步骤中，连接器将从库文件中取得所需代码，复制到可执行文件中。这种库就是静态库。 特点是可执行文件中包含了库代码的一份完整的拷贝，在编译过程中被载入程序中。 缺点就是多次使用就会有多分冗余的拷贝，并且对程序的更新、部署、和发布带来麻烦，比如静态库有更新，那么所有使用它的程序都需要重新编译发布。 动态库： 在链接阶段没有被复制到程序中，而是在程序运行时，由系统动态加载到内存中供程序调用。 系统只需载入一次动态库，不同程序就可以得到内存总相同动态库的副本，因此节省了很多内存 例子：编译静态库，先定义3个源文件too.h,tool.c,main.c用来求一个数组中的最大值 12[root@cdh-master test]# lsmain.c tool.c tool.h tool.h123#pragma onceint find_max(int arr[],int n); tool,c123456789101112#include \"tool.h\"int find_max(int arr[], int n) { int max = arr[0]; int i = 0; for (; i &lt; n; i++) { if (arr[i]&gt;max) { max = arr[i]; } } return max;} main.c123456789#include &lt;stdio.h&gt;#include \"tool.h\"int main() { int arr[] = {1,3,6,8,5,7,9}; int max = find_max(arr,7); printf(\"max=%d\\n\",max); return 0;} 开始编译静态库： 第一步：使用gcc -c tool.c可以生成一个tool.o文件12[root@cdh-master test]# lsmain.c tool.c tool.h tool.o 第二步：使用命令ar rcs libtool.a tool.o生成静态库文件tool.a文件123[root@cdh-master test]# ar rcs libtool.a tool.o[root@cdh-master test]# lslibtool.a main.c tool.c tool.h tool.o 第三步：编译可执行文件，并连接静态库，使用命令gcc -o main main.c -L. -ltool-l执行要链接的库，-L表示去目标目录寻找文件，这里使用.表示当前文件夹123[root@cdh-master test]# gcc -o main main.c -L. -ltool[root@cdh-master test]# lslibtool.a main main.c tool.c tool.h tool.o 最后执行main文件./main12[root@cdh-master test]# ./mainmax=9 开始编译动态库：第一步跟生成.o文件，跟前面一样第一步：使用gcc -c tool.c可以生成一个tool.o文件(目标文件)12[root@cdh-master test]# lsmain.c tool.c tool.h tool.o 第二步：使用命令gcc -shared -fPIC -o libtool.so tool.o 生成libtool.so文件123[root@cdh-master test]# gcc -shared -fPIC -o libtool.so tool.o[root@cdh-master test]# lslibtool.a libtool.so main main.c tool.c tool.h tool.o 第三步：编译可执行文件并连接动态库，跟前面的链接静态库一样gcc -o main main.c -L. -ltool,如果当前目录有同名的静态库和动态库比如现在libtool.a libtool.so虚拟机会先加载动态库，最后生成main可执行文件 第四步：./main执行文件12[root@cdh-master test]# ./main./main: error while loading shared libraries: libtool.so: cannot open shared object file: No such file or directory 报错，找不到共享的libraries，可以通过ldd命令查看main文件依赖了那些库12345[root@cdh-master test]# ldd main linux-vdso.so.1 =&gt; (0x00007fff24348000) libtool.so =&gt; not found libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f6ec319f000) /lib64/ld-linux-x86-64.so.2 (0x00007f6ec3569000) 可以看到libtool.so =&gt; not found找不到，因为它会默认到系统默认路径下寻找，这里没有配置环境变量，所以找不到，我们需要给他执行加载目录。这里使用.指定当前目录LD_LIBRARY_PATH=. ./main12[root@cdh-master test]# LD_LIBRARY_PATH=. ./mainmax=9 动态库和静态库的区别： 静态库在程序编译时链接到代码中，程序运行的时候不在需要静态库，因此体积比较大，每次编译都需要从新载入静态代码，内存开销大。 动态库在程序编译期间不会链接到目标代码中，而是在程序运行时才被载入，因此体积比较小，不过运行的时候需要指定动态库的路径。系统每次只需载入一次动态库，不同程序可以得到内存中相同的动态库的副本，内存开销比较小。 Makefile为什么要写Makefile文件？当项目非常庞大时，让构建过程，自动化，简单 Makefile 定义了一系列的规则来指定哪些文件需要优先编译，哪些文件需要重新编译，以及如何进行链接操作。 Makefile就是“自动化编译”告诉make命令如何编译和链接。 Makefile包含以下五个部分： 显示规则：如何生成一个或多个目标文件 隐晦规则：自动推导功能 变量定义：一般是字符串 文件指示：1 一个Makefile中引用另一个Makefile 2 根据某些情况执行有效部分 3 定义多行 注释：使用# 规则： target：目标文件可以是Object File 也可以是执行文件，还可以是标签 prerequistites：依赖文件，即要成成的那个target所需要的文件或者其他target command：make需要执行的命令 Makefile是如何工作的： 默认情况下，输入make命令后会执行下面步骤： make会在当前目录下寻找名字叫Makefile或者makefile的文件 如果找到了，它会找文件中第一个目标文件（target），并把这个target作为最终目标文件。比如前面例子中的main文件 如果找不到main文件或者main多以来的.o文件的修改时间比main文件要新，那么它会执行后面定义的命令来生成main文件 如果main所依赖的.o文件也存在，那么make会在当前文件夹中找目标为.o的文件的依赖，若找到则根据规则生成.o文件 make再用.o文件声明make的终极任务，也就是执行文件main 环境变量MAKEFILES: 如果当前环境中定义了环境变量MAKEFILES,那么make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其他的Makefile，用空格分割。只是它和include不同的是，从这个环境变量中引入的Makefile的目标不会起作用，如果环境变量中定义的文件发现错误，make也不会理会。 不过建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make的时候，所有的Makefile都会收到它的影响。 Makefile中的预定义变量 变量名 描述 默认值 CC C语言编译器名称 cc CPP C语言预处理器的名称 $(CC)-E CXX C++语言编译器名称 g++ RM 删除文件程序的名称 rm -f CFLAGS C语言编译器的编译选项 无 CPPFLAGS C语言预处理器的编译选项 无 CXXFLAGS C++语言编译器的编译选项 无 Makefile中的自动变量 自动变量 描述 $* 目标文件的名称，不包含扩展名 $@ 目标文件的名称，包含扩展名 $+ 所有的依赖文件，以空格隔开，可能含有重复的文件 $^ 所有的依赖文件，以空格隔开，不重复 $&lt; 依赖项中第一个依赖文件的名称 $? 依赖项中所有比目标文件新的依赖文件 Makefile中的函数 123456789101112131415161718# 不带参数define FUNC$(info echo &quot;hello&quot;)endef#调用$(call FUNC)------------输出：hello#带参数define FUNC1$(info echo $(1)$(2))endef#调用$(call FUNC1,hello,world)----------输出：hello world 使用Makefile的例子： 还是使用前面的几个源文件，tool.h,tool.c,main.c。文件少的时候我们可以一个命令一个命令的去敲去编译，文件多的时候，就会非常麻烦，所以把命令都在在Makefile文件中，使用的时候直接make就完事。 在上面三个文件所在目录执行vim Makefile命令创建一个Makefile文件并编辑123456789101112131415161718#main是最终目标，第一行是最终目标#:后的文件都是它的依赖#下一行用TAB键开头 写上需要生成目标文件需要执行的命令main:main.o tool.o gcc main.o tool.o -o main#main.o是二级目标#main.c是main.o的依赖#gcc -c main.c是需要执行的命令main.o:main.c gcc -c main.ctool.o:tool.c gcc -c tool.c#PHONY关键字代表为目标.PHONY:clean#clean清除所有的.o结尾的文件和执行文件clean: rm -f *.o rm -f main 编辑完成之后，执行make命令，就会直接生成main.o,tool.o,main这些文件。 第一行是最终目标，和它所需要的依赖，如果它的依赖也需要别的依赖来生成，就从下面按照相同的格式在写一行，以此类推。 .PHONY关键字代表为目标。比如上面例子中标记clean，如果我们源文件的目录中有个叫clean的文件，如果没有用.PHONY标记，就会去编译clean文件。这里用它标记了，那么clean就只能执行下面定义的删除方法了。 前面的Makefile文件已经可以简化我们的命令的了，但是如果文件多了还是比较麻烦，我们可以继续简化。123456789OBJECT=main.o tool.omain:$(OBJECT) gcc $^ -o $@%.o:%.c gcc -c $^ -o $@.PHONY:cleanclean: rm -f *.o rm -f main 定义一个OBJECT变量来保存依赖文件$^表示所有依赖，$@表示目标，%.o:%.c是使用通配符来表示所有的.o文件有所有的.c文件生成。执行make之后效果跟前面的一样。 我们发现虽然定义了一个OBJECT变量，后面需要依赖的文件还得手动写，如果文件很多还是很麻烦的，还可以继续优化 12345678910SOURCES=$(wildcard *.c)OBJECT=$(patsubst %.c,%.o,$(SOURCES))main:$(OBJECT) gcc $^ -o $@%.o:%.c gcc -c $^ -o $@.PHONY:cleanclean: rm -f *.o rm -f main 使用SOURCES关键字定义资源。wildcard关键字是找出该目录下所有的.c源文件。patsubst关键字是把所有的.c替换成.o。执行之后效果跟前面一样。 Makefile中使用函数： 无参函数 12345define func$(info &quot;hello world&quot;)endef//调用$(call func) 使用define 定义一个名叫func的函数，使用$(call func)调用。保存之后，回到文件夹中执行make命令，会看到输出hello world。 有参函数12345define func1$(info $(1) $(2))endef$(call func1,hello,world) 使用define 定义一个名叫func1的函数， $(1) $(2)代表要输入的参数，最后通过call调用函数，保存回到文件夹中执行make命令，会看到输出hello world。 make的工作流程 GNU的make工作步骤如下: 读入所有的Makefile 读入被include的其他的Makefile 初始化文件中的变量 推导隐晦规则，并法分析所有的规则 为所有的目标文件创建依赖关系链 根据依赖关系，决定哪些目标要重新生成 执行生成命令 Android.makAndroid.mk是一个向Android NDK构建系统描述NDK项目的GNU makefile 片段。主要用来编译生成以下几种： APK程序：一般的Android应用程序，系统级别的直接push Java库：JAVA类库，编译打包生成JAR文件 C/C++应用程序：可执行的C/C++应用程序 C/C++静态库：编译生成C/C++静态库，并打包成.a文件。 C/C++共享库：编译生成共享库，并打包成.so文件 一个简单的Android.mk文件样例12345678910111213141516171819#定义模块当前的路径（必须定义在文件开头，只需要定义一次）LOCAL_PATH := $(call my-dir)#Makefile中可以引入其他的Makefile文件#编译模块时，清空当前环境变量（LOCAL_PATH除外）include $(CLEAR_VARS)#当前模块名（这里会生成libhello-jni）LOCAL_MODULE :=hello-jni#编译所需要的源文件 多个文件以空格隔开LOCAL_SRC_FILES :=hello-jni.c#需要的头文件LOCAL_C_INCLUDES#编译需要的动态库LOCAL_SHARED_LIBRARIES#表示当前模块将要被编译成一个共享库include $(BUILD_SHARED_LIBRARY) 一个Android.mk可能编译产生多个共享库模块，比如下面代码会产生libmodeule1.so和libmodule2.so两个动态库12345678910111213LOCAL_PATH := $(call my-dir)#模块1include $(CLEAR_VARS)LOCAL_MODULE :=module1LOCAL_SRC_FILES :=module1.cinclude $(BUILD_SHARED_LIBRARY)#模块2include $(CLEAR_VARS)OCAL_MODULE :=module2LOCAL_SRC_FILES :=module2.cinclude $(BUILD_SHARED_LIBRARY) 编译静态库 Android应用程序不能直接使用静态库，不过可以使用静态库来编译动态库。比如在把第三方代码添加到原生项目中时，可以不用直接把第三方源码放入原生项目中，而是将第三方源码编译成静态库，然后并入共享库。 123456789101112131415LOCAL_PATH := $(call my-dir)#第三方AVI库include $(CLEAR_VARS)OCAL_MODULE :=avilibLOCAL_SRC_FILES :=abilib.c platfrom_posix.cinclude $(BUILD_SHARED_LIBRARY)#原生模块include $(CLEAR_VARS)LOCAL_MODULE :=moduleLOCAL_SRC_FILES :=module.c#将静态模块添加到LOCAL_STATIC_LIBRARIES变量LOCAL_STATIC_LIBRARIES :avilibinclude $(BUILD_SHARED_LIBRARY) 使用共享库共享通用模块 静态库可以保证源代码模块化，但是当静态库与共享库相连时，它就变成了共享库的一部分。 在多个共享库与静态库相连接时，需要将通用模块的多个副本与不同的共享库重复相连，这样就会增大APP的大小。这时候可以将通过用模块作为共享库,不过这样必须是一个NDK项目123456789101112131415161718192021LOCAL_PATH := $(call my-dir)#第三方AVI库include $(CLEAR_VARS)LOCAL_MODULE :=avilibLOCAL_SRC_FILES :=abilib.c platfrom_posix.cinclude $(BUILD_SHARED_LIBRARY)#原生模块1include $(CLEAR_VARS)OCAL_MODULE :=module1LOCAL_SRC_FILES :=module1.cLOCAL_SHARED_LIBRARIES :avilibinclude $(BUILD_SHARED_LIBRARY)#原生模块2include $(CLEAR_VARS)OCAL_MODULE :=module2LOCAL_SRC_FILES :=module2.cLOCAL_SHARED_LIBRARIES :avilibinclude $(BUILD_SHARED_LIBRARY) 多个NDK项目之间共享模块 首先先将avilib源码移动到NDK项目以外的位置，比如C:\\android\\shared-modules\\transcode\\avilib 作为共享模块，avilib需要有自己的Android.mk文件 以transcode/avilib为参数调用函数宏import-module添加到NDK项目的Android.mk文档末尾。 12345678910111213141516171819202122232425#avilib模块自己的Android.mk文件LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE :=avilibLOCAL_SRC_FILES :=abilib.c platfrom_posix.cinclude $(BUILD_SHARED_LIBRARY)----------------------------#使用共享模块的NDK项目1的Android.mk文件LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)OCAL_MODULE :=module1LOCAL_SRC_FILES :=module1.cLOCAL_SHARED_LIBRARIES :avilibinclude $(BUILD_SHARED_LIBRARY)$(call import-module,transcode/avilib)----------------------------#使用共享模块的NDK项目2的Android.mk文件LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)OCAL_MODULE :=module2LOCAL_SRC_FILES :=module2.cLOCAL_SHARED_LIBRARIES :avilibinclude $(BUILD_SHARED_LIBRARY)$(call import-module,transcode/avilib) 使用预编译库 如果想在不发布代码的情况下将模块发布给他人或者想使用共享模块的预编译版本来急速编译过程1234567#预编译共享模块的Android.mk文件LOCAL_PATH := $(call my-dir)#第三方预编译库include $(CLEAR_VARS)LOCAL_MODULE :=avilibLOCAL_SRC_FILES :=libavilib.soinclude $(BUILD_SHARED_LIBRARY) 编译独立的可执行文件 为了方便测试和进行快速开发，可以编译成可执行文件。不用打包成APK就可以复制到Andorid设备上执行 1234567#独立可执行模块的Android.mk文件LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)OCAL_MODULE :=moduleLOCAL_SRC_FILES :=module.cLOCAL_SHARED_LIBRARIES :avilibinclude $(BUILD_EXECUTABLE) 注意： 如果我们本地库libhello-jni.so依赖于libTest.so(可以使用NDK下的ndk-depends查看so的依赖关系) 在Android6.0版本之前，需要在加载本地库钱先加载被依赖的so库 在Android6.0版本之后，不能再使用预编译的动态库（静态库没问题） 12345#Android 6.0版本之前System.loadLibrary(&quot;Test&quot;);Systen.loadLibrary(&quot;hello-jni&quot;);#Android 6.0版本之后System.loadLibrary(&quot;hello-jni&quot;) Andorid.mk的简单使用使用AndroidStudio新建一个空项目。 在MainActivity中定义native方法nativeTest 1public static native int nativeTest(); 在main文件夹的同级新建一个ndkbuild目录，里面创建两个文件”hello-jni.c”和”Andorid.mk” 1234567#include &lt;jni.h&gt;int test(){ return 123456;}jint Java_com_chs_ndktest_MainActivity_nativeTest(){ return test();} 123456789101112131415#定义模块当前的路径（必须定义在文件开头，只需要定义一次）LOCAL_PATH := $(call my-dir)#Makefile中可以引入其他的Makefile文件#编译模块时，清空当前环境变量（LOCAL_PATH除外）include $(CLEAR_VARS)#当前模块名（这里会生成libhello-jni）LOCAL_MODULE :=hello-jni#编译所需要的源文件 多个文件以空格隔开LOCAL_SRC_FILES :=hello-jni.c#表示当前模块将要被编译成一个共享库include $(BUILD_SHARED_LIBRARY) 修改gradle文件，配置支持的cup和Android.mk的路径12345678910111213141516171819defaultConfig { applicationId &quot;com.chs.ndktest&quot; minSdkVersion 15 targetSdkVersion 28 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; externalNativeBuild{ ndkBuild{ //例子使用模拟器测试，所以编译x86的，现在主流手机都是arm-v7a的 abiFilters &quot;x86&quot; } } } externalNativeBuild{ ndkBuild{ path &quot;src/main/ndkbuild/Android.mk&quot; } } 这时候build工程，查看生成的apk文件，在lib目录下就可以看到一个hello-jni.so的文件 最后在MainActivity中加载hello-jni.so动态库，并调用方法显示在TextView上12345678910{ System.loadLibrary(&quot;hello-jni&quot;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = findViewById(R.id.tv_test); textView.setText(&quot;hello&quot;+nativeTest()); } 运行在模拟器上就会看到TextView上会显示hello12346，成功。 如今AndroidStudio对Makefile的支持基本上不支持了。现在都用CMake语法，不过HIA有一些老项目会用到，所以Makefile还要了解一下。","link":"/2019/05/19/technology/Makefile相关/"},{"title":"C基础知识","text":"C基础知识 Hello World从hello wrld开始1234#include &lt;stdio.h&gt;printf(\"hello world\\n\"); system(\"pause\"); 内存物理角度：内存是计算机中必不可少的一部分，是跟CPU沟通的桥梁，计算机中所有的程序都是运行在内存中。 逻辑角度：内存是一块具备随机访问能力，支持读、写操作，用来存放程序运行中产生的数据的区域。 内存：位（bit），字节（1byte=8bit），KB（1KB=1024字节）MB（1MB=1024KB） 内存编址：计算机中内存按字节编址，每个地址的存储单元可以存放一个字节（8bit）的数据，CPU通过内存地址回去指令和数据，并不关心这个地址所代表的控件具体在什么位置，怎么分布，因为硬件的设计保证一个地址对应着一个具体的空间。 内存地址：通常使用16进制的数值表示，指向内存中某一个区域。 动态内存分配静态内存分配1int a[1024 * 1024 * 10]; C的内存组成： 运行时系统分配空间：栈，堆 编译时编译器分配的空间：BSS段（存放全局的成员变量），数据段（一段数据），代码段（转化后的汇编指令） c语言的内存分配 栈区(stack)自动分配释放（比如window中一般2 M） 堆区 (heap)手动分配释放（可以占用操作系统%80内存） 全局区或者静态区 字符常量区 程序代码区 动态内存分配123456789101112131415161718192021222324252627282930//栈内存void stackFun(){ int a[1024]}//堆内存void heapFun(){ //申请内存空间 int *p = malloc(1024*1024*4) //释放内存 free(p)}//动态内存分配（相当于java中的集合）int len = 5;//申请内存，申请完之后，p就变成一个数组int *p = malloc(len*sizeof(int));//也可以用calloc(len,sizeof(int));//给数组赋值int i = 0;for(; i&lt;len-1 ;i++){ p[i] = rand()%100}//释放内存free(p);p=NULL;//使用realloc 重新分配内存//第一个参数：原来指针的内存指针//第二个参数：内存扩大之后的总大小int addLen = 5;int* p2 = realloc(p, sizeof(int) * (len + addLen)); 重新分配内存的两种情况 缩小内存，缩小的那一部分会丢失 扩大内存，如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针 扩大内存，如果当前内存段后面空闲不够，那么就从堆中找到第一个可以满足内存需求的一块内存，把原来的数据复制过来，并释放原来的内存，返回新的地址 扩大内存，如果申请失败，返回NULL，原来的指针仍然有效。 内存分配需要注意的几个细节 不能多次释放 释放完成之后，给指针置NULL，标志释放完成 如果不是使用realloc重新赋值而是malloc给p重新赋值之后，在free，并没有真正的释放，会造成内存泄漏。 12345678910111213void main(){ //给p1赋值 int* p1 = malloc(1024 * 1024 * 10 * sizeof(int)); //先释放内存 free(p1); //打印一下可以看到，释放后p1并不为空 printf(\"%#x\\n\",p1); p1 = NULL; //在给p1重新赋值 p1 = malloc(1024 * 1024 * 10 * sizeof(int) * 2); free(p1); p1 = NULL;} 基本数据类型123456789int %d 字节数：4short %d 字节数：2long %ld 字节数：4（跟java不一样）float %f 字节数：4double %lf 字节数：8char %c 字节数：1%x 十六进制 %0 八进制 %s 字符串 指针指针存储的是变量的内存地址 指针有类型，地址没有类型 比如int类型的指针不能赋值为double类型的指针，因为指针只是指向一个地址的首位。具体走多少需要看类型。1234567891011void main() { int i = 100; //p是int类型的指针，代表这个int类型的值的内存地址 int *p = &amp;i; printf(\"%#x\\n\", p); printf(\"%#x\\n\", &amp;p); printf(\"%#x\\n\", &amp;i); printf(\"%#x\\n\", i); //p是指针，*p代表取地址的值 system(\"pause\");} 多级指针指针保存的是变量的地址，它保存的这个地址变量也可以使一个指针变量。1234567 int a = 50;//p1上保存的a的地址int* p1 = &amp;a;//p2上保存的p1的地址int** p2 = &amp;p1;//通过二级指针改变a的值**p2 = 100; 指针的运算一般用在数组遍历，指针加一，就是向前移动一个数据类型的字节。比如是int类型的，移动4位，double类型的移动8位12345678910111213141516 //数组在内存中是连续存储的int ids[] = { 78, 90, 23, 65, 19 };//数组变量名：ids就是数组的首地址//ids,&amp;ids,&amp;ids[0]的值是一样的printf(\"%#x\\n\",ids);printf(\"%#x\\n\",&amp;ids);printf(\"%#x\\n\",&amp;ids[0]);//指针变量int *p = ids;printf(\"%d\\n\",*p);//指针的加法//p++向前移动sizeof(数据类型)个字节p++; printf(\"p的值:%#x\\n\", p);//p--;printf(\"%d\\n\", *p); 通过指针给数组赋值12345int arr[5]; int i = 0;for (; i &lt; 5; i++){ arr[i] = i;} 指针数组 (数组里面存放的是指针) 1int *p[3]; 数组指针（行指针） 1int (*p)[n] 优先级：()&gt;[]&gt;* ，所以首先p是一个指针，指向一个整型数组，这个数组的长度是n，也可以说是p的步长，也就是说执行p+1的时候，p要跨过n个整型的长度。 当浏览一个图片的时候，可以使用数组指针来读取。1234int a[3][4]//定义一个3行4列的二维数组int (*p)[4]//指针数组指向含有4个元素的以为数组p=a//将该二维数组的首地址赋值为p，也就是a[0]或者a[0][0]p++ //执行该语句之后，跨过一行比如从a[0][]指向a[1][] 变量名变量名是对内存空间上的一段数据的抽象，我们可以对p存的内存地址的变量进行操作 也可以定义一个方法，参数就是一个变量的指针，调用方法的时候，传入指针，就可改变这个变量的值。12345678910111213141516void change(int* p){ *p = 300;}void main() { int i = 100; printf(\"i的值为：%d\\n\", i); //p是i的指针 int *p = &amp;i; //通过指针赋值 *p = 200; printf(\"i的值为：%d\\n\", i); //change(p); change(&amp;i); system(\"pause\");} 函数指针函数是一个函数，返回一个指针1234567891011121314//void 是无符号类型，类比于java中的Objectint* int_add_func(void* wParam) { printf(\"指针函数\\n\"); int b = 10; int *p = &amp;b; //指针函数返回一个指针 return p;}void main() { int a = 10; int_add_func(&amp;a); system(\"pause\");} 函数指针是一个变量，是一个指向函数的指针变量。 回调的时候经常用到 12345678910111213141516171819202122232425262728293031323334353637383940//(*funcp)要用括号括起来，括号代表优先级void(*funcp)(int* a, int* b);void point_func(int* a, int* b) { *a = 200; printf(\"函数指针\\n\");}//main函数中，给这个函数指针赋值，//**然后就可以通过它调用这个函数了**。void main() { int b = 20; funcp = point_func; funcp(&amp;a, &amp;b); printf(\"a值 %d\", a); system(\"pause\");}-----------------------------------int add(int a,int b){ return a + b;}int minus(int a,int b){ return a - b;}void msg(int(*func_p)(int a, int b), int m, int n){ printf(\"执行一段代码...\\n\"); printf(\"执行回调函数...\\n\"); int r = func_p(m, n); printf(\"执行结果：%d\\n\",r);}void main(){ //加法 //msg(add,50,10); //减法 //msg(minus,50,10);}//定义两个方法 add,minus。msg这个方法中，需要传入一个//函数指针int(*func_p)(int a, int b)和两个值//只要是返回int值，传入两个参数的这种方法，//都可以传入到msg方法中计算。 字符串使用字符数组来存储字符串12345//'\\0'代表结束char str[] = {'a','b','c','d','e','\\0'};char str[6] = {'a','b','c','d','e'};char str[10]=\"china\";str[0] = 's'; 字符指针12345678910111213141516171819202122232425262728293031323334353637//内存连续排列char *str = \"hello world\";//不能修改，下一行代码会报错str[0] = 's';//使用指针加法，截取字符串 str += 3; while (*str){ printf(\"%c\",*str); str++; }//字符串拼接void main(void){ char dest[50]; char *a = \"china\"; char *b = \" is powerful!\"; strcpy(dest, a); strcat(dest, b); printf(\"%s\\n\", dest); system(\"pause\");}//查找一个字符的位置void main(void){ char *str = \"I want go to USA!\"; printf(\"%#x\\n\", str); //U元素的指针 //str+3 char* p = strchr(str, 'w'); if (p){ printf(\"索引位置：%d\\n\", p - str); } else{ printf(\"没有找到\"); } system(\"pause\");} 操作字符串的在线API文档：http://www.kuqin.com/clib/string/strcpy.html 结构体相当于java中的类。把不同的数据类型整合起来 几种结构体的写法123456789101112131415161718192021222324252627282930struct Man { char name[20]; int age;};//s1 s2是结构体的变量名struct student { char name[20]; int age;} s1 ,s2;//匿名结构体 相当于单例struct { char name[20]; int age;} m1;//赋值方式如下void main(){ struct Man man; man.age = 10; strcpy(man.name,\"chs\"); s1.age = 11; strcpy(s1.name, \"lr\"); m1.age = 12; strcpy(m1.name, \"czg\"); system(\"pause\");} 结构体嵌套 12345678910111213141516171819202122232425//第一种写法struct student { char name[20]; int age;} s1 ,s2;struct teacher { char name[20]; struct student s;} t;//第二种写法struct teacher { char name[20]; struct student { char name[20]; int age; } s;};//赋值方式void main(){ strcpy(t.name, \"czg\"); t.s.age = 13; strcpy(t.s.name, \"cxh\"); system(\"pause\");} 结构体指针12345678910111213141516struct student { char name[20]; int age;};void main(){ struct student s = {\"czl\",12}; struct student *p = &amp;s; //使用指针赋值 p-&gt;age = 20; strcpy(p-&gt;name, \"xc\"); //使用变量赋值 s.age = 20; strcpy(s.name, \"xc\"); system(\"pause\");} 结构体数组和指针1234567891011121314151617181920struct student { char name[20]; int age;};void main(){ struct student stus[] = { {\"Jack\",20}, {\"Rose\", 19} }; //遍历结构体数组 //第一种方式,使用指针 struct student *p = stus; for (; p&lt; stus + 2;p++) { printf(\"%s,%d\\n\", p-&gt;name, p-&gt;age); } //第二种方式，使用变量 int i = 0; for (; i &lt; sizeof(stus) / sizeof(struct student); i++) { printf(\"%s,%d\\n\", stus[i].age, stus[i].name); } system(\"pause\");} 结构体的大小123456789struct Man{ int age; double weight; };void main(){ struct Man m1 = {20,55.0}; printf(\"%#x,%d\\n\", &amp;m1,sizeof(m1)); getchar();} 上面的结构体有两个变量一个int类型一个double类型，通过打印可以看到，该结构体的大小是16。 这就是结构体的内存对齐，结构体的大小，是其内部最大数据类型的整数倍，如果在加一个int类型的变量，那大小就是24。这样做的原因是为了提升效率，以空间换时间。 结构体动态内存分配12345678910111213141516171819struct Man { int age; char *name;};void main(){ //开辟一块内存 struct Man *p = (struct Man*)malloc(sizeof(struct Man) * 10); //赋值 struct Man *mp = p; mp-&gt;age = 18; mp-&gt;name = \"lily\"; //循环遍历 struct Man *lop = p; for (; lop &lt; p + 2;lop++) { printf(\"%s,%d\\n\", lop-&gt;name, lop-&gt;age); } system(\"pause\");} typedef 类型取别名取别名好处：让代码简洁，不同情况下使用不同的别名，不同的名称代表干不同的事情12345678910111213141516171819202122232425//Age int类型指针的别名typedef int Age;//Age int类型指针的别名typedef int* Ap;struct Man{ char name[20]; int age;};//给结构体取别名typedef struct Man M;typedef struct Man* MP;void main(){ int i = 5; Ap p = &amp;i; //结构体变量 M m1 = {\"Rose\",20}; //结构体指针 MP mp1 = &amp;w1; printf(\"%s,%d\\n\", m1.name, m1.age); printf(\"%s,%d\\n\", mp1-&gt;name, mp1-&gt;age); getchar();} 结构体函数指针成员Girl了类似于java中的类，sayHi类似于java中的方法。1234567891011121314151617181920212223242526struct Girl{ char *name; int age; //函数指针 void(*sayHi)(char*);};struct Girl { char *name; int age; //函数指针 void(*sayHi)(char*);};void sayHi(char *text) { printf(text);}void main(){ struct Girl gl; gl.age = 18; gl.name = \"lily\"; gl.sayHi = sayHi; gl.sayHi(\"hello\"); system(\"pause\");} 给Gril类取别名。在c中大多数情况下都是操作的指针123456789101112131415161718192021222324252627282930typedef struct Girl { char *name; int age; //函数指针 void(*sayHi)(char*);} Girl;//定义一个Girl的指针类型typedef Girl *GirlP;void sayHi(char *text) { printf(text);}//改名方法需要传入指针类型void rename(GirlP gp1) { gp1-&gt;name = \"Lily\";}void main(){ Girl gl; gl.age = 18; gl.name = \"lily\"; gl.sayHi = sayHi; gl.sayHi(\"hello\"); //拿到指针 GirlP gpl = &amp;gl; //传入指针改名。使用变量是无法改名的。 rename(gpl); system(\"pause\");} 共用体（联合体）共用体是一种特殊的数据类型，允许相同的内存位置存储不同的数据类型，比如定义一个多成员的共用体，它同一个时间只能有一个成员有值。 目的就是为了节省内存，共用体的大小取决于最大的类型的大小。12345678910111213141516171819202122union MyValue{ int x; short y; double z;};void main(){ union MyValue d1; d1.x = 90; d1.y = 100; d1.z = 23.8;//最后一次赋值有效 printf(\"%d,%d,%lf\\n\", d1.x, d1.y, d1.z); system(\"pause\");} 上面的例子通过打印之后看到，只有最后一个d1.z有值。 枚举1234567891011121314151617enum Day{ Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};void main() { //枚举的值，必须是括号中的值 enum Day d = Monday; printf(\"%#x,%d\\n\", &amp;d, d); getchar();} c中的文件操作读取文件1234567891011121314151617void main() { char *path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\2.1.txt\"; //r代表只读 FILE *fp = fopen(path, \"r\"); if (fp == NULL) { printf(\"文件打开失败...\"); return; } //缓冲 char buff[50]; while (fgets(buff, 50, fp)) { printf(\"%s\", buff); } fclose(fp); system(\"pause\");} 写入文件123456789101112void main() { char *path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\3.1.txt\"; //打开 w代表写 FILE *fp = fopen(path, \"w\"); char *text = \"你好 世界\"; fputs(text, fp); //关闭流 fclose(fp); system(\"pause\");} 读取二进制文件并复制1234567891011121314151617181920void main() { char *path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\color_filter.jpg\"; char *path_new = \"C:\\\\Users\\\\83734\\\\Desktop\\\\color_filter_new.jpg\"; //读的指针 rb代表读取二进制 FILE *read_fp = fopen(path, \"rb\"); //写的指针 wb代表写入二进制 FILE *write_fp = fopen(path_new, \"wb\"); //缓冲区 int buff[50]; //每次读取到的数据的长度 int len = 0; while ((len = fread(buff,sizeof(int),50,read_fp))!=0) { fwrite(buff,sizeof(int),len,write_fp); } //关闭流 fclose(read_fp); fclose(write_fp); system(\"pause\");} c读写文本文件和二进制文件的差别，只在回车换行符上面，写文本的时候每遇到一个\\n就会将其转换成\\r\\n，读文本的时候，每遇到一个\\r\\n就会将其转换成\\n。 获取一个文件的大小,可以通过fseek和ftell1234567891011121314void main() { char *path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\color_filter.jpg\"; //读的指针 rb代表读取二进制 FILE *read_fp = fopen(path, \"rb\"); //重新定位文件指针 //SEEK_END文件末尾，0偏移量 fseek(read_fp, 0, SEEK_END); //返回当前的文件指针，相对于文件开头的位移量 long filesize = ftell(read_fp); printf(\"%d\\n\", filesize); fclose(read_fp); system(\"pause\");} 文件的加解密 可以读取每个文件的字符，然后给每个字符做异或运算，解密的时候在做一次异或运算123456789101112131415161718192021222324252627282930313233343536373839//加密void crpypt(char normal_path[], char crpypt_path[]) { //打开文件 FILE *normal_fp = fopen(normal_path, \"r\"); FILE *crypt_fp = fopen(crpypt_path, \"w\"); //一次读取一个字符 int ch; while ((ch = fgetc(normal_fp)) != EOF) { //End of File //写入（异或运算） fputc(ch ^ 3, crypt_fp); } //关闭 fclose(crypt_fp); fclose(normal_fp);}//解密void decrpypt(char crpypt_path[], char decrpypt_path[]) { //打开文件 FILE *normal_fp = fopen(crpypt_path, \"r\"); FILE *crypt_fp = fopen(decrpypt_path, \"w\"); //一次读取一个字符 int ch; while ((ch = fgetc(normal_fp)) != EOF) { //End of File //写入（异或运算） fputc(ch ^ 3, crypt_fp); } //关闭 fclose(crypt_fp); fclose(normal_fp);}void main() { char *path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\2.1.txt\"; char *path_c = \"C:\\\\Users\\\\83734\\\\Desktop\\\\2.1.1.txt\"; char *path_de = \"C:\\\\Users\\\\83734\\\\Desktop\\\\2.1.2.txt\"; //crpypt(path,path_c); decrpypt(path_c, path_de);} 前面的加解密都是跟一个3异或，有时候我们可以使用一个字符串作为密码比如“abcd”,读取到的每一个字符循环跟字符串中的字符异或。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//加密void crpypt(char normal_path[], char crypt_path[],char password[]){ //打开文件 FILE *normal_fp = fopen(normal_path, \"rb\"); FILE *crypt_fp = fopen(crypt_path, \"wb\"); //一次读取一个字符 int ch; int i = 0; //循环使用密码中的字母进行异或运算 int pwd_len = strlen(password); //密码的长度 while ((ch = fgetc(normal_fp)) != EOF){ //End of File //写入（异或运算） fputc(ch ^ password[i % pwd_len], crypt_fp); i++; } //关闭 fclose(crypt_fp); fclose(normal_fp);}//解密void decrpypt(char crypt_path[], char decrypt_path[],char password[]){ //打开文件 FILE *normal_fp = fopen(crypt_path, \"rb\"); FILE *crypt_fp = fopen(decrypt_path, \"wb\"); //一次读取一个字符 int ch; int i = 0; //循环使用密码中的字母进行异或运算 int pwd_len = strlen(password); //密码的长度 while ((ch = fgetc(normal_fp)) != EOF){ //End of File //写入（异或运算） fputc(ch ^ password[i % pwd_len], crypt_fp); i++; } //关闭 fclose(crypt_fp); fclose(normal_fp);}void main(){ char *normal_path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\color_filter.jpg\"; char *crypt_path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\color_filter_c.jpg\"; char *decrypt_path = \"C:\\\\Users\\\\83734\\\\Desktop\\\\color_filter_de.jpg\"; //crpypt(normal_path, crypt_path,\"abcd\"); decrpypt(crypt_path, decrypt_path,\"abcd\");} C语言的执行流程 编译：形成目标代码（.obj） 连接：将目标代码与c函数库连接合并，形成最终的可执行文件 执行 预编译阶段，主要为编译做准备工作，完成代码的替换。头文件告诉编译器有这么一个函数，连接器负责到代码中找到这个函数 define(宏定义、宏替换 、预编译指令)define指令 定义标示（#ifdef __cplusplus 标识支持C++语法） 定义常数（#define MAX 100） 定义宏函数，简化比较麻烦的函数1234567891011121314void dn_com_jni_read(){ printf(\"read\\n\");}void dn_com_jni_write(){ printf(\"write\\n\");}//定义宏函数 NAME是参数#define jni(NAME) dn_com_jni_##NAME();void main(){ //直接调用定义的宏函数 jni(write);//替换：dn_com_jni_write(); getchar();} c中的库库可以通过gcc命令编译 1234//动态库gcc -shared -fPIC -o libtest.so test.c //静态库gcc -static -fPIC -o libtest.so test.c 动态库：.so/.dll 静态库：.a/.lib 动态库类似于android中的.jar文件 静态库类似于andorid中的.arr文件","link":"/2019/05/12/technology/C基础知识/"},{"title":"RecycleView的缓存原理","text":"RecycleView的缓存原理 上一篇文章RecycleView的绘制流程，当我们走到子View的布局流程的layoutChunk方法的时候，通过View view = layoutState.next(recycler);方法获取将要布局的子View，然后进行后续操作，现在来看一下这个子View是怎么获取的。12345678View next(RecyclerView.Recycler recycler) { if (mScrapList != null) { return nextViewFromScrapList(); } final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view; } 可以看到是通过recycler.getViewForPosition这个方法获取的123456public View getViewForPosition(int position) { return getViewForPosition(position, false); }View getViewForPosition(int position, boolean dryRun) { return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView; } tryGetViewHolderForPositionByDeadline方法返回的是一个ViewHolder对象，然后直接返回ViewHolder的成员变量itemView，也就是当前将要布局的子view。 到这里还没有涉及到缓存的代码，我们也可以猜测，RecycleView的缓存，不只是对View缓存，是对ViewHolder的缓存。 tryGetViewHolderForPositionByDeadline这个方法是真正的缓存机制的入口，它是RecycleView.Recycler中的方法，按照我们正常的思维想想里面肯定是先从缓存中去，取不到在新建一个，那么这个缓存是啥呢，在进入tryGetViewHolderForPositionByDeadline方法之前我们先看几个Recycler中的成员变量方便看下面的代码123456789101112131415161718public final class Recycler { final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2; ...... 这几个就是用来缓存的List了 mAttachedScrap：不参与复用，只保存在重新布局的时候，从RecycleView中剥离的当前在显示的ViewHolder列表。比如当我们插入一条或者删除一条数据，这时候需要重新布局，怎么办呢，办法就是把当前屏幕上显示的view先拿下来保存到一个列表中，然后在重新布局上去。这个列表就是mAttachedScrap。所以它只是存储重新布局前从RecycleView上剥离出的ViewHolder，并不参与复用 mUnmodifiableAttachedScrap：通过Collections.unmodifiableList(mAttachedScrap)，把mAttachedScrap放进去，返回一个不可更改的列表，共外部获取 mChangedScrap：不参与复用 从新布局的时候要修改的放到这里面，其余的放到mAttachedScrap mCachedViews：从名字就能看出来这就是参与缓存的list mRecyclerPool：参与缓存，并且它里面的ViewHolder的信息都会被重置，相当于一个新建的ViewHolder，供后面使用 mViewCacheExtension：这个是让我们自己扩展自己的缓存策略，一般情况下我们不会自己写这东西的。 所以，mCachedViews ，mRecyclerPool ， mViewCacheExtension 这三个组成了一个三级缓存，当RecyclerView要拿一个复用的ViewHolder的时候，查找的顺序是mCachedViews-&gt;mViewCacheExtension-&gt;mRecyclerPool。因为一般情况下我们不会写mViewCacheExtension，所以一般情况就两级缓存mCachedViews-&gt;mRecyclerPool 实际上mCachedViews是不参与真正的回收的，mCachedViews的作用是保存最新被移除的ViewHolder，通过removeAndRecycleView(view, recycler)方法，它的作用是，当需要更新ViewHoder的时候，精确的匹配是不是刚才移除那个，如果是直接拿出来让RecycleView布局，如果不是，即使它中存在ViewHolder，也不会返回，而是去mRecyclerPool中找一个新的ViewHolder然后重新赋值。mAttachedScrap中也是精确匹配步骤跟mCachedViews一样。 OK下面我们进入tryGetViewHolderForPositionByDeadline方法中看看到底是怎么取的吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) { if (position &lt; 0 || position &gt;= mState.getItemCount()) { throw new IndexOutOfBoundsException(\"Invalid item position \" + position + \"(\" + position + \"). Item count:\" + mState.getItemCount() + exceptionLabel()); } boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) 是否处于布局前的状态 去mChangedScrap中找，布局前的状态也就是重新布局的时候 if (mState.isPreLayout()) { holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; } // 1) 先从mAttachedScrap中找，找不到在去mCachedViews中查找 if (holder == null) { holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) { if (!validateViewHolderForOffsetPosition(holder)) { // 检查是不是我们要查找的viewholder，如果不是移除 if (!dryRun) { // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) { removeDetachedView(holder.itemView, false); holder.unScrap(); } else if (holder.wasReturnedFromScrap()) { holder.clearReturnedFromScrapFlag(); } //回收这个holder 放到mCachedViews或者mRecyclerPool中 recycleViewHolderInternal(holder); } holder = null; } else { fromScrapOrHiddenOrCache = true; } } } if (holder == null) { final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) { throw new IndexOutOfBoundsException(\"Inconsistency detected. Invalid item \" + \"position \" + position + \"(offset:\" + offsetPosition + \").\" + \"state:\" + mState.getItemCount() + exceptionLabel()); } final int type = mAdapter.getItemViewType(offsetPosition); // 2)通过id精确的从mAttachedScrap中查找 if (mAdapter.hasStableIds()) { holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) { // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; } } //如果我们自定义了缓存策略 if (holder == null &amp;&amp; mViewCacheExtension != null) { // We are NOT sending the offsetPosition because LayoutManager does not // know it. final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) { holder = getChildViewHolder(view); if (holder == null) { throw new IllegalArgumentException(\"getViewForPositionAndType returned\" + \" a view which does not have a ViewHolder\" + exceptionLabel()); } else if (holder.shouldIgnore()) { throw new IllegalArgumentException(\"getViewForPositionAndType returned\" + \" a view that is ignored. You must call stopIgnoring before\" + \" returning this view.\" + exceptionLabel()); } } } if (holder == null) { // fallback to pool if (DEBUG) { Log.d(TAG, \"tryGetViewHolderForPositionByDeadline(\" + position + \") fetching from shared pool\"); } //去mRecyclerPool中查找 根据不同的type拿到不同的holder， //type就是我们在adapter中写的getItemViewType holder = getRecycledViewPool().getRecycledView(type); if (holder != null) { holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) { invalidateDisplayListInt(holder); } } } if (holder == null) { long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) { // abort - we have a deadline we can't meet return null; } //缓存中找不到调用createViewHolder创建 holder = mAdapter.createViewHolder(RecyclerView.this, type); if (ALLOW_THREAD_GAP_WORK) { // only bother finding nested RV if prefetching RecyclerView innerView = findNestedRecyclerView(holder.itemView); if (innerView != null) { holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView); } } long end = getNanoTime(); mRecyclerPool.factorInCreateTime(type, end - start); if (DEBUG) { Log.d(TAG, \"tryGetViewHolderForPositionByDeadline created new ViewHolder\"); } } } // This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM. if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) { holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (mState.mRunSimpleAnimations) { int changeFlags = ItemAnimator .buildAdapterChangeFlagsForAnimations(holder); changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState, holder, changeFlags, holder.getUnmodifiedPayloads()); recordAnimationInfoIfBouncedHiddenView(holder, info); } } boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) { // do not update unless we absolutely have to. holder.mPreLayoutPosition = position; } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {//如果没有绑定数据 if (DEBUG &amp;&amp; holder.isRemoved()) { throw new IllegalStateException(\"Removed holder should be bound and it should\" + \" come here only in pre-layout. Holder: \" + holder + exceptionLabel()); } final int offsetPosition = mAdapterHelper.findPositionOffset(position); //调用bindViewHolder bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); } //给holder中的itemView设置LayoutParams final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams(); final LayoutParams rvLayoutParams; if (lp == null) { rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams); } else if (!checkLayoutParams(lp)) { rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams); } else { rvLayoutParams = (LayoutParams) lp; } rvLayoutParams.mViewHolder = holder; rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound; return holder; } 从上面源码可以总结一下的流程，先去mAttachedScrap中找。是要是看看View是不是刚刚剥离的，如果是直接返回如果不是，去mCachedViews中查找，mCachedViews中是精确查找，如果找到返回，找不到或者匹配不上就去mRecyclerPool中查找，找到了返回一个全新的ViewHolder，找不到的话只能调用onCreateViewHolder新建一个了。 mAttachedScrap和mCachedViews都是精确查找，找到的ViewHolder都是已经绑定好数据的，不会再调用onBindViewHolder重新绑定数据，mRecyclerPool中的ViewHolder都是清理干净的空白的ViewHolder，找到之后需要调用onBindViewHolder重新绑定数据，这点我们可以从上面代码中的第二步那跟进去看看getScrapOrCachedViewForId方法1234567891011121314151617181920212223242526272829303132333435363738394041424344ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) { // Look in our attached views first final int count = mAttachedScrap.size(); for (int i = count - 1; i &gt;= 0; i--) { final ViewHolder holder = mAttachedScrap.get(i); //判断id是否一致 是不是从Scrap中返回 //是才返回，不是去mCachedViews中找 if (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) { if (type == holder.getItemViewType()) { holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); if (holder.isRemoved()) { if (!mState.isPreLayout()) { holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED); } } return holder; } else if (!dryRun) { mAttachedScrap.remove(i); removeDetachedView(holder.itemView, false); quickRecycleScrapView(holder.itemView); } } } // Search the first-level cache final int cacheSize = mCachedViews.size(); for (int i = cacheSize - 1; i &gt;= 0; i--) { final ViewHolder holder = mCachedViews.get(i); //判断id是否一致，是才返回不是放入mRecyclerPool中并从mCachedViews中移除 if (holder.getItemId() == id) { if (type == holder.getItemViewType()) { if (!dryRun) { mCachedViews.remove(i); } return holder; } else if (!dryRun) { recycleCachedViewAt(i); return null; } } } return null; } 可以看到上面的代码中，从对应的缓存中找到holder之后，都会判断一下是不是想要的那个holder，是的话才会返回。 那RecycleView到底是怎么复用的呢？入口很多比如通过Recycler中的recycleView方法（recycler.recycleView）进去看看1234567891011121314public void recycleView(View view) { // This public recycle method tries to make view recycle-able since layout manager // intended to recycle this view (e.g. even if it is in scrap or change cache) ViewHolder holder = getChildViewHolderInt(view); if (holder.isTmpDetached()) { removeDetachedView(view, false); } if (holder.isScrap()) { holder.unScrap(); } else if (holder.wasReturnedFromScrap()) { holder.clearReturnedFromScrapFlag(); } recycleViewHolderInternal(holder); } 这个方法用于回收分离的视图和把指定的视图放到缓存池中用于重新绑定和复用。最后调用了recycleViewHolderInternal方法，recycleViewHolderInternal这个方法时最终的回收方法，有的入口直接调用了这个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void recycleViewHolderInternal(ViewHolder holder) { ...... boolean cached = false; boolean recycled = false; if (DEBUG &amp;&amp; mCachedViews.contains(holder)) { throw new IllegalArgumentException(\"cached view received recycle internal? \" + holder + exceptionLabel()); } if (forceRecycle || holder.isRecyclable()) { if (mViewCacheMax &gt; 0 &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) { // Retire oldest cached view int cachedViewSize = mCachedViews.size(); //mViewCacheMax的值是2，所以mCachedViews中最多缓存两条数据 if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) { //根据先进先出原则，把最老的从mCachedViews中放到mRecyclerPool中 recycleCachedViewAt(0); cachedViewSize--; } int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK &amp;&amp; cachedViewSize &gt; 0 &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) { // when adding the view, skip past most recently prefetched views int cacheIndex = cachedViewSize - 1; while (cacheIndex &gt;= 0) { int cachedPos = mCachedViews.get(cacheIndex).mPosition; if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) { break; } cacheIndex--; } targetCacheIndex = cacheIndex + 1; } //将最近刚刚回收的ViewHolder放在mCachedViews里 mCachedViews.add(targetCacheIndex, holder); cached = true; } //如果不设置往mCachedViews中放，就放入mRecyclerPool if (!cached) { addViewHolderToRecycledViewPool(holder, true); recycled = true; } } else { // NOTE: A view can fail to be recycled when it is scrolled off while an animation // runs. In this case, the item is eventually recycled by // ItemAnimatorRestoreListener#onAnimationFinished. // TODO: consider cancelling an animation when an item is removed scrollBy, // to return it to the pool faster if (DEBUG) { Log.d(TAG, \"trying to recycle a non-recycleable holder. Hopefully, it will \" + \"re-visit here. We are still removing it from animation lists\" + exceptionLabel()); } } // even if the holder is not removed, we still call this method so that it is removed // from view holder lists. mViewInfoStore.removeViewHolder(holder); if (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) { holder.mOwnerRecyclerView = null; } } 从这里面我们看到了熟悉的mCachedViews和mRecyclerPool，这也说明了RecycleView的回收机制跟mAttachedScrap是没有关系的。 那这个回收到底是从哪里调用的呢？第一个地方就是在LayoutManager的onLayoutChildren方法中调用的detachAndScrapAttachedViews(recycler);，另一个就是Recyclerview滑动的时候调用removeAndRecycleView方法。 detachAndScrapAttachedViews仅用于布局之前，将所有的子view剥离，放在mAttachedScrap中供后面重新布局的时候使用。 removeAndRecycleView在滚动的时候，把ViewHolder标记为removed，先缓存在mCachedViews中，mCachedViews的最大容量为2，如果mCachedViews中存满了，把最先缓存进来的拿出来放到mRecyclerPool，mRecyclerPool中默认缓存5个。然后把最新的放入mCachedViews中缓存。 OK，结束。 参考： https://www.cnblogs.com/dasusu/p/7746946.html https://www.jianshu.com/p/504e87089589 https://blog.csdn.net/harvic880925/article/details/84866486","link":"/2019/04/05/technology/RecycleView的缓存原理/"},{"title":"UI绘制流程--View是如何被添加到屏幕上的","text":"我们平时打开一个activity的时候，设置我们的视图都是在onCreate的setContentView方法开始，那我们就从这个方法开始看源码。 这里我们继承的是AppCompatActivity 12345678910public void setContentView(@LayoutRes int layoutResID) { this.getDelegate().setContentView(layoutResID); }public void setContentView(View view) { this.getDelegate().setContentView(view); }public void setContentView(View view, LayoutParams params) { this.getDelegate().setContentView(view, params); } 这里有三个重载的方法，原理都一样，我们平时最常用的就是放入一个xml文件了，所以从第一个往下看。调用了getDelegate()的setContentView方法123456789public AppCompatDelegate getDelegate() { if (this.mDelegate == null) { this.mDelegate = AppCompatDelegate.create(this, this); } return this.mDelegate; }public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) { return new AppCompatDelegateImpl(activity, activity.getWindow(), callback); } 可以看到getDelegate最后返回了AppCompatDelegateImpl实例传入了activity window和callback，所以也就是调用了它的setContentView方法。12345678910public void setContentView(int resId) { //确保mSubDecor已经创建 this.ensureSubDecor(); //找到contentParent ViewGroup contentParent = (ViewGroup)this.mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); //把我们的view放入contentParent中 LayoutInflater.from(this.mContext).inflate(resId, contentParent); this.mOriginalWindowCallback.onContentChanged(); } 首先调用了ensureSubDecor()方法，从名字来看感觉是确保某个view已经创建。然后从mSubDecor这个ViewGroup中通过id找到contentParent,可以猜测这个mSubDecor应该就是从前面的方法中创建的。然后把我们的view放进去。先看ensureSubDecor()方法。123456789101112131415161718192021222324252627private void ensureSubDecor() { if (!this.mSubDecorInstalled) { //果然是从这里创建的 this.mSubDecor = this.createSubDecor(); CharSequence title = this.getTitle(); if (!TextUtils.isEmpty(title)) { if (this.mDecorContentParent != null) { this.mDecorContentParent.setWindowTitle(title); } else if (this.peekSupportActionBar() != null) { this.peekSupportActionBar().setWindowTitle(title); } else if (this.mTitleView != null) { this.mTitleView.setText(title); } } this.applyFixedSizeWindow(); //回调此view this.onSubDecorInstalled(this.mSubDecor); //标记已经创建完 this.mSubDecorInstalled = true; AppCompatDelegateImpl.PanelFeatureState st = this.getPanelState(0, false); if (!this.mIsDestroyed &amp;&amp; (st == null || st.menu == null)) { this.invalidatePanelMenu(108); } } } 上面这段代码主要就是调用了createSubDecor()方法创建了mSubDecor这个ViewGroup,并回调和标记已创建。所以createSubDecor()是个关键方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128private ViewGroup createSubDecor() { //获取属性 TypedArray a = this.mContext.obtainStyledAttributes(styleable.AppCompatTheme); if (!a.hasValue(styleable.AppCompatTheme_windowActionBar)) { a.recycle(); //如果不设置AppCompat相关的主题就报错 throw new IllegalStateException(\"You need to use a Theme.AppCompat theme (or descendant) with this activity.\"); } else { //根据拿到的主题属性来设置相应的主题风格 if (a.getBoolean(styleable.AppCompatTheme_windowNoTitle, false)) { this.requestWindowFeature(Window.FEATURE_NO_TITLE); } else if (a.getBoolean(styleable.AppCompatTheme_windowActionBar, false)) { this.requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR); } if (a.getBoolean(styleable.AppCompatTheme_windowActionBarOverlay, false)) { this.requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY); } if (a.getBoolean(styleable.AppCompatTheme_windowActionModeOverlay, false)) { this.requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY); } this.mIsFloating = a.getBoolean(styleable.AppCompatTheme_android_windowIsFloating, false); a.recycle(); //获取DecorView this.mWindow.getDecorView(); LayoutInflater inflater = LayoutInflater.from(this.mContext); // ViewGroup subDecor = null; //根据前面设置的不同的主题风格性创建出subDecor，比如FEATURE_NO_TITLE，FEATURE_SUPPORT_ACTION_BAR_OVERLAY if (!this.mWindowNoTitle) { if (this.mIsFloating) { subDecor = (ViewGroup)inflater.inflate(layout.abc_dialog_title_material, (ViewGroup)null); this.mHasActionBar = this.mOverlayActionBar = false; } else if (this.mHasActionBar) { TypedValue outValue = new TypedValue(); this.mContext.getTheme().resolveAttribute(attr.actionBarTheme, outValue, true); Object themedContext; if (outValue.resourceId != 0) { themedContext = new ContextThemeWrapper(this.mContext, outValue.resourceId); } else { themedContext = this.mContext; } subDecor = (ViewGroup)LayoutInflater.from((Context)themedContext).inflate(layout.abc_screen_toolbar, (ViewGroup)null); this.mDecorContentParent = (DecorContentParent)subDecor.findViewById(id.decor_content_parent); this.mDecorContentParent.setWindowCallback(this.getWindowCallback()); if (this.mOverlayActionBar) { this.mDecorContentParent.initFeature(109); } if (this.mFeatureProgress) { this.mDecorContentParent.initFeature(2); } if (this.mFeatureIndeterminateProgress) { this.mDecorContentParent.initFeature(5); } } } else { if (this.mOverlayActionMode) { subDecor = (ViewGroup)inflater.inflate(layout.abc_screen_simple_overlay_action_mode, (ViewGroup)null); } else { subDecor = (ViewGroup)inflater.inflate(layout.abc_screen_simple, (ViewGroup)null); } if (VERSION.SDK_INT &gt;= 21) { ViewCompat.setOnApplyWindowInsetsListener(subDecor, new OnApplyWindowInsetsListener() { public WindowInsetsCompat onApplyWindowInsets(View v, WindowInsetsCompat insets) { int top = insets.getSystemWindowInsetTop(); int newTop = AppCompatDelegateImpl.this.updateStatusGuard(top); if (top != newTop) { insets = insets.replaceSystemWindowInsets(insets.getSystemWindowInsetLeft(), newTop, insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom()); } return ViewCompat.onApplyWindowInsets(v, insets); } }); } else { ((FitWindowsViewGroup)subDecor).setOnFitSystemWindowsListener(new OnFitSystemWindowsListener() { public void onFitSystemWindows(Rect insets) { insets.top = AppCompatDelegateImpl.this.updateStatusGuard(insets.top); } }); } } if (subDecor == null) { throw new IllegalArgumentException(\"AppCompat does not support the current theme features: { windowActionBar: \" + this.mHasActionBar + \", windowActionBarOverlay: \" + this.mOverlayActionBar + \", android:windowIsFloating: \" + this.mIsFloating + \", windowActionModeOverlay: \" + this.mOverlayActionMode + \", windowNoTitle: \" + this.mWindowNoTitle + \" }\"); } else { if (this.mDecorContentParent == null) { this.mTitleView = (TextView)subDecor.findViewById(id.title); } //选择适合系统窗口的装饰 ViewUtils.makeOptionalFitsSystemWindows(subDecor); //获取布局的父容器中的ContentFrameLayout ContentFrameLayout contentView = (ContentFrameLayout)subDecor.findViewById( R.id.action_bar_activity_content); //找到PhoneWindow中的ContentView 如果看activity中的setContentView方法我们知道android.R.id.content就是我们设置的view的父view ViewGroup windowContentView = (ViewGroup)this.mWindow.findViewById(android.R.id.content); if (windowContentView != null) { while(windowContentView.getChildCount() &gt; 0) { View child = windowContentView.getChildAt(0); windowContentView.removeViewAt(0); contentView.addView(child); } //把PhoneWindow中的ContentView设置成没有id windowContentView.setId(View.NO_ID); //把从我们的主题xml中找到的contentView的id设置成android.R.id.content，其实就是以前的PhoneWindow中的ContentView中的id contentView.setId(android.R.id.content); if (windowContentView instanceof FrameLayout) { ((FrameLayout)windowContentView).setForeground((Drawable)null); } } //把subDecor设置给window，mWindow是个Window对象，它只有一个子类就是PhoneWindow this.mWindow.setContentView(subDecor); contentView.setAttachListener(new OnAttachListener() { public void onAttachedFromWindow() { } public void onDetachedFromWindow() { AppCompatDelegateImpl.this.dismissPopups(); } }); return subDecor; } } } 通过上面的源码我们可以知道，通过不同的主题创建出不同的subDecor这个ViewGroup容器，然后把从PhoneWindow中通过android.R.id.content找出原来的contentview然后把它设置成没有id，然后把subDecor中通过R.id.action_bar_activity_content找到的这个view的id重新设置为android.R.id.content来个偷天换日，最后把这个subDecor设置回PhoneWindow中。 我们知道subDecor是通过inflate一个布局文件创建出来的，下面先来看看这个subDecor的布局文件长啥样，源码位置 /frameworks/support/v7/appcompat/res/layout/abc_screen_simple.xml1234567891011121314151617181920212223242526272829&lt;androidx.appcompat.widget.FitWindowsLinearLayout18 xmlns:android=\"http://schemas.android.com/apk/res/android\"19 android:id=\"@+id/action_bar_root\"20 android:layout_width=\"match_parent\"21 android:layout_height=\"match_parent\"22 android:orientation=\"vertical\"23 android:fitsSystemWindows=\"true\"&gt;2425 &lt;androidx.appcompat.widget.ViewStubCompat26 android:id=\"@+id/action_mode_bar_stub\"27 android:inflatedId=\"@+id/action_mode_bar\"28 android:layout=\"@layout/abc_action_mode_bar\"29 android:layout_width=\"match_parent\"30 android:layout_height=\"wrap_content\" /&gt;3132 &lt;include layout=\"@layout/abc_screen_content_include\" /&gt;3334&lt;/androidx.appcompat.widget.FitWindowsLinearLayout&gt;//abc_screen_content_include&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;1819 &lt;androidx.appcompat.widget.ContentFrameLayout20 android:id=\"@id/action_bar_activity_content\"21 android:layout_width=\"match_parent\"22 android:layout_height=\"match_parent\"23 android:foregroundGravity=\"fill_horizontal|top\"24 android:foreground=\"?android:attr/windowContentOverlay\" /&gt;2526&lt;/merge&gt; 可以看到subDecor其实是个FitWindowsLinearLayout。 小插曲：requestWindowFeature，我们以前都用过这个方法， requestWindowFeature(Window.FEATURE_NO_TITLE);用的时候要求我们要放到setContentView()方法之前，为什么呢，前面的代码中我们看到了requestWindowFeature这个方法，跟进去之后，看到调用了this.throwFeatureRequestIfSubDecorInstalled();这个方法12345private void throwFeatureRequestIfSubDecorInstalled() { if (this.mSubDecorInstalled) { throw new AndroidRuntimeException(\"Window feature must be requested before adding content\"); } } 如果mSubDecorInstalled为true就报错，而mSubDecorInstalled这个标志位我们前面的ensureSubDecor()方法中就给他设置为true了。所以此方法要在setContentView()方法之前调用。 OK前面我们很多次提到了mWindow这个成员变量，最终subDecor也是被设置到mWindow中，前面createSubDecor()方法中有两个很重要的指令mWindow.getDecorView();和mWindow.setContentView(subDecor); 进入Window类，它是一个抽象类，看类上面的注释，可以知道它只有一个子类PhoneWindow，所以上面的两个方法都是在PhoneWindow中实现的。 123456public final View getDecorView() { if (mDecor == null || mForceDecorInstall) { installDecor(); } return mDecor; } 如果mDecor是空就创建一个，最后返回mDecor。123456789101112131415private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { mDecor = generateDecor(-1); ... } else { mDecor.setWindow(this); } if (mContentParent == null) { mContentParent = generateLayout(mDecor); ... } ... } 这个类很长，只看主要的，如果mDecor为null就调用generateDecor方法创建，否则就直接把当前window对象设置为mDecor，mDecor这个成员变量点过去可以看到是DecorView对象。mContentParent这个成员变量点过去可以看到它是一个ViewGroup，如果是null就创建，传入了mDecor。1234567891011121314151617protected DecorView generateDecor(int featureId) { Context context; if (mUseDecorContext) { Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) { context = getContext(); } else { context = new DecorContext(applicationContext, getContext()); if (mTheme != -1) { context.setTheme(mTheme); } } } else { context = getContext(); } return new DecorView(context, featureId, this, getAttributes()); } 下面看一下DecorView123public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { ...} 可以看到它就是一个FrameLayout，然后在看一下 generateLayout(mDecor)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected ViewGroup generateLayout(DecorView decor) { //获取属性数组 TypedArray a = getWindowStyle(); ... //是不是悬浮 mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); ... //设置一堆标志位，通过TypedArray获取各种属性 ... //给窗口充气 int layoutResource; int features = getLocalFeatures(); //根据不同的标志位选择不同的布局文件 //布局文件位置/frameworks/base/core/res/res/layout/ ... //开始更新decor mDecor.startChanging(); //加载 layoutResource 到 decor 中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //ID_ANDROID_CONTENT就是R.id.content ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... //getContainer()返回的是一个Window对象，它是父activity中的window if (getContainer() == null) { final Drawable background; if (mBackgroundResource != 0) { background = getContext().getDrawable(mBackgroundResource); } else { background = mBackgroundDrawable; } mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) { frame = getContext().getDrawable(mFrameResource); } else { frame = null; } mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) { setTitle(mTitle); } if (mTitleColor == 0) { mTitleColor = mTextColor; } setTitleColor(mTitleColor); } //结束更新 mDecor.finishChanging(); return contentParent;} 上面的代码中根据不同的风格加载不同的布局，这些布局中都有一个id为@android:id/content的控件，比如screen_simple.xml。布局源码位置在/frameworks/base/core/res/res/layout/。然后把加载出来的布局放到mDecor中。 OK到这里mWindow.getDecorView()我们就看完了，它就是创建一个DecorView，然后根据不同的风格加载不同的布局文件，把这些布局文件放到DecorView中。下面我们看一下mWindow.setContentView(subDecor)前面我们知道mWindow就是PhoneWindow所以调用了PhoneWindow中的setContentView方法1234567891011121314151617181920212223242526 public void setContentView(View view) { setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));} public void setContentView(View view, ViewGroup.LayoutParams params) { //mContentParent在mWindow.getDecorView()已经创建了 if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } //是否有转场动画 transitions if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); } else { // 把subDecor也就是前面的FitWindowsLinearLayout添加到mContentParent中 mContentParent.addView(view, params); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true;} mWindow.getDecorView()创建了DecorView和mContentParent，上面的代码吧subDecor放入mContentParent中。最后回到AppCompatDelegateImpl中，找到R.id.content这个容器，把我们的view放到这个容器中。这时候我们可以知道整个activity的布局从外到内：AppCompatActivity-&gt;PhoneWindow-&gt;DecorView-&gt;LinearLayout-&gt;FitWindowLinearLayout-&gt;ViewStubCompat-&gt;ConentFramLayout-&gt;我们的view。 最后一张奇丑无比的图来镇楼","link":"/2019/03/22/technology/UI绘制流程-View-是如何被添加到屏幕上的/"},{"title":"事件总线LiveDataBus","text":"使用LiveData实现事件总线 最近在使用谷歌官方的架构组件重构项目，在事件总线的选择方面，以前用的是EventBus，因为现在项目中使用了LiveData，想到了之前看过的美团的一篇文章Android消息总线的演进之路里面讲了使用LiveDataBus，来代替RxBus、EventBus。感觉想法非常，于是项目中开始使用LiveDataBus，使用是非常简单的，不过来需了解实现原理。 开始之前最好先了解一下LiveData可以看这两篇文章：Android Jetpack之LiveData，Android Jetpack之Lifecycles LiveDdataBus的优点 使用简单 代码量非常少 能够感知组件（Activity，Fragment，Service等）的生命周期 不用取消注册也不会内存泄露 使用的是谷歌亲儿子LiveData，官方提供了稳定的依赖包，并且会一直维护 OK下面开始，想要实现一个事件总线的框架，我们需要搞定下面几个东西。 消息：可以是任何类型的消息 消息通道：系统API，LiveData，不同的消息通道使用不同的名字。并且可以通过名字获取该通道 消息总线: 通过一个集合来管理消息通道，比如HashMap 发布者： 系统API, setValue和postValue这俩都是LiveData提供的方法 订阅者： 系统API，Observer类 把上面的几个对应到代码中，一个简易的事件总线框架就出来啦如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class LiveDataBus { //消息总线HashMap 和 消息通道 MutableLiveData private final Map&lt;String, MutableLiveData&lt;Object&gt;&gt; mBus; private LiveDataBus() { mBus = new HashMap&lt;&gt;(); } private static class SingletonHolder { private static final LiveDataBus DATA_BUS = new LiveDataBus(); } public static LiveDataBus get() { return SingletonHolder.DATA_BUS; } public synchronized &lt;T&gt; MutableLiveData&lt;T&gt; with(String target, Class&lt;T&gt; type) { if (!mBus.containsKey(target)) { mBus.put(target, new MutableLiveData&lt;&gt;()); } return (MutableLiveData&lt;T&gt;) mBus.get(target); } public MutableLiveData&lt;Object&gt; with(String target) { return with(target, Object.class); }}public class LiveDataFirstActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_live_data_bus); //传入订阅者和观察者 LiveDataBus.get().with(\"text\",String.class).observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { ToastUtils.showShort(s); } }); } public void sendMessage(View view) { //发布消息 LiveDataBus.get().with(\"text\").setValue(\"哈哈哈\"); } public void Jump(View view) { Intent intent = new Intent(this,LiveDataSecondActivity.class); startActivity(intent); }}public class LiveDataSecondActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_live_data_bus); LiveDataBus.get().with(\"text\",String.class).observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { ToastUtils.showShort(s); } }); } public void sendMessage(View view) { LiveDataBus.get().with(\"text\").setValue(\"我是第二个\"); } public void Jump(View view) { }} 效果如下: 可以看到已经收到了消息，不过发现两个个问题： 上面写的这个这个事件总线框架好像自带黏性效果，当我们从第一个Activity发送完消息之后，跳到第二个Activity，如果第二个Activity也订阅了跟第一个Activity中的消息通道中一样的消息，那它也能收到之前发布的消息 重复接收，当我们从第二个Activity发送一个消息，然后退回到第一个Activity，然后在进入第二个Activity，发现还能收到 怎么解决问题呢，首先需要先找到问题的原因 从LiveData的observe方法开始看1234567891011121314151617public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { assertMainThread(\"observe\"); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper); } 这里面创建了一个LifecycleBoundObserver对象，它是observer的包装对象。123456789101112131415161718192021222324252627282930313233class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver { @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) { super(observer); mOwner = owner; } @Override boolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); } @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) { if (mOwner.getLifecycle().getCurrentState() == DESTROYED) { removeObserver(mObserver); return; } activeStateChanged(shouldBeActive()); } @Override boolean isAttachedTo(LifecycleOwner owner) { return mOwner == owner; } @Override void detachObserver() { mOwner.getLifecycle().removeObserver(this); } } LifecycleBoundObserver继承自ObserverWrapper1234567891011121314151617181920212223242526272829303132333435363738private abstract class ObserverWrapper { final Observer&lt;? super T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;? super T&gt; observer) { mObserver = observer; } abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) { return false; } void detachObserver() { } void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) { onActive(); } if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) { onInactive(); } if (mActive) { dispatchingValue(this); } } } 在这个ObserverWrapper的成员变量中，有一个mLastVersion，并被赋值为常量START_VERSION，START_VERSION的值为-1。ok先记下这个值。 下面在看发布消息的方法123456protected void setValue(T value) { assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null); } 首先调用了mVersion++;这个是当前的版本，也记住这个值。它是在LiveData创建的时候被赋值的如下12345678public LiveData(T value) { mData = value; mVersion = START_VERSION + 1;}public LiveData() { mData = NOT_SET; mVersion = START_VERSION;} 前面我们知道mLastVersion的初始值为START_VERSION，所以mVersion的值刚开始的时候肯定是大于等于mLastVersion的。 然后调用了dispatchingValue方法分发消息1234567891011121314151617181920212223void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { considerNotify(initiator); initiator = null; } else { for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false; } 我们传进来的initiator参数是null，所以这里面会循环消息通道，找到其中的观察者，然后调用considerNotify方法通知观察者123456789101112131415private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData); } 重点来啦，这里有个判断if (observer.mLastVersion &gt;= mVersion)当我们的observer包装对象中的mLastVersion大于或者等于mVersion的时候就返回，返回了也就不会调用下面的observer.mObserver.onChanged((T) mData)方法通知订阅者了。反之则会通知订阅者 然而前面我们知道，当我们新建一个订阅者的包装对象的时候，它的mLastVersion成员变量会被赋值为-1，mVersion初始值会被赋值为0或者-1，当调用setValue方法的时候，mVersion的值还会++，所以if (observer.mLastVersion &gt;= mVersion)是不成立的，因此一直都能收到消息。 现在知道原因啦，下面就是解决问题了 那解决这个问题的思路就是想办法不让它走到considerNotify方法中的observer.mObserver.onChanged((T) mData);。所以这一行前面的代码我们都可以发挥想象空间。比如： 我们可以更改mLastVersion让它跟mVersion相等，这样就可以直接返回不会再走观察者的onChanged方法了。不过想改这个mLastVersion值，因为它所在的类是个私有的抽象类，我们无法直接拿到，所以只能通过反射更改了，有点麻烦。 事件分发的时候会回调观察者的onChanged方法，我们可以自己实现一个Observer的包装类，然后在其onChanged方法之前做拦截。 现在先使用第一种方法解决12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 重写MutableLiveData，实现它的observe方法，在其中反射改变mLastVersion的值 * @param &lt;T&gt; */ private class BusMutableLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt;{ @Override public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { super.observe(owner, observer); //先调用super方法，将observer的包装对象放入map中在反射更改。 try { hook(observer); } catch (Exception e) { e.printStackTrace(); } } private void hook(Observer&lt;? super T&gt; observer) throws Exception { //获取LiveData的class Class&lt;LiveData&gt; liveDataClass = LiveData.class; //反射回去LiveData的成员变量mObservers Field fileObservers = liveDataClass.getDeclaredField(\"mObservers\"); //设置该属性可更改 fileObservers.setAccessible(true); //get方法获取的是当前对象的实例，这里就是mObservers这个Map集合 Object objectObservers = fileObservers.get(this); //获取map对象的类 Class&lt;?&gt; classObservers = objectObservers.getClass(); //获取集合的Map方法 Method methodGet = classObservers.getDeclaredMethod(\"get\", Object.class); //设置get方法可以被访问 methodGet.setAccessible(true); //执行get方法拿出当前观察者对应的对象 Object objectWrapperEntry = methodGet.invoke(objectObservers,observer); //定义一个空对象 Object objectWrapper = null; //判断objectWrapperEntry是否是Map.Entry类型 if(objectWrapperEntry instanceof Map.Entry){ //如果是拿出他的值,其实就是LifecycleBoundObserver objectWrapper = ((Map.Entry) objectWrapperEntry).getValue(); } //如果是空抛个异常 if(objectWrapper == null){ throw new RuntimeException(\"objectWrapper is null\"); } //因为mLastVersion在LifecycleBoundObserver的父类ObserverWrapper中，所以拿到它的父类 Class&lt;?&gt; classObserverWrapper = objectWrapper.getClass().getSuperclass(); //获取到mLastVersion字段 Field fieldLastVersion = classObserverWrapper.getDeclaredField(\"mLastVersion\"); //设置该字段可以更改 fieldLastVersion.setAccessible(true); //获取LiveData中的mVersion值 Field fileVersion = liveDataClass.getDeclaredField(\"mVersion\"); //设置该值可以被访问 fileVersion.setAccessible(true); //获取mVersion的值 Object objVersion = fileVersion.get(this); //给mLastVersion赋值 fieldLastVersion.set(objectWrapper,objVersion); } } 重写MutableLiveData，实现它的observe方法，在其中反射改变mLastVersion的值，然后把Map中的通道改成我们自己的BusMutableLiveData。这样就可以解决前面的问题了用法不变效果如下： 使用第二种方法解决：123456789101112131415161718192021222324252627282930313233343536373839404142private class BusMutableLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt;{ int mCurrentVersion; /** * 是否需要更新数据,当主动调用setValue或者postValue的时候才触发 */ @Override public void setValue(T value) { mCurrentVersion++; super.setValue(value); } @Override public void postValue(T value) { mCurrentVersion++; super.postValue(value); } @Override public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { super.observe(owner, new ObserverWrapper&lt;T&gt;(observer,mCurrentVersion,this)); } } private class ObserverWrapper&lt;T&gt; implements Observer&lt;T&gt;{ private Observer&lt;? super T&gt; mObserver; private int mVersion; private BusMutableLiveData&lt;T&gt; mLiveData; public ObserverWrapper(Observer&lt;? super T&gt; observer,int version,BusMutableLiveData&lt;T&gt; liveData) { mObserver = observer; mVersion = version; mLiveData = liveData; } @Override public void onChanged(T t) { if(mLiveData.mCurrentVersion&gt;mVersion&amp;&amp;mObserver!=null){ mObserver.onChanged(t); } } } 第二种方法，系统的version信息拿不到，我们仿照系统自己弄个mCurrentVersion，在新的观察者来的时候，吧当前mCurrentVersion传给他，setValue或者postValue的时候给通道的mCurrentVersion加一。 然后自定义一个观察者的包装类，ObserverWrapper，在其onChanged方法中判断isChangeData为true的时候才更新数据。用法不变效果跟前面那个一样。 源码位置在这里","link":"/2019/04/27/technology/事件总线LiveDataBus/"},{"title":"直播用到的技术","text":"直播用到的技术 服务器端搭建Nginx Nginx是一个高性能的HTTP和反向代理服务器，用来处理前端（Andorid ios Web）过来的请求，以前在一台服务器上需要部署多个服务，需要通过端口号执行访问的具体服务，部署完Nginx之后就不需要这样了，可以用Nginx来导流和分发。 下载地址：http://nginx.org/en/download.html 在Linux上下载当前最新版本并解压12wget http://nginx.org/download/nginx-1.17.0.tar.gztar -zxvf nginx-1.17.0.tar.gz 使用nginx-rtmp-module作为直播模块 https://github.com/arut/nginx-rtmp-module 下载最新版本并解压12345wget https://codeload.github.com/arut/nginx-rtmp-module/tar.gz/v1.2.1tar -zxvf v1.2.1//或者wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gztar -zxvf v1.2.1.tar.gz 进入到nginx的解压目录，给它添加直播模块 12#--prefix代表编译到哪个目录 --add-module 指向rtmp模块目录./configure --prefix=./bin --add-module=../nginx-rtmp-module-1.2.1 开始安装1make &amp;&amp; make install 有时候可能会出现zlib，pcre，openssl这几个库找不到可以根据下面的链接中的安装 https://blog.csdn.net/z920954494/article/details/52132125 安装成功后会生成一个bin目录，进入bin/conf修改nginx.conf文件配置rtmp和http协议。在nginx-rtmp-module-1.2.1/test/nginx.conf中有示例12cd bin/confvim nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344worker_processes 1;error_log logs/error.log debug;events {#最大连接数 worker_connections 1024;}rtmp { server { listen 1935; application myapp { live on; #大于5秒不响应丢弃 drop_idle_publisher 5s; } }}http { server { listen 8081; location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { #这里改成自己的路径 root /root/nginx-rtmp-module-1.2.1/; } location /control { rtmp_control all; } location /rtmp-publisher { #这里改成自己的路径 root /root/nginx-rtmp-module-1.2.1/test; } location / { #这里改成自己的路径 root /root/nginx-rtmp-module-1.2.1/test/www; } }} 查看端口是否被占用：netstat -tunlp|grep 8081 回到Nginx解压根目录,打开nginx1bin/sbin//nginx 浏览器打开后台网址 58.320.63.116:8081/stat如果能够打开说明搭建成功了。 视频推流123456graph LR摄像头--&gt;视频通道麦克风--&gt;音频通道视频通道--&gt;打包音频通道--&gt;打包打包--&gt;Native推流 摄像头搜集到视频源数据Android中是NV21格式，它是YUV中的一种这个源数据非常大，需要对其编码压缩，可以使用h264协议进行压缩。 H264是连续帧，包括I帧 B帧 P帧 I帧：也是关键帧，它保留了一幅图的完整信息 P帧：根据I帧形成的，表示与I帧之间的差别 B帧：I帧和P帧之间的，由前面的I帧或者后面的P帧预测而来 封装成pcket，使用rtmp协议传输，rtmpDump工具 rtmpDump 下载地址：http://rtmpdump.mplayerhq.hu/download/ 下载解压，把libtrmp复制到我们工程的cpp目录下面 编译失败123F:\\sdk\\ndk-bundle\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin\\clang.exe --target=x86_64-none-linux-android21 --gcc-toolchain=F:/sdk/ndk-bundle/toolchains/llvm/prebuilt/windows-x86_64 --sysroot=F:/sdk/ndk-bundle/toolchains/llvm/prebuilt/windows-x86_64/sysroot -g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -fno-addrsig -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fno-limit-debug-info -fPIC -MD -MT librtmp/CMakeFiles/rtmp.dir/hashswf.c.o -MF librtmp\\CMakeFiles\\rtmp.dir\\hashswf.c.o.d -o librtmp/CMakeFiles/rtmp.dir/hashswf.c.o -c D:/android/A1/MyPusher/app/src/main/cpp/librtmp/hashswf.cD:/android/A1/MyPusher/app/src/main/cpp/librtmp/hashswf.c:56:10: fatal error: &apos;openssl/ssl.h&apos; file not found#include &lt;openssl/ssl.h&gt; 说是在hashswf.c的56行找不到&lt;openssl/ssl.h&gt;，这个主要是用来加密的，加密意味着效率慢，所以通常的直播是不需要加密的，可以忽略掉这一部分。 进入hashswf.c中可以看到：&lt;openssl/ssl.h&gt;的引用是在#ifdef CRYPTO之后，只有定义了CRYPTO这个参数才能走下面引用openssl的方法，所以可以想办法绕过这里，可以直接注释掉CRYPTO也可以通过下面的方法 在CMakeLists.txt文件中传递一个NO_CRYPTO参数1set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -DNO_CRYPTO&quot;) -D后面就是传递的参数，传递之后再编译就不会出错了。 使用x264工具来负责h264的编解码 x264地址 ：https://www.videolan.org/developers/x264.html x264的源码很多，就不能跟前面rtmpdump一样直接导入AndoroidStudio中使用了，因为源码太多会编译非常慢慢到你怀疑人生，所以需要下载到Linux服务器在服务器中编译完在导入到AndoridStudio中。 在服务器中直接通过git下载，clone之前要安装git，或者直接官网下载zip文件在上传到服务器中1git clone https://code.videolan.org/videolan/x264.git 为什么视频编码采用YUV而不是RGB RGB原理：定义RGB从颜色发光的原理来设定，任何一种颜色都可以通过红、绿、蓝三种颜色混合而成，亮度等于参与混合的颜色之和，越混合亮度越高，即混合加法，RGB24指RGB三个各占8位 YUV原理：YUV只要用于优化色彩视频信号的传输，与RGB视频信号传输相比，它的最大优点是占用极少的频宽。RGB要求三个独立的视频信号同时传输。Y表示亮度，U和V表示色度 NV21 YUVI420 为什么要对视频进行编码？ 视频是由一帧帧的图像组成，一般的视频为了不让用户感到卡顿，一秒钟至少需要16帧的画面（一般是30帧），假如该视频是一个1280720分辨率的视频，那么不经过编码的一秒钟大小结果是：1280720*60≈843.75M，非常大不适合保存和传输。 H264的编码规则 在相邻的几幅图像中，一般差别的像素只有10%以内的点，亮度差值变化不超过2%，而色度差值的变化只有1%以内，所以对于一段变化不大的图像，我们可以先编码出一个完整的图像的帧A 随后，B帧就不用编码全部的图像，只写入和A帧的差别，这样B帧的大小就只有完成帧的1/10或者更小。B帧之后的C帧如果变化不大，我们可以继续以参考B帧的方法编码C帧如此循环 这样的一段图像成为一个序列。序列就是有相同特点的一段数据。当某个图像的差别跟前一个很大的时候无法参考前面的来生成，就结束这个序列开始下一段序列。 编码后的I帧B帧P帧也不能直接发送，还需要通过帧内压缩来进一步减小其大小。 NALU单元设计，H264原始码流（裸流）是由一个接一个的NALU组成的。 NALU包括NALU头和RBSP（切片），。NALU头就相当于一辆汽车的头，切片就相当于它拉的货物，他们两个组成一个完整的一个火车运送到目的地，H264的原始流就是一辆一辆的这样的货车运送。 什么是切片：H264默认使用16*16大小的区域作为一个宏块，若干个宏块就可以组成一个切片。 SPS和PPS SPS和PPS包含了初始化H264解码器所需要的信息参数，包括编码所用的profile,level图像宽和高，deblock滤波器等。 SPS：序列参数集 PPS：图像参数集 在H264中，都是以 “0x00 0x00 0x01” 或者 “0x00 0x00 0x00 0x01” 为开始编码的，找到开始码之后使用开始码之后的第一个字节的底5位判断是否为7sps或者8pps。 RTMPDump的地址：http://rtmpdump.mplayerhq.hu/ 使用RTMPDump的步骤： RTMP_Alloc 申请内存 RTMP_Init 初始化 RTMP_SetupURL 设置地址 RTMP_EnableWrite 开启输出模式 RTMP_Connect 连接服务器 RTMP_ConnectStream 连接流 RTMP_SendPacket 发从音频和视频数据包 RTMP_Close 关闭连接 RTMP_Free 释放 音频推流一般使用aac编码音频 AAC： 高级音频编码(Advanced Audio Coding)，出现于1997年，基于MPEG-2的音频编码技术,目的是取代MP3格式。2000年，MPEG-4标准出现后，AAC重新集成了其特性，为了区别于传统的MPEG-2 AAC又称为MPEG-4 AAC。相对于mp3，AAC格式的音质更佳，文件更小。AAC的音频文件格式有 ADIF ＆ ADTS aac一种是在连续的音频数据的开始处存有解码信息，一种是在每一小段音频数据头部存放7个或者9个字节的头信息用于播放器解码。 RTMP推流需要的是aac的裸数据。所以如果编码出adts格式的数据，需要去掉7个或者9个字节的adts头信息。类似于推送视频，第一个包总是包含sps和pps的音频序列包，推送音频同样第一个包是包含了接下来数据的格式的音频序列包 https://www.audiocoding.com/ 下载地址： https://sourceforge.net/projects/faac/files/faac-src/faac-1.29/faac-1.29.9.2.tar.gz/ 编译faac 1234567891011121314151617181920#!/bin/bashPREFIX=`pwd`/android/armeabi-v7aNDK_ROOT=/root/android-ndk-r17cTOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabiFLAGS=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=17 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -std=c++11 -O0 -fPIC\"export CC=\"$CROSS_COMPILE-gcc --sysroot=$NDK_ROOT/platforms/android-17/arch-arm\"export CFLAGS=\"$FLAGS\"./configure \\--prefix=$PREFIX \\--host=arm-linux \\--with-pic \\--enable-shared=nomake cleanmake install 音视频播放和同步使用FFmpeg来播放视频 使用OpenSL ES 播放音频 FFmpeg: AvformatContext:获取视频流和音频流 字幕流，这是经过编码后的压缩数据 AVcodecContext：解压的上下文，可以获得宽度高度编码信息等 AVcondec：解码器 解码成yuv数据 SwsContext ：转换上下文 视频缩放等操作123456789101112FAILED: D:/android/A1/MyPlayer/app/build/intermediates/cmake/debug/obj/armeabi-v7a/libmyplayer.so cmd.exe /C &quot;cd . &amp;&amp; F:\\sdk\\ndk-bundle\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin\\clang++.exe --target=armv7-none-linux-androideabi19 --gcc-toolchain=F:/sdk/ndk-bundle/toolchains/llvm/prebuilt/windows-x86_64 --sysroot=F:/sdk/ndk-bundle/toolchains/llvm/prebuilt/windows-x86_64/sysroot -fPIC -g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -mfpu=vfpv3-d16 -fno-addrsig -march=armv7-a -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -stdlib=libc++ -LD:/android/A1/MyPlayer/app/src/main/cpp/../../../libs/armeabi-v7a -O0 -fno-limit-debug-info -Wl,--exclude-libs,libgcc.a -Wl,--exclude-libs,libatomic.a -static-libstdc++ -Wl,--build-id -Wl,--warn-shared-textrel -Wl,--fatal-warnings -Wl,--exclude-libs,libunwind.a -Wl,--no-undefined -Qunused-arguments -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -shared -Wl,-soname,libmyplayer.so -o D:\\android\\A1\\MyPlayer\\app\\build\\intermediates\\cmake\\debug\\obj\\armeabi-v7a\\libmyplayer.so CMakeFiles/myplayer.dir/native-lib.cpp.o -lavcodec -lavfilter -lavformat -lavutil -lswresample -lswscale -landroid -lz -lOpenSLES -llog -latomic -lm &amp;&amp; cd .&quot;libavcodec/v4l2_buffers.c:439: error: undefined reference to &apos;mmap64&apos;libavformat/utils.c:5610: error: undefined reference to &apos;av_bitstream_filter_filter&apos;libavformat/codec2.c:74: error: undefined reference to &apos;avpriv_codec2_mode_bit_rate&apos;libavformat/codec2.c:75: error: undefined reference to &apos;avpriv_codec2_mode_frame_size&apos;libavformat/codec2.c:76: error: undefined reference to &apos;avpriv_codec2_mode_block_align&apos;libavformat/hls.c:840: error: undefined reference to &apos;atof&apos;libavformat/spdifdec.c:63: error: undefined reference to &apos;av_adts_header_parse&apos;libavformat/hlsproto.c:141: error: undefined reference to &apos;atof&apos;clang++.exe: error: linker command failed with exit code 1 (use -v to see invocation)ninja: build stopped: subcommand failed. 原因依赖顺序有问题：后面的库会用到前面库的方法 原来的1avcodec avfilter avformat avutil swresample swscale 改后1avfilter avformat avcodec avutil swresample swscale https://android.googlesource.com/platform/ndk/+/master/docs/user/common_problems.md https://github.com/android-ndk/ndk/issues/536 https://www.jianshu.com/p/e0e042a10000 avcodec：编解码 avformat：封装格式处理 avfilter：滤镜特效处理 avutil：工具库 swresample：音频采样数据格式转换 swscale：视频像素数据格式转换 armv8a编译脚本12345678910111213141516171819202122232425262728293031#!/bin/bashNDK_ROOT=/root/ff/NDK/android-ndk-r17cPREFIX=./android/arm64-v8a#TOOLCHAIN 变量指向ndk中的交叉编译gcc所在的目录TOOLCHAIN=$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64FLAGS=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC\" # --disable-cli : 关闭命令行# 其他和ffmpeg一样./configure \\--prefix=$PREFIX \\--enable-small \\--disable-programs \\--disable-avdevice \\--disable-encoders \\--disable-muxers \\--disable-filters \\--enable-cross-compile \\--cross-prefix=$TOOLCHAIN/bin/aarch64-linux-android- \\--enable-shared \\--enable-static \\--sysroot=$NDK_ROOT/platforms/android-21/arch-arm64 \\--extra-cflags=\"$FLAGS $INCLUDES\" \\--extra-cflags=\"-isysroot $NDK_ROOT/sysroot\" \\--arch=aarch64 \\--target-os=androidmake cleanmake install 多个版本一起编译123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#!/bin/shMY_LIBS_NAME=ffmpeg-4.0MY_DIR=ffmpeg-4.0# cd ./${MY_DIR}#编译的过程中产生的中间件的存放目录，为了区分编译目录，源码目录，install目录MY_BUILD_DIR=binaryNDK_PATH=/home/as/Android/android-ndk-r15cBUILD_PLATFORM=linux-x86_64TOOLCHAIN_VERSION=4.9ANDROID_VERSION=24ANDROID_ARMV5_CFLAGS=\"-march=armv5te\"ANDROID_ARMV7_CFLAGS=\"-march=armv7-a -mfloat-abi=softfp -mfpu=neon\" #-mfloat-abi=hard -mfpu=vfpv3-d16 #-mfloat-abi=hard -mfpu=vfpANDROID_ARMV8_CFLAGS=\"-march=armv8-a\"ANDROID_X86_CFLAGS=\"-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32\"ANDROID_X86_64_CFLAGS=\"-march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel\"# params($1:arch,$2:arch_abi,$3:host,$4:cross_prefix,$5:cflags)build_bin() { echo \"-------------------start build $2-------------------------\" ARCH=$1 # arm arm64 x86 x86_64 ANDROID_ARCH_ABI=$2 # armeabi armeabi-v7a x86 mips PREFIX=$(pwd)/dist/${MY_LIBS_NAME}/${ANDROID_ARCH_ABI}/ HOST=$3 SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-${ARCH} CFALGS=$5 TOOLCHAIN=${NDK_PATH}/toolchains/${HOST}-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM} CROSS_PREFIX=${TOOLCHAIN}/bin/$4- # build 中间件 BUILD_DIR=./${MY_BUILD_DIR}/${ANDROID_ARCH_ABI} echo \"pwd==$(pwd)\" echo \"ARCH==${ARCH}\" echo \"PREFIX==${PREFIX}\" echo \"HOST==${HOST}\" echo \"SYSROOT=${SYSROOT}\" echo \"CFALGS=$5\" echo \"CFALGS=${CFALGS}\" echo \"TOOLCHAIN==${TOOLCHAIN}\" echo \"CROSS_PREFIX=${CROSS_PREFIX}\" #echo \"-------------------------按任意键继续---------------------\" #read -n 1 #echo \"-------------------------继续执行-------------------------\" mkdir -p ${BUILD_DIR} #创建当前arch_abi的编译目录,比如:binary/armeabi-v7a cd ${BUILD_DIR} #此处 进了当前arch_abi的2级编译目录 sh ../../${MY_DIR}/configure \\ --prefix=${PREFIX} \\ --target-os=linux \\ --arch=${ARCH} \\ --sysroot=$SYSROOT \\ --enable-cross-compile \\ --cross-prefix=${CROSS_PREFIX} \\ --extra-cflags=\"$CFALGS -Os -fPIC -DANDROID -Wfatal-errors -Wno-deprecated\" \\ --extra-cxxflags=\"-D__thumb__ -fexceptions -frtti\" \\ --extra-ldflags=\"-L${SYSROOT}/usr/lib\" \\ --enable-shared \\ --enable-asm \\ --enable-neon \\ --disable-encoders \\ --enable-encoder=aac \\ --enable-encoder=mjpeg \\ --enable-encoder=png \\ --disable-decoders \\ --enable-decoder=aac \\ --enable-decoder=aac_latm \\ --enable-decoder=h264 \\ --enable-decoder=mpeg4 \\ --enable-decoder=mjpeg \\ --enable-decoder=png \\ --disable-demuxers \\ --enable-demuxer=image2 \\ --enable-demuxer=h264 \\ --enable-demuxer=aac \\ --disable-parsers \\ --enable-parser=aac \\ --enable-parser=ac3 \\ --enable-parser=h264 \\ --enable-gpl \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-symver \\ --disable-debug \\ --enable-small make clean make make install #从当前arch_abi编译目录跳出，对应上面的cd ${BUILD_DIR},以便function多次执行 cd ../../ echo \"-------------------$2 build end-------------------------\"}# build armeabibuild_bin arm armeabi arm-linux-androideabi arm-linux-androideabi \"$ANDROID_ARMV5_CFLAGS\"#build armeabi-v7abuild_bin arm armeabi-v7a arm-linux-androideabi arm-linux-androideabi \"$ANDROID_ARMV7_CFLAGS\"#build arm64-v8abuild_bin arm64 arm64-v8a aarch64-linux-android aarch64-linux-android \"$ANDROID_ARMV8_CFLAGS\"#build x86build_bin x86 x86 x86 i686-linux-android \"$ANDROID_X86_CFLAGS\"#build x86_64build_bin x86_64 x86_64 x86_64 x86_64-linux-android \"$ANDROID_X86_64_CFLAGS\" OpenSL ES OpenSL ES是一套无授权费跨平台，针对嵌入式系统精心优化的硬件音频加速API，为移动多媒体设备提供标准化、高性能、低响应时间的音频功能实现方法，并实现软硬件音频性能的直接跨平台部署，降低执行难度。促进高级音频时长的发展。 Android播放音频的几种方式: 12345678910111213141516171819202122 //1.使用MediaPlayer播放音频 //直接创建，不需要设置setDataSourceMediaPlayer mMediaPlayer；mMediaPlayer=MediaPlayer.create(this, R.raw.audio); mMediaPlayer.start();//2 使用AudioTrack播放音频 AudioTrack audio = new AudioTrack( AudioManager.STREAM_MUSIC, // 指定流的类型 32000, // 设置音频数据的採样率 32k，假设是44.1k就是44100 AudioFormat.CHANNEL_OUT_STEREO, // 设置输出声道为双声道立体声，而CHANNEL_OUT_MONO类型是单声道 AudioFormat.ENCODING_PCM_16BIT, // 设置音频数据块是8位还是16位。这里设置为16位。//3 使用OpenSL ES播放/混音器SLObjectItf outputMixObject = NULL;//用SLObjectItf创建混音器接口对象SLEnvironmentalReverbItf outputMixEnvironmentalReverb = NULL;////创建具体的混音器对象实例 result = (*engineEngine)-&gt;CreateOutputMix(engineEngine, &amp;outputMixObject, 1, mids, mreq);//利用引擎接口对象创建混音器接口对象result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);//实现（Realize）混音器接口对象result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, &amp;outputMixEnvironmentalReverb);//利用混音器接口对象初始化具体混音器实例 使用OpenSl ES 播放的优势 C 语言接口，需要在 NDK 下开发，能更好地集成在 native 应用中 运行于 native 层，播放 速度极快，延时低 对于音视频同步中以音频为准的最为适合不过 减少java层频繁的反射调用，如果通过AudioTrack播放需要将解码后得pcm数据反射java 增加开销 Android native操作Java的官方例子https://github.com/googlesamples/android-ndk OpenSl ES的执行流程 创建音频引擎 设置混音器 创建播放器 设置缓冲队列和回调函数 设置播放状态 启动回调函数 音视频同步以音频为准，以视频为准，自定义时间为准。一般音频为准，因为人的耳朵对音频比较敏感。 音频丢一帧耳朵能听出卡顿，视频丢一帧人眼一般发现不了。 帧率 解码速度 渲染速度都会影响同步 ffmpeg中提供了时间戳 DTS和PTS DTS Decoding Time Stamp 解码时间戳，告诉解码器packet的解码顺序 PTS presentation Time Stamp 显示时间戳，从packet中解码出来的数据的显示顺序 在音频中两者是相同的，但是在视频中由于B帧（双向预测）的存在，会造成解码顺序与显示顺序不相同。视频中DTS和PTS不一定相同。 视频中B帧是根据I帧和P帧计算出来的，所以解码顺序有可能不一样。比如I帧和P帧先解码然后在解码B帧。","link":"/2019/06/22/technology/直播用到的技术/"},{"title":"自定义ViewGroup练习之仿写RecycleView","text":"哈哈，标题很唬人，其实就是根据RecyclerView的核心思想来写一个简单的列表控件。 RecycleView的核心组件 回收池：可以回收任意的item控件，并可以根据需要返回特定的item控件。 适配器：Adapter接口，帮助RecycleView展示列表数据，使用适配器模式，将界面展示跟交互分离 RecycleView：主要做用户交互，事件触摸反馈，边界值的判断，协调回收池和适配器对象之间的工作。 下面就开始把上面的三个东西写出来，前两个都很简单，最后的RecyclerView稍微复杂一点 回收池 当然这里只是简单的实现一个回收池，具体RecyclerView的回收原理可以看之前的文章RecycleView的缓存原理 定义一个类叫做Recycler。我们想一下，一个回收池可以缓存一些View,第一次加载的时候，我们需要创建一些item把这个屏幕填满，当我们向上滑动的时候，最上面的item移除屏幕外面，我们需要把这个移除的item放到缓存池中，屏幕最下面如果有item需要填充的话，先去缓存池中寻找是否有缓存的item，如果有直接拿过来填充数据，如果没有就重新建一个新的item填充。 这个地方涉及到快速的添加和删除操作，所以这里使用Stack（栈）这个数据结构来缓存，它具有后进先出的特性。 代码如下 123456789101112131415161718192021222324252627282930public class Recycler { private Stack&lt;View&gt;[] mViews; /** * * @param typeNum 有几种类型 */ public Recycler(int typeNum){ mViews = new Stack[typeNum]; //RecyclerView中可能有不同的布局类型，不同的type分开缓存 for (int i = 0; i &lt; typeNum; i++) { mViews[i] = new Stack&lt;&gt;(); } } public void put(View view,int type){ mViews[type].push(view); } public View get(int type){ try { return mViews[type].pop(); }catch (Exception e){ return null; } }} 这里为什么使用一个Stack的数组呢，因为我们平时使用RecyclerView的时候，会有多种布局类型的情况，那么我们复用的时候肯定只能复用跟自己类型一样的item，所以使用一个Stack的数组，不同的类型缓存在不同的Stack中，数组的大小就是我们布局类型的种类数。然后添加get 和 put 方法。 适配器 Adapter很简单，定义一个接口，供外部使用，接口里面有什么方法呢，直接去RecyclerView中看看然后把名字抄过来哈哈。因为是简单的实现嘛，就不涉及到ViewHolder相关的东西啦。12345678interface Adapter{ View onCreateViewHodler(int position, View convertView, ViewGroup parent); View onBinderViewHodler(int position, View convertView, ViewGroup parent); int getItemViewType(int row); int getViewTypeCount(); int getCount(); int getHeight(int index); } 使用的时候，也很简单，在我们自己的MyRecyclerView中定义一个setAdapter方法直接用这个set方法就好啦。然后在重写的各个方法中创建我们的item，或者给item绑定数据123456789101112131415161718192021222324252627282930313233343536MyRecyclerView recyclerView = findViewById(R.id.recycleview); recyclerView.setAdapter(new MyRecyclerView.Adapter() { @Override public View onCreateViewHodler(int position, View convertView, ViewGroup parent) { convertView= getLayoutInflater().inflate( R.layout.list_item,parent,false); TextView textView= (TextView) convertView.findViewById(R.id.tvname); textView.setText(\"name \"+position); return convertView; } @Override public View onBinderViewHodler(int position, View convertView, ViewGroup parent) { TextView textView= (TextView) convertView.findViewById(R.id.tvname); textView.setText(\"name \"+position); return convertView; } @Override public int getItemViewType(int row) { return 0; } @Override public int getViewTypeCount() { return 1; } @Override public int getCount() { return 40; } @Override public int getHeight(int index) { return 150; } }); MyRecyclerView 重头戏MyRecyclerView来啦1public class MyRecyclerView extends ViewGroup {......} 它继承自ViewGroup,主要包括两个部分，布局部分和滑动部分。我们先写布局的部分，自定义ViewGroup主要包括测量和布局两个重要的部分，分别是重写onMeasure和onLayout方法12345678910111213141516protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int widthSize = MeasureSpec.getSize(widthMeasureSpec); final int heightSize = MeasureSpec.getSize(heightMeasureSpec); if(mAdapter!=null){ rowCount = mAdapter.getCount(); heights = new int[rowCount]; for (int i = 0; i &lt; rowCount; i++) { heights[i] = mAdapter.getHeight(i); } } int totalH = sumArray(heights, 0, heights.length); setMeasuredDimension(widthSize,Math.min(heightSize,totalH)); super.onMeasure(widthMeasureSpec, heightMeasureSpec); } onMeasure方法很简单，首先从Adapter中拿到总共有多少条数据，和每一条item的高度，然后把这个高度值存在一个数组中。 因为我们的目的是做一个列表，所以宽度部分我们就忽略不关心，直接使用其实际测量的大小就好了。我们主要看高度部分。 对于高度部分，我们需要根据item的高度之和来动态设置，如果我们列表item的高度的和大于了测量的高度，就使用测量的高度，反之则使用item高度之和作为其高度。 也就是说item的高之和如果小于屏幕高度，那么我们MyRecyclerView的高度就应该是这个和，反之就有item在屏幕之外了，所以我们的MyRecyclerView高度为屏幕高度就好啦。 求item总高度的计算公式我们封装成一个方法,后面也会用到12345678private int sumArray(int array[], int firstIndex, int count) { int sum = 0; count += firstIndex; for (int i = firstIndex; i &lt; count; i++) { sum += array[i]; } return sum; } 第一个参数就是数组，第二个参数和第三个参数可以表示一个区间，我们求这个区间内的item的总高度，比如数组的第10个到第30之间的总高度。onMeasure中传入0到 heights.length就是总item的高度了。 onMeasure完成之后就是onLayout方法啦12345678910111213141516171819protected void onLayout(boolean changed, int l, int t, int r, int b) { if(needRelayout&amp;&amp;changed){ needRelayout = false; mCurrentViewList.clear(); removeAllViews(); if(mAdapter!=null){ width = r-l; height = b-t; int top =0; for (int i = 0; i &lt; rowCount&amp;&amp;top&lt;height; i++) { int bottom = heights[i]+top; View view = createView(i,width,heights[i]); view.layout(0,top,width,bottom); mCurrentViewList.add(view); top = bottom; } } } } 因为布局的方法可能会被触发多次，所以使用一个标志位needRelayout来保证只有在布局改变的时候才重新布局，避免不必要的性能损失。 定义一个集合mCurrentViewList来保存当前屏幕上的item，我们拿到一个item后放入这个集合中，当item的的总高度，或者最后一个item的顶部的高度大于屏幕总高度的时候，就不往集合里面放了。这也保证在布局类型一样的时候，我们只会创建这么多的item，以后就可以复用了。只有布局类型在多一种的时候才会考虑重新创建新的item 得到一个子View之后，找到这个子View的左 上 右 下 的位置，调用子View的layout方法来布局这个子view。 怎么得到一个item呢，定义一个createView方法123456789101112131415161718private View createView(int row, int width, int height) { int itemType= mAdapter.getItemViewType(row); View reclyView = mRecycler.get(itemType); View view = null; if(reclyView==null){ view = mAdapter.onCreateViewHodler(row,reclyView,this); if (view == null) { throw new RuntimeException(\"必须调用onCreateViewHolder\"); } }else { view = mAdapter.onBinderViewHodler(row,reclyView,this); } view.setTag(1234512045, itemType); view.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY) ,MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY)); addView(view,0 ); return view; } 首先通过adapter拿到布局类型，然后根据布局类型去缓存池中寻找，如果找到了，就调用onBinderViewHodler方法来绑定数据，如果没有找到，调用onCreateViewHodler方法来创建一个新的item。 然后给这个新建的View设置一个tag,值就是它的布局类型，因为我们开始建立回收池的时候是建立的一个Stack数组，数组下标就是布局类型，所以这里设置tag方便我们回收的时候拿到布局类型 最后就是测量一下新建的子View，并通过addView方法放入到布局中。 通过上面的步骤，运行之后就可以看到一个列表就铺满整个屏幕了。不过这个列表现在是不能滑动的，现在我们来给它加上滑动的功能。 事件的处理我们重写两个方法，onInterceptTouchEvent来拦截事件，onTouchEvent方法来处理事件1234567891011121314151617public boolean onInterceptTouchEvent(MotionEvent ev) { boolean intercepted = false; switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: //记录下手指按下的位置 currentY = ev.getRawY(); break; case MotionEvent.ACTION_MOVE: //当手指的位置大于最小滑动距离的时候拦截事件 float moveY = currentY - ev.getRawY(); if(Math.abs(moveY)&gt;touchSlop){ intercepted = true; } default: } return intercepted;} 当按下（ACTION_DOWN）事件的时候，记录下当前手指点击的位置，当移动（ACTION_MOVE）事件的时候，判断我们的手指移动的距离是不是大于系统规定的最小距离，如果是就返回true拦截事件 系统规定的最小距离可能每个手机都不一样，还好系统提供了响应的方法来让我们获取123//获取系统最小滑动距离ViewConfiguration configuration = ViewConfiguration.get(context);touchSlop = configuration.getScaledTouchSlop(); 注意：如果我们监听了onInterceptTouchEvent中的ACTION_MOVE事件，需要在布局文件中添加clickable为true，否则不会调用ACTION_MOVE方法。具体原因可以去查看系统事件拦截机制的源码。或者看这篇文章重写了onInterceptTouchEvent(ev)方法，但是为什么Action_Move分支没执行12345&lt;com.chs.androiddailytext.recyclerview.MyRecyclerView android:id=\"@+id/recycleview\" android:clickable=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; 下面来看onTouchEvent，这个方法中我们只需要监听ACTION_MOVE事件就好了。123456789101112public boolean onTouchEvent(MotionEvent event) { if(event.getAction() == MotionEvent.ACTION_MOVE){ //滑动距离 int diff = (int) (currentY - event.getRawY()); //上滑是正 下滑是负数 //因为调用系统的scrollBy方法，只是滑动当前的MyRecyclerView容器 //我们需要在滑动的时候，动态的删除和加入子view，所以重写系统的scrollBy方法 scrollBy(0,diff); } return super.onTouchEvent(event); } 求出我们手指的滑动距离，上滑是正下滑是负，然后调用scrollBy方法，传入移动的距离来移动View。不过scrollBy是ViewGroup中的方法，调用它只能滑动我们的MyRecyclerView，并不能滑动其内部的item子View，所以只能重写这个方自己来控制字item的移动了。12345678910111213141516171819202122232425262728293031323334353637383940414243 public void scrollBy(int x, int y) { scrollY+=y; scrollY = scrollBounds(scrollY); //&lt;1&gt;上滑 if(scrollY&gt;0){ //上滑移除最上面的一条 while (scrollY&gt;heights[firstRow]){ removeView(mCurrentViewList.remove(0)); //scrollY的值保持在0到一条item的高度之间 scrollY -= heights[firstRow]; firstRow++; } //&lt;2&gt;上滑加载最下面的一条 // 当剩下的数据的总高度小于屏幕的高度的时候 while (getFillHeight() &lt; height){ int addLast = firstRow + mCurrentViewList.size(); View view = createView(addLast,width,heights[addLast]); //上滑是往mCurrentViewList中添加数据 mCurrentViewList.add(mCurrentViewList.size(),view); } }else if(scrollY&lt;0){ //&lt;3&gt;下滑最上面加载 //这里判断scrollY&lt;0即可，滑到顶置零 while (scrollY&lt;0){ //第一行应该变成firstRow - 1 int firstAddRow = firstRow - 1; View view = createView(firstAddRow, width, heights[firstAddRow]); //找到view添加到第一行 mCurrentViewList.add(0,view); firstRow --; scrollY += heights[firstRow+1]; } //&lt;4&gt;下滑最下面移除 while (sumArray(heights, firstRow, mCurrentViewList.size())-scrollY&gt;height){ removeView(mCurrentViewList.remove(mCurrentViewList.size() - 1)); }// while (sumArray(heights, firstRow, mCurrentViewList.size()) - scrollY - heights[firstRow + mCurrentViewList.size() - 1] &gt;= height) {// removeView(mCurrentViewList.remove(mCurrentViewList.size() - 1));// } } //重新布局 repositionViews(); } 这里我们通过判断scrollY的正负值来判断向上滑动还是向下滑动，当scrollY大于0的时候说明上滑，反之则是下滑。 主要分四步： 上滑的时候，最上面的子View移除屏幕 上滑的时候，最下面的子View，如果需要，填充到屏幕 下滑的时候，移出去的子View需要填充进屏幕 下滑的时候，最下面的子View，需要移除屏幕。 使用firstRow这个标志位来判断当前屏幕的第一行，在我们总的数据中占第几个。从0开始，每移出去一个item，它就加一 ，移进来一个item它就减一，还记得最开始的sumArray方法吗，它可以求一个区间内的item的总高度。这里如果我们传入当前的firstRow，和数据的总个数，就可以求出从当前第一行到数据总和之间的item的总高度。这个高度很有用，它关系着我们最下面对元素是否要填充屏幕。 我们之前定义了一个mCurrentViewList来保存当前屏幕上的现实的View,移入移除的原理就是我们添加进这个集合和从这个集合中删除一个View的过程。移动完成之后，调用repositionViews方法在重新把mCurrentViewList中的子View布局一边即可，如下：123456789101112private void repositionViews() { int left, top, right, bottom, i; top = - scrollY; i = firstRow; for (View view : mCurrentViewList) { if(i&lt;heights.length){ bottom = top + heights[i++]; view.layout(0, top, width, bottom); top = bottom; } } } scrollBy方法中最开始给 scrollY 赋值的时候，我们调用了一个scrollBounds(scrollY)，主要是用来判断边界值，防止数组越界的崩溃发生 下滑极限值，通过sumArray方法，我们可以求出从数据的第0个元素到当前第一行firstRow之间item的总高度。当这个高度为0的时候，说明我们已经滑到了真正的第一行，这时候scrollY也应该被赋值为0 上滑极限值，通过sumArray方法，我们可以算出当前的第一行firstRow到总数据最后一个之间的item的总高度，如果小于当前屏幕的高度了，那就不会有新的item可以填充进来了，这时候scrollY的值就需要定格在当前的高度不能再增加了。 判断极限值的代码如下：12345678910private int scrollBounds(int scrollY) { //上滑极限值 if (scrollY &gt; 0) { scrollY = Math.min(scrollY,sumArray(heights, firstRow, heights.length-firstRow)-height); }else { //下滑极限值 scrollY = Math.max(scrollY, -sumArray(heights, 0, firstRow)); } return scrollY; } OK到这里这个自定义ViewGroup的练习就结束啦，最终效果如下 源码地址","link":"/2019/04/14/technology/自定义ViewGroup练习之仿写RecycleView/"},{"title":"自定义ViewGroup练习之流式布局","text":"自定义ViewGroup，写自己的View继承自ViewGroup，然后重写它的onMeasure和onLayout方法即可。 onMeasure 测量阶段主要分3步 循环调用子view的measure方法，测量子view的宽高并保存 通过子view的宽高，来确定自己的宽高 setMeasuredDimension()方法来保存自己的宽高 计算子view的尺寸，需要通过父view的测量模式和大小和子view的LayoutParams 来确定。 View的三种测量模式 EXACTLY：精准测量模式，比如我们在xml中使用match_parent和写死dp值，如果父view是这种模式，那么子veiw在测量的时候，肯定不能超过这个固定的值，返回MeasureSpec中的size。 AT_MOST：最大测量模式，比如我们在xml中是用wrap_content，如果父view是这种模式，理论上讲父view的大小是可以无限大的，但是我们也不知道这个值是多少，就暂时把父view当前的size返回，也是MeasureSpec中的size UNSPECIFIED：无限制测量模式，没有任何限制，一般用不到。 onLayout()布局阶段主要分两步 根据onMeasure中的测量结果，找出子view的左 上 右 下 四个位置的数值 调用子view的layout方法，传入上面求出来的四个值，完成布局 下面开始实现一个流式布局的自定义 首先定义一个类FlowLayout继承自ViewGroup,然后开始实现其onMeasure方法 123456789101112131415161718192021222324252627282930313233343536protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //获取本身宽度的测量模式和大小 int widthSize = MeasureSpec.getSize(widthMeasureSpec); //记录当前行每个子view加起来的中宽度 int currentWidth = 0; //如果有多行，记录最宽的那一行的宽度 int measureWidth = 0; //记录子view每一行加起来的高度 int currentHeight = 0; //遍历测量每个子view int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) { View chileView = getChildAt(i); //测量子view的宽高 measureChild(chileView,widthMeasureSpec,heightMeasureSpec); //得到子view的测量数据 MarginLayoutParams layoutParams = (MarginLayoutParams)chileView.getLayoutParams(); //子view最终实际占用的宽高需要加上它的margin值 int childWidth = chileView.getMeasuredWidth()+ layoutParams.leftMargin+layoutParams.rightMargin; int childHeight = chileView.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin; //如果当前的行的子view的宽加起来小于父view的可用宽度 if(currentWidth&lt;widthSize){ currentWidth = currentWidth+childWidth; currentHeight = Math.max(currentHeight,childHeight); }else { measureWidth = Math.max(currentWidth,childWidth); currentWidth = childWidth; currentHeight = currentHeight+childHeight; } } //保存自己的宽高 setMeasuredDimension(resolveSize(measureWidth,widthMeasureSpec),resolveSize(currentHeight,heightMeasureSpec)); } 循环遍历子view，通过调用系统提供的measureChild方法来测量子view的宽高。 在计算子view的宽高的同时也计算自己的宽高 对于宽，流式布局，我们知道，当子view的宽度相加和大于父view的可用宽的时候，需要换行，所以每一行的子view相加的宽度可能都不一样，我们需要找到一个最大值来当做我们自定义的ViewGroup的宽度，也就是上面代码中的measureWidth 对于高度，定义一个currentHeight来记录当前的高度，没当换一行的时候，它的大小就加上子view的高度 最后通过setMeasuredDimension方法保存自己的宽高。自己的宽高也要根据自己的测量模式来确定，resolveSize就是系统给提供的一个很好用的根据测量模式来返回最终结果的工具方法，传入我们期望宽高和宽高的测量模式即可，省去我们自己根据测量模式来判断返回值。 1234567891011121314151617181920212223242526272829public static int resolveSize(int size, int measureSpec) { return resolveSizeAndState(size, measureSpec, 0) &amp; MEASURED_SIZE_MASK; }public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { //如果是最大模式 case MeasureSpec.AT_MOST: //如果MeasureSpec中的specSize值小于我们传入的期望值 //那也不能超过specSize，返回specSize并给它一个太小的标记 if (specSize &lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { //反之，直接返回我们的期望值。 result = size; } break; //如果是精准模式，直接返回MeasureSpec中的值 case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; } return result | (childMeasuredState &amp; MEASURED_STATE_MASK); } 然后开始布局1234567891011121314151617181920212223242526272829303132333435protected void onLayout(boolean b, int i, int i1, int i2, int i3) { //自身的可用宽 int width = getWidth()-getPaddingLeft()-getPaddingRight(); //当前行子view的总宽度 int currentWidth = 0; //当前高度 int currentHeight = 0; //根据上面onMeasure中测量的值，遍历布局子view，算出子view的左上右下的值，调用其layout方法 int childCount = getChildCount(); for (int j = 0; j &lt; childCount; j++) { View chileView = getChildAt(j); //得到子view的测量数据 MarginLayoutParams layoutParams = (MarginLayoutParams)chileView.getLayoutParams(); //子view最终实际占用的宽高需要加上它的margin值 int childWidth = chileView.getMeasuredWidth()+ layoutParams.leftMargin+layoutParams.rightMargin; int childHeight = chileView.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin; //如果如果当前宽度加上下一个子view的宽度小于父view可用的宽度，就加上子view的宽 //反之，当前宽度重置为下一个子view的宽 if(currentWidth+childWidth&lt;width){ currentWidth = currentWidth+childWidth; }else { currentWidth = childWidth; currentHeight = currentHeight + childHeight; } //计算出子view左 上 右 下 的位置 int childL = currentWidth - childWidth+layoutParams.leftMargin+layoutParams.rightMargin; int childT = currentHeight+layoutParams.topMargin+layoutParams.bottomMargin; int childR = childL+chileView.getMeasuredWidth(); int childB = childT + chileView.getMeasuredHeight(); //布局 chileView.layout(childL,childT,childR,childB); } } 注释很清楚，求出每个View的左 上 右 下的数值，然后调用子view的layout方法进行布局。 OK 一个简单的流式布局就完成了 使用的时候在布局文件中或者在代码中添加数据都可以 xml中添加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;com.chs.androiddailytext.netease.FlowLayout android:id=\"@+id/flow_layout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"哈哈\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"嘎嘎嘎嘎\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"呱呱呱呱呱\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"摇摇摇\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"切克闹\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"呵呵呵呵\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"嘿嘿嘿IEhi额嘿嘿\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"哇哇哇哇\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"来来来来\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"小bitch\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"come on baby\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"都是弟弟\" /&gt; &lt;/com.chs.androiddailytext.netease.FlowLayout&gt; 代码中添加,在activity中12345678910111213141516171819202122232425var datas = mutableListOf&lt;String&gt;() datas.add(\"刮刮卡\") datas.add(\"粒子效果\") datas.add(\"splash\") datas.add(\"QQ红点拖拽\") datas.add(\"PathMeasure\") datas.add(\"屏幕适配\") datas.add(\"刘海适配\") datas.add(\"刘海适配\") datas.add(\"FlowLayout\") datas.add(\"FlowLayout\") for (str in datas){ val textview = TextView(this) val lp = ViewGroup.MarginLayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT) lp.setMargins(15,15,15,15) textview.layoutParams = lp textview.text = str textview.textSize = 20f textview.background = ContextCompat.getDrawable(this,R.drawable.text_bg) flow_layout.addView(textview) } 最后效果： 源码位置在此 参考 ：自定义ViewGroup，写自己的View继承自ViewGroup，然后重写它的onMeasure和onLayout方法即可。 onMeasure 测量阶段主要分3步 循环调用子view的measure方法，测量子view的宽高并保存 通过子view的宽高，来确定自己的宽高 setMeasuredDimension()方法来保存自己的宽高 计算子view的尺寸，需要通过父view的测量模式和大小和子view的LayoutParams 来确定。 View的三种测量模式 EXACTLY：精准测量模式，比如我们在xml中使用match_parent和写死dp值，如果父view是这种模式，那么子veiw在测量的时候，肯定不能超过这个固定的值，返回MeasureSpec中的size。 AT_MOST：最大测量模式，比如我们在xml中是用wrap_content，如果父view是这种模式，理论上讲父view的大小是可以无限大的，但是我们也不知道这个值是多少，就暂时把父view当前的size返回，也是MeasureSpec中的size UNSPECIFIED：无限制测量模式，没有任何限制，一般用不到。 onLayout()布局阶段主要分两步 根据onMeasure中的测量结果，找出子view的左 上 右 下 四个位置的数值 调用子view的layout方法，传入上面求出来的四个值，完成布局 下面开始实现一个流式布局的自定义 首先定义一个类FlowLayout继承自ViewGroup,然后开始实现其onMeasure方法 123456789101112131415161718192021222324252627282930313233343536protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //获取本身宽度的测量模式和大小 int widthSize = MeasureSpec.getSize(widthMeasureSpec); //记录当前行每个子view加起来的中宽度 int currentWidth = 0; //如果有多行，记录最宽的那一行的宽度 int measureWidth = 0; //记录子view每一行加起来的高度 int currentHeight = 0; //遍历测量每个子view int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) { View chileView = getChildAt(i); //测量子view的宽高 measureChild(chileView,widthMeasureSpec,heightMeasureSpec); //得到子view的测量数据 MarginLayoutParams layoutParams = (MarginLayoutParams)chileView.getLayoutParams(); //子view最终实际占用的宽高需要加上它的margin值 int childWidth = chileView.getMeasuredWidth()+ layoutParams.leftMargin+layoutParams.rightMargin; int childHeight = chileView.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin; //如果当前的行的子view的宽加起来小于父view的可用宽度 if(currentWidth&lt;widthSize){ currentWidth = currentWidth+childWidth; currentHeight = Math.max(currentHeight,childHeight); }else { measureWidth = Math.max(currentWidth,childWidth); currentWidth = childWidth; currentHeight = currentHeight+childHeight; } } //保存自己的宽高 setMeasuredDimension(resolveSize(measureWidth,widthMeasureSpec),resolveSize(currentHeight,heightMeasureSpec)); } 循环遍历子view，通过调用系统提供的measureChild方法来测量子view的宽高。 在计算子view的宽高的同时也计算自己的宽高 对于宽，流式布局，我们知道，当子view的宽度相加和大于父view的可用宽的时候，需要换行，所以每一行的子view相加的宽度可能都不一样，我们需要找到一个最大值来当做我们自定义的ViewGroup的宽度，也就是上面代码中的measureWidth 对于高度，定义一个currentHeight来记录当前的高度，没当换一行的时候，它的大小就加上子view的高度 最后通过setMeasuredDimension方法保存自己的宽高。自己的宽高也要根据自己的测量模式来确定，resolveSize就是系统给提供的一个很好用的根据测量模式来返回最终结果的工具方法，传入我们期望宽高和宽高的测量模式即可，省去我们自己根据测量模式来判断返回值。 1234567891011121314151617181920212223242526272829public static int resolveSize(int size, int measureSpec) { return resolveSizeAndState(size, measureSpec, 0) &amp; MEASURED_SIZE_MASK; }public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { //如果是最大模式 case MeasureSpec.AT_MOST: //如果MeasureSpec中的specSize值小于我们传入的期望值 //那也不能超过specSize，返回specSize并给它一个太小的标记 if (specSize &lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { //反之，直接返回我们的期望值。 result = size; } break; //如果是精准模式，直接返回MeasureSpec中的值 case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; } return result | (childMeasuredState &amp; MEASURED_STATE_MASK); } 然后开始布局1234567891011121314151617181920212223242526272829303132333435protected void onLayout(boolean b, int i, int i1, int i2, int i3) { //自身的可用宽 int width = getWidth()-getPaddingLeft()-getPaddingRight(); //当前行子view的总宽度 int currentWidth = 0; //当前高度 int currentHeight = 0; //根据上面onMeasure中测量的值，遍历布局子view，算出子view的左上右下的值，调用其layout方法 int childCount = getChildCount(); for (int j = 0; j &lt; childCount; j++) { View chileView = getChildAt(j); //得到子view的测量数据 MarginLayoutParams layoutParams = (MarginLayoutParams)chileView.getLayoutParams(); //子view最终实际占用的宽高需要加上它的margin值 int childWidth = chileView.getMeasuredWidth()+ layoutParams.leftMargin+layoutParams.rightMargin; int childHeight = chileView.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin; //如果如果当前宽度加上下一个子view的宽度小于父view可用的宽度，就加上子view的宽 //反之，当前宽度重置为下一个子view的宽 if(currentWidth+childWidth&lt;width){ currentWidth = currentWidth+childWidth; }else { currentWidth = childWidth; currentHeight = currentHeight + childHeight; } //计算出子view左 上 右 下 的位置 int childL = currentWidth - childWidth+layoutParams.leftMargin+layoutParams.rightMargin; int childT = currentHeight+layoutParams.topMargin+layoutParams.bottomMargin; int childR = childL+chileView.getMeasuredWidth(); int childB = childT + chileView.getMeasuredHeight(); //布局 chileView.layout(childL,childT,childR,childB); } } 注释已经很清楚，求出每个View的左 上 右 下的数值，然后调用子view的layout方法进行布局。 OK 一个简单的流式布局就完成了 使用的时候在布局文件中或者在代码中添加数据都可以 xml中添加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;com.chs.androiddailytext.netease.FlowLayout android:id=\"@+id/flow_layout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"哈哈\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"嘎嘎嘎嘎\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"呱呱呱呱呱\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"摇摇摇\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"切克闹\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"呵呵呵呵\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"嘿嘿嘿IEhi额嘿嘿\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"哇哇哇哇\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"来来来来\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"小bitch\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"come on baby\" /&gt; &lt;TextView style=\"@style/text_flow\" android:text=\"都是弟弟\" /&gt; &lt;/com.chs.androiddailytext.netease.FlowLayout&gt; 代码中添加12345678910111213141516171819202122232425var datas = mutableListOf&lt;String&gt;() datas.add(\"刮刮卡\") datas.add(\"粒子效果\") datas.add(\"splash\") datas.add(\"QQ红点拖拽\") datas.add(\"PathMeasure\") datas.add(\"屏幕适配\") datas.add(\"刘海适配\") datas.add(\"刘海适配\") datas.add(\"FlowLayout\") datas.add(\"FlowLayout\") for (str in datas){ val textview = TextView(this) val lp = ViewGroup.MarginLayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT) lp.setMargins(15,15,15,15) textview.layoutParams = lp textview.text = str textview.textSize = 20f textview.background = ContextCompat.getDrawable(this,R.drawable.text_bg) flow_layout.addView(textview) } 最后效果： 源码位置在此 参考： https://blog.csdn.net/lmj623565791/article/details/38352503","link":"/2019/04/13/technology/自定义ViewGroup练习之流式布局/"},{"title":"APP瘦身优化","text":"APP瘦身优化 1 为什么要瘦身优化1.1 瘦身优化的好处 提高下载转化率 大型APP都有Lite版本 渠道合作商要求，降低推广成本 应用市场比如 Google Play 要求超过 100MB 的应用只能使用APK 扩展文件方式上传，由此可见应用包体积对应用市场的服务器带宽成本还是会有一点压力。 Resource 资源、Library 以及 Dex 类加载这些都会占用不少的内存，包体积减少也能起到优化内存的效果 一个100M的apk，安装解压之后可能会占用200M以上的空间，对低端手机不够友好。 1.2瘦身优化3点方法论 删：删除无用的代码和资源 压：压缩代码和资源 移：实在不行就抽离出，动态加载，动态下发。 1.3 APK的组成 lib 存放so文件，有armeabi armeabi-v7a arm64-v8a x86 mips x86-64。一般只需要支持armeabi和x86即可 res：存放编译后的资源文件 例如drawable layout等 assets：应用程序的资源，应用程序可以使用AssetManager来检索该资源 MEAT-INFO：存在于已经签名的apk中，包含了apk中左右的文件的签名摘要等信息 classes.dex：Java Class 被Dex编译后可提供给Dalvik/ART虚拟机所理解的文件格式 resources.arsc 编译后的二进制资源文件 AndroidManifest.xml Android中清单文件 1.4 APK分析工具 ApkTool https:ibotpeaches.github.io/Apktool/ apktool d xx.apk Analyze APK Android Studio 2.2之后 查看APK组成 大小 占比 查看Dex文件组成 APK对比 https://nimbledroid.com App性能分析 显示文件大小及排行榜 dex 方法数等 还可以可以分析启动速度 android-classyshark 二进制检查工具 https://github.com/google/android-classyshark 支持多种格式 Apk Jar Class So 代码分析工具 PMD https://pmd.github.io 下载后输入： ./run.sh cpdgui pmd -d /usr/src -R rulesets/java/quickstart.xml -f text 文档地址：https://pmd.github.io/pmd-6.17.0/pmd_rules_java.html 资料：https://www.jianshu.com/p/5fe23ed8d147 2 图片压缩相关一个工程中图片所占的资源是相当大的，所以第一步就从图片压缩开始 2.1 SVG官方SVG使用介绍：https://developer.android.google.cn/studio/write/vector-asset-studio#about 使用矢量可绘制对象代替位图可以减小 APK 的大小，因为可以针对不同的屏幕密度调整同一文件的大小，而不会降低图片质量。对于不支持矢量可绘制对象的较低版本的 Android 系统，Vector Asset Studio 可以在编译时针对每种屏幕密度将矢量可绘制对象转换为不同大小的位图。 SVG在Android中主要是在各种图标中使用，不过Android中不是直接使用SVG图片，而是将其转化为一个以vector为标签的xml文件来使用。 单个转换在可以在AndroidStudio中转换，具体步骤右键点击 res 文件夹，然后依次选择 New &gt; Vector Asset，出现下图 在文件夹中选择自己的SVG图标后点击确定，就会在drawable文件夹下生成相应的xml文件比如上面的图片生成的结果：123456789&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"64dp\" android:height=\"64dp\" android:viewportWidth=\"1024\" android:viewportHeight=\"1024\"&gt; &lt;path android:fillColor=\"#FF000000\" android:pathData=\"M177.74,652.95A364.07,364.07 0,0 0,331.31 826.52v-310.83L192.49,645.15c-4.3,4.01 -9.4,6.61 -14.75,7.81zM157.75,590.03l209.71,-195.56L170.67,394.46c-0.62,0 -1.24,-0.01 -1.85,-0.05A362.19,362.19 0,0 0,149.33 512c0,26.78 2.9,52.91 8.42,78.03zM459.83,394.46a32.06,32.06 0,0 1,-5.15 6.19l-62.11,57.91c1.76,3.96 2.73,8.34 2.73,12.95v79.54c3.58,1.64 6.91,3.98 9.8,7.01l67.57,70.85h90.57l68.3,-72.94v-95.87l-68.18,-66.83c-2.77,0.78 -5.69,1.19 -8.69,1.19h-94.84zM395.23,855.47A362.22,362.22 0,0 0,512 874.67c32.77,0 64.52,-4.34 94.72,-12.49l-211.41,-221.65L395.31,853.33c0,0.71 -0.03,1.42 -0.07,2.13zM670.7,838.2a364.27,364.27 0,0 0,155.69 -145.28L533.71,692.92l131.95,138.35c2.03,2.13 3.71,4.47 5.05,6.93zM855.39,628.98A362.21,362.21 0,0 0,874.67 512c0,-36.66 -5.44,-72.05 -15.55,-105.41L650.91,628.91L853.33,628.91c0.69,0 1.38,0.02 2.06,0.06zM197.96,330.46h301.31l-139.73,-136.94a31.98,31.98 0,0 1,-5.9 -7.89A364.27,364.27 0,0 0,197.97 330.47zM418.34,161.55l213.21,208.94v-195.2c0,-1.92 0.17,-3.79 0.49,-5.62A362.11,362.11 0,0 0,512 149.33c-32.38,0 -63.79,4.25 -93.65,12.21zM695.55,446.61L695.55,487.64l134.43,-143.57c0.75,-0.8 1.55,-1.56 2.35,-2.26a364.37,364.37 0,0 0,-136.78 -142.67v247.49zM512,938.67C276.36,938.67 85.33,747.64 85.33,512S276.36,85.33 512,85.33s426.67,191.03 426.67,426.67 -191.03,426.67 -426.67,426.67z\"/&gt;&lt;/vector&gt; 批量转换可以使用一个开源库地址： https://developer.android.google.cn/studio/write/vector-asset-studio svg的正确使用方法：在build.gradle中的defaultConfig闭包中使用入下配置1234// 将svg图片生成 指定维度的png图片vectorDrawables.generatedDensities(&apos;xhdpi&apos;,&apos;xxhdpi&apos;)// 使用support-v7兼容5.0以上vectorDrawables.useSupportLibrary = true 5.0以下 将svg图片生成指定维度的png图片,下面写几个就会生成几个相应的图片 5.0以上 以上使用support-v7进行兼容 12345&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:srcCompat=\"@drawable/ic_friend_circle\" /&gt; 2.2 Tint着色器上面的ImageView可以通过着色器直接上色，相同的图片，不同的效果。 1234567891011&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:srcCompat=\"@drawable/ic_friend_circle\" /&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:srcCompat=\"@drawable/ic_friend_circle\" android:tint=\"@color/colorPrimary\" /&gt; 效果如下： 那使用一张图片，能实现我们平时常用的selector效果吗，当然也是可以的 首先在drawable文件夹下创建一个selector12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/ic_friend_circle\" android:state_pressed=\"true\" /&gt; &lt;item android:drawable=\"@drawable/ic_friend_circle\" /&gt;&lt;/selector&gt; 正常状态和按下状态使用同一张图片，然后在res目录下面创建一个color文件夹，里面创建一个color的选择器12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:color=\"@android:color/holo_purple\" android:state_pressed=\"true\" /&gt; &lt;item android:color=\"@android:color/transparent\" /&gt;&lt;/selector&gt; 最后在layout中使用1234567&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:clickable=\"true\" android:focusable=\"true\" app:srcCompat=\"@drawable/ic_friend_circle\" android:tint=\"@color/tint_color_selector\" /&gt; 效果： 2.3 使用webp格式webp是谷歌提供的一种有损压缩格式，这种图片格式相比png和jpg格式的图片损失的质量几乎可以忽略不计，但是压缩之后的图片体积却比png或者jpg小很多。 AndridStudio就有接将png和jpg格式的图转换成webp格式的图片的功能。右键想要转化的图片，在弹出菜单中点击convert to webp条目就会进入转化的界面，默认是压缩为75%的质量，可以自己调节。有时候几M的图片可以压缩成几百kb而且清晰度肉眼几乎看不出来，瘦身效果非常棒。（如果想要一次转化多张图片就在文件夹上右键点击转换） 也可以下载WebP转换工具 https://developers.google.com/webp/doc/precompiled 2.4 png压缩如果非要使用png，png也有几个压缩工具 几个压缩png的工具 https://tinypng.com https://github.com/waynell/TinyPngPlugin https://imageoptim.com/mac http://www.apprcn.com/pngyu.html jpg压缩 一般不压缩 如果要压缩可以使用下面工具 packJPG： https://roov.org/2013/03/packjpg-options/ guetzli：https://github.com/google/guetzli 2.5 使用纯色图片如果项目中用到了纯色图片，可以使用代码实现 比如shape或者自定义view 3 配置资源打包在app下的build.gradle文件中的defaultConfig 闭包中配置下面123456defaultConfig { ... // 只保留指定和默认资源 resConfigs(&apos;zh-rCN&apos;, &apos;ko&apos;) ... } 这样配置有什么好处呢？我们知道APK打包之后，资源文件会映射到resources.arsc文件中，我们使用AndroidStudio来查看这个apk中的resources.arsc文件中的string文件，可以看到下图中的样子。 平时开发的时候，我们都会把一些写死的文字放到string.xml文件中，上图中可以看到，Android中默认会把我们的string.xml文件中的数据翻译成几十种国家的语言，相当于平白多出了几十个string.xml文件，而我们的应用可能只需要一两种语言就可以了。 加上前面的配置，就能将语言只保留指定资源和默认资源。效果如下图： 4 配置so库如果项目中使用了第三方SDK或者NDK，如果不配置cpu架构，可能就会导入全部的so库文件，这时候可以在gradle中配置，选择特定的so库打包到apk中，这块瘦身效果是很可观的。配置方式：app-&gt;build.gradle-&gt;android-&gt;defaultConfig中12345678defaultConfig { ... // 配置so库架构（真机：arm，模拟器：x86） ndk { abiFilters(&apos;armeabi&apos;,&apos;armeabi-v7a&apos;) } ... } 那该选择那些库呢？ x86_64兼容x86 armeabi几乎可以兼容所有机型 armeabi-v7a兼容armeabi arm64-v8a兼容armeabi-v7a x86一般是模拟器所以我们可以只留一份armeabi，arm64-v8a或者armeabi-v7a中的一个即可。现在是主流手机基本都是armeabi-v7a以上了，谷歌play已经要求所有apk必须适配arm64-v8a的cpu 如果下载微信和淘宝和支付宝的apk解压之后可以看到，微信中只使用了arm64-v8a，淘宝中只使用了armeabi-v7a，支付宝中只保留了armeabi 提供so库的时候，要么全给要么不给。不能arm64-v8a文件夹中给两个so库armeabi-v7a文件夹中给一个so库 对于cpu敏感的so库，我们可以在armeabi-v7a中放一套v8a的库，根据CPU的架构来动态的选择使用哪个 也可以构建的时候分包，利用应用市场来动态分发（google play） 如果项目中用的so库比较多，使用此过滤方法瘦身效果非常明显 5 Lint检查Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量 问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。 随着代码迭代版本的增多，很容易会遗留一些无用的代码、资源文件，我们可以使用 Lint 进行检查并清除。 打开AndroidStudio在菜单栏中，依次选择 Analyze &gt; Inspect Code。如下： 弹出窗口中选择检查的包的范围，之后点击OK，就会自动检查筛选出一些错误，警告，无用代码资源。 查看检查出来的文件，根据实际情况判断是修改还是删除。 需要注意的是，如果代码中通过反射等手段动态获取资源id，这时候也会被lint检查到认为是没有用过的资源所以lint检查出来的资源删除的时候需要谨慎 6 混淆和资源压缩项目做的时间长了，代码中肯定会有一些没有用到的资源文件，删除这些无用的资源当然也可以起到瘦身的作用 前面知道了Lint检查出来，删除后是是物理删除，删了之后就找不到了，比较危险，比如我们代码中是通过反射找到某些资源，而这些资源会被上面的操作删除掉，最终导致应用崩溃。 比较安全的优化策略是使用资源压缩 https://developer.android.google.cn/studio/build/shrink-code 123456789buildTypes { release { // 源代码混淆开启 minifyEnabled true // 启动资源压缩 shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos; } } 6.1 代码混淆 代码中各个元素改成无意义的名字 以更难理解的形式重写部分逻辑 打乱代码格式 Proguard 代码中元素名称改短 取出无用元素等。 在混淆的时候，不要乱keep，有的类可能不需要keep 当使用Android Gradle 插件 3.4.0 或更高版本编译您的项目时，Gradle插件不再使用 ProGuard 执行编译时代码优化，而是与 R8 编译器一起使用，共同处理以下编译时任务 代码压缩:从应用及其库依赖项中检测并安全地移除未使用的类、字段、方法和属性 资源压缩：从应用中移除未使用的资源，包括应用的库依赖项中未使用的资源。此功能可与代码压缩结合使用，这样一来，移除未使用的代码后，也可以安全地移除不再引用的任何资源。 混淆：缩短类和成员的名称，从而减小 DEX 文件大小。 优化：检查并重写代码，以进一步减小应用 DEX 文件的大小。例如，如果 R8 检测到从未采用过给定 if/else 语句的 else {} 分支，R8 便会移除 else {} 分支的代码。 6.2 资源压缩shrinkResources可以压缩资源，比如可以把一些无用的资源压缩成只有名字没有内容的文件 只有开启了混淆之后使用这个才能有效果，因为混淆之后会把一些无用的类删掉，那么无用的类中引用的资源也就可以放心的压缩了。 如果要保留或者压缩特定的资源，可以子在res/raw/文件夹下创建一个keep.xml文件内如可以如下：1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:keep=\"@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*\" tools:discard=\"@layout/unused2\" /&gt; tools:keep 属性中指定要保留的每个资源 tools:discard 属性中指定要舍弃的每个资源 这两个属性都接受逗号分隔的资源名称列表。也可以将星号字符用作通配符。 只是开启shrinkResources，系统会使用一种比较安全的模式去压缩资源，对于一些不确定判断都会选择不去压缩比如，如果代码中或者某个库中使用了Resources.getIdentifier()，这就说明我们的代码是通过动态生成的字符串来查找资源id，这时候资源压缩器就会开启防御行为，把所有相关的资源都标记为使用，不会压缩比如下面的代码就会把所有的以img_为前缀的资源都标记为已用。12String name = String.format(&quot;img_%1d&quot;, angle + 1);res = getResources().getIdentifier(name, &quot;drawable&quot;, getPackageName()); 资源压缩器还会浏览代码以及各种 res/raw/ 资源中的所有字符串常量，查找格式类似于 file:///android_res/drawable//ic_plus_anim_016.png 的资源网址。如果它找到这样的字符串，或发现一些其他字符串看似可用来构建这样的网址，就不会将它们移除。 如果想要完全压缩，停用这种安全模式，可以在res/raw/文件夹下创建一个keep.xml文件来开启严苛模式123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:shrinkMode=&quot;strict&quot; /&gt; 开启严苛模式之后，如果代码中还是用了上面Resources.getIdentifier()方式来查找资源，就必须在keep.xml中添加keep属性，把所要找的资源keep住 7 资源混淆和7zip压缩资源混淆和压缩不仅可以减少包体积，还能增大资源文件的反编译的难度 通过resource.arsc文件混淆步骤 解析arsc文件（主要解析资源名字符串池） 修改字符串池中的字符串（替换为a/b等无意义字符） 修改apk中res目录资源文件名 打包（7zip）、对齐、签名 资源混淆和压缩可以使用微信开源方案 AndResGuard ， AndResGuard原理 8 其他减少Enum枚举的使用 每减少一个枚举可以减少1k左右 优化引用的库，基础库统一 选择更小的库 AndroidStudio插件：Android Methods Count ，使用这个插件可以看到引入库的方法数量 使用第三方库的时候，最好只引入使用到的代码。 音频资源压缩 资料： https://mp.weixin.qq.com/s/WGl2TBkz8a_uZHiolGo0sQ https://mp.weixin.qq.com/s/QRIy_apwqAaL2pM8a_lRUQ https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html","link":"/2019/12/20/optimize/APP瘦身优化/"},{"title":"Android Jetpack之Lifecycles","text":"Android Jetpack之Lifecycles Android中大多数的组件都有生命周期函数，生命周期由操作系统或者framework层的代码来管理，它们是Andorid的核心运行方式。我们平时写程序必须遵循生命周期的原则，否则会造成内存泄露甚至程序崩溃 我们通常会在activity和fragment的生命周期函数内来做一些初始化操作和释放资源的一些操作，但是这样会导致代码组织不良，容易出错，使用生命周期感知组件，可以让生命周期方法移动到组件上来。 android.arch.lifecycle包中提供了一些类和接口来构建生命周期组件，它们可以根据activity和fragment的生命周期的当前状态自动调整自身行为。 在没有使用生命周期感知组件之前，如果我们想要使用定位服务，我们可能会按照下面的方式来写，通过一个接口来回调123456789101112131415161718192021222324252627282930313233343536373839class MyListener { public MyListener() { // ... } void start() { // 连接到系统位置服务 } void stop() { // 断开连接 }}class MyActivity extends AppCompatActivity { private MyListener myListener; @Override public void onCreate(...) { myListener = new MyListener(this, (location) -&gt; { //更新UI }); } @Override public void onStart() { super.onStart(); myListener.start(); //如果有其他组件需要监听生命周期，在下面继续回调 } @Override public void onStop() { super.onStop(); myListener.stop(); //如果有其他组件需要监听生命周期，在下面继续回调 }} 上面的写法是可以的，但是考虑到假如除了定位服务还有一些别的服务也需要在这个activity的生命周期函数内执行，比如网络，比如媒体查询，这时候，onStart()和onStop()这两个方法内会有很多的接口回调不利于维护。 另外还会有一些别的问题，比如执行onStop()的时候，初始化还没完成，而我们又在初始化之后做了一些耗时的操作，这就会导致资源不能及时的关闭或者断开。我们可能需要在初始化完成后来检查其所依赖的activity的状态来避免这个问题。 lifecycle组件可以很灵活的处理这些问题。 lifecyle的导入 123456789101112131415161718 //如果没用AndroidX implementation \"android.arch.lifecycle:runtime:1.1.1\" annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"//如果用了AndoridXdef lifecycle_version = \"2.0.0\" // 包含 ViewModel and LiveData implementation \"androidx.lifecycle:lifecycle-extensions:$lifecycle_version\" //只包含 ViewModel 如果是 Kotlin 使用 lifecycle-viewmodel-ktx implementation \"androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version\" // 只包含 LiveData implementation \"androidx.lifecycle:lifecycle-livedata:$lifecycle_version\" // 只包含Lifecycles implementation \"androidx.lifecycle:lifecycle-runtime:$lifecycle_version\" //注解处理器，如果是Kotlin 使用 kapt 代替 annotationProcessor annotationProcessor \"androidx.lifecycle:lifecycle-compiler:$lifecycle_version\" //如果使用了Java8, 使用下面的代替lifecycle-compiler implementation \"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version\" lifecycle是一个类，它包含一些生命周期组件的生命周期的信息比如activity和fragment，并允许其他的对象监听此状态 它主要使用两个枚举类来监听它所关联的组件的生命周期 Event: 这些events是从系统框架层（framework ）和 Lifecycle类中派发的，他们映射到 activities 和 fragments 中的回调中。 State：由Lifecycle对象来跟组组件的当前状态。 LifecycleOwner是一个单一的方法接口，表示该类有一个Lifecycle，它有一个方法， getLifecycle()必须由类实现，该方法可以获取生命周期比如activity和fragment的生命周期，任何自定义的类都可以实现这个接口。 使用LifecycleObserver可以和LifecycleOwner无缝对接，LifecycleOwner 相当于被观察者，LifecycleObserver相当于观察者，LifecycleOwner可以获取组件的生命周期，那么观察者也能观察生命周期的变化了。 在Support Library 26.1.0 和以上的版本中，activity和fragment已经默认实现了LifecycleOwner接口，如果是26.1.0以下版本需要自定义实现LifecycleOwner接口。 比如一开始的例子，可以让MyLocationListener实现LifecycleObserver 12345678910111213141516171819202122public class MyListener implements LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void connectListener() { // 连接到服务 Log.i(\"LifecycleEvent\",\"start\"); } @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void disconnectListener() { // 断开连接 Log.i(\"LifecycleEvent\",\"stop\"); }}public class LifeActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); getLifecycle().addObserver(new MyListener()); }} 通过上面的实现，MyListener类就可以感知生命周期了，以后所有的初始化和释放的操作它都可以自己完成，查看log日志可以看到MyListener已经可以感知到生命周期了1204-08 16:43:49.144 11995-11995/com.chs.androiddailytext I/LifecycleEvent: start04-08 16:43:50.873 11995-11995/com.chs.androiddailytext I/LifecycleEvent: stop MyListenr除了实现LifecycleObserver然后使用注解，也可以继承DefaultLifecycleObserver然后实现里面的方法。因为Java8之后注解的方式会被弃用，所以推荐使用DefaultLifecycleObserver1234567/** * Callback interface for listening to {@link LifecycleOwner} state changes. * &lt;p&gt; * If you use Java 8 language, &lt;b&gt;always&lt;/b&gt; prefer it over annotations. */@SuppressWarnings(\"unused\")public interface DefaultLifecycleObserver extends FullLifecycleObserver {......} Lifecycle的实现原理: 本文使用的API28 它其实就是一个观察者模式，LifecycleOwner是被观察者，在Support Library 26.1.0 和以上的版本中，activity和fragment已经默认实现了LifecycleOwner接口，所以他俩都是被观察者，我们自己定义的LifecycleObserver就是观察者， 通过getLifecycle().addObserver方法注册观察者。 下面从getLifecycle()这个方法开始查看源码123456789 //在FragmentActivity中，FragmentActivity继承自ComponentActivity(本文使用的API28) public Lifecycle getLifecycle() { return super.getLifecycle(); } //在ComponentActivity 中 public Lifecycle getLifecycle() { return mLifecycleRegistry; }LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); getLifecycle()方法返回了一个LifecycleRegistry对象123456789101112131415public class LifecycleRegistry extends Lifecycle { public LifecycleRegistry(@NonNull LifecycleOwner provider) { mLifecycleOwner = new WeakReference&lt;&gt;(provider); mState = INITIALIZED; }}public class ComponentActivity extends Activity implements LifecycleOwner, KeyEventDispatcher.Component { ...... protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); } ...... } LifecycleRegistry对象继承自Lifecycle，是从ComponentActivity中直接new出来的，并传入一个LifecycleOwner对象。ComponentActivity实现了LifecycleOwner接口所以传入自己就好了。 ComponentActivity中除了创建了LifecycleRegistry对象外在其onCreate方法中还执行了ReportFragment.injectIfNeededIn(this)这个方法。 下面来看看这个ReportFragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 分派初始化事件的内部类。 * @hide */@SuppressWarnings(\"UnknownNullness\") // TODO https://issuetracker.google.com/issues/112197238@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)public class ReportFragment extends Fragment { private static final String REPORT_FRAGMENT_TAG = \"androidx.lifecycle\" + \".LifecycleDispatcher.report_fragment_tag\"; public static void injectIfNeededIn(Activity activity) { // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) { manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); } } static ReportFragment get(Activity activity) { return (ReportFragment) activity.getFragmentManager().findFragmentByTag( REPORT_FRAGMENT_TAG); } private ActivityInitializationListener mProcessListener; private void dispatchCreate(ActivityInitializationListener listener) { if (listener != null) { listener.onCreate(); } } private void dispatchStart(ActivityInitializationListener listener) { if (listener != null) { listener.onStart(); } } private void dispatchResume(ActivityInitializationListener listener) { if (listener != null) { listener.onResume(); } } @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); } @Override public void onStart() { super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); } @Override public void onResume() { super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); } @Override public void onPause() { super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE); } @Override public void onStop() { super.onStop(); dispatch(Lifecycle.Event.ON_STOP); } @Override public void onDestroy() { super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; } private void dispatch(Lifecycle.Event event) { Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) { ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; } if (activity instanceof LifecycleOwner) { Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) { ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); } } } void setProcessListener(ActivityInitializationListener processListener) { mProcessListener = processListener; } interface ActivityInitializationListener { void onCreate(); void onStart(); void onResume(); }} 通过上面的代码我们可以知道： injectIfNeededIn方法用来创建这个ReportFragment，并且将它commit到当前的Activity中。这是一个没有布局文件的空的Fragment，虽然没有布局文件，但是它有一个完整的生命周期，我们可以把它的生命周期利用起来。 在其生命周期方法中调用dispatch(Lifecycle.Event event)方法，传入对应的event，Event是一个枚举类，里面定义了生命周期函数名字对应的标志位常量。比如onStart()中就传入Lifecycle.Event.ON_RESUME。 dispatch方法中调用了getLifecycle().handleLifecycleEvent(event)，前面我们知道getLifecycle()返回的是一个LifecycleRegistry对象，已经在Activity成员变量中new了出来。 注意：在onActivityCreated，onStart，onResume方法中除了调用dispatch方法还是调用了dispatchCreate，dispatchStart，dispatchResume方法。这些先略过最后在看。 1234public void handleLifecycleEvent(@NonNull Lifecycle.Event event) { State next = getStateAfter(event); moveToState(next); } handleLifecycleEvent方法的作用就是，设置当前状态并通知观察者,下面来看getStateAfter和moveToState方法1234567891011121314151617181920212223242526272829303132static State getStateAfter(Event event) { switch (event) { case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; } throw new IllegalArgumentException(\"Unexpected event value \" + event);}private void moveToState(State next) { if (mState == next) { return; } mState = next; //如果正在发送事件或者正在注册事件，直接返回 if (mHandlingEvent || mAddingObserverCounter != 0) { mNewEventOccurred = true; // we will figure out what to do on upper level. return; } mHandlingEvent = true; sync(); mHandlingEvent = false;} 从getStateAfter中找出当前的需要赋值的状态，然后赋值给成员变量mState。 状态赋值完之后调用了sync()方法，下面看这个方法12345678910111213141516171819202122232425262728private void sync() { LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) { throw new IllegalStateException(\"LifecycleOwner of this LifecycleRegistry is already\" + \"garbage collected. It is too late to change lifecycle state.\"); } while (!isSynced()) { mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) { backwardPass(lifecycleOwner); } Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) { forwardPass(lifecycleOwner); } } mNewEventOccurred = false;}private boolean isSynced() { if (mObserverMap.size() == 0) { return true; } State eldestObserverState = mObserverMap.eldest().getValue().mState; State newestObserverState = mObserverMap.newest().getValue().mState; return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;} isSynced()方法，用来判断最后添加的观察者和最新添加的观察者的状态是否一致，并且当前将要分发的事件状态和最新添加的观察者的状态是否一致。 如果一致执行backwardPass方法和forwardPass方法，两个方法都是循环遍历观察者的集合分发事件，正常情况下执行backwardPass方法，如果在执行backwardPass方法的过程中有新的状态改变，会执行forwardPass方法。 1234567891011121314151617181920212223242526272829private void backwardPass(LifecycleOwner lifecycleOwner) { Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) { Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) { Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); } }} private void forwardPass(LifecycleOwner lifecycleOwner) { Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) { Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) { pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); } }} 可以看到这两个方法中都是循环观察者的集合，调用观察者（observer）的dispatchEvent方法来分发事件。这个观察者是一个ObserverWithState对象 观察者的集合是咋来的呢，Ok,现在回到Activity中getLifecycle().addObserver(new MyListener());，前面我们都是跟着getLifecycle()走的，现在看addObserver这个添加观察者的方法。 addObserver是Lifecycle这个接口中的方法，LifecycleRegistry实现了Lifecycle接口，着getLifecycle()方法返回一个LifecycleRegistry对象，所以去LifecycleRegistry中看addObserver方法1234567891011121314151617181920212223242526272829303132public void addObserver(@NonNull LifecycleObserver observer) { State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) { return; } LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) { // it is null we should be destroyed. Fallback quickly return; } boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) { pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); } if (!isReentrance) { // we do sync only on the top level. sync(); } mAddingObserverCounter--;} 上面代码最主要的就是封装一个ObserverWithState对象，然后保存到一个自定义的Map集合中。前面我们知道backwardPass和forwardPass方法中都是当状态改变的时候，循环调用的ObserverWithState中的dispatchEvent方法。12345678910111213141516static class ObserverWithState { State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) { mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; } void dispatchEvent(LifecycleOwner owner, Event event) { State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; } } 构造方法中，把我们传入的LifecycleObserver对象通过lifecycleEventObserver方法转换成一个LifecycleEventObserver对象， LifecycleEventObserver也是一个接口，只有一个方法onStateChanged。它有好几个子类，比如我们的MyListener实现了LifecycleObserver接口，那么它会转化成SingleGeneratedAdapterObserver，如果我们的MyListener实现了DefaultLifecycleObserver接口，就会转化成FullLifecycleObserverAdapter。 事件分发方法dispatchEvent中调用onStateChanged通知状态改变了。 到这里观察和监听的一个闭环就完成了 现在回到ReportFragment中，前面在看其生命周期方法的时候看到在onActivityCreated，onStart，onResume方法中除了调用dispatch方法还是调用了dispatchCreate，dispatchStart，dispatchResume方法。为啥呢？ 因为这个ReportFragment是在ComponentActivity这个Activity中的onCreate方法中创建的，ComponentActivity继承自Activity假如我们的Activity也直接继承自Activity，那没法初始化ReportFragment，怎么监听生命周期呢？ 跟进这几个方法看看 12345private void dispatchCreate(ActivityInitializationListener listener) { if (listener != null) { listener.onCreate(); } } 调用了ActivityInitializationListener的相关方法，前面贴的ReportFragment的代码最后可以看到ActivityInitializationListener是一个接口，里面有onCreate，onStart，onResume方法，ReportFragment中还提供了一个set方法。studio中点击这个set方法，进入到新大陆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class ProcessLifecycleOwner implements LifecycleOwner { @VisibleForTesting static final long TIMEOUT_MS = 700; //mls // ground truth counters private int mStartedCounter = 0; private int mResumedCounter = 0; private boolean mPauseSent = true; private boolean mStopSent = true; private Handler mHandler; private final LifecycleRegistry mRegistry = new LifecycleRegistry(this); private Runnable mDelayedPauseRunnable = new Runnable() { @Override public void run() { dispatchPauseIfNeeded(); dispatchStopIfNeeded(); } }; ActivityInitializationListener mInitializationListener = new ActivityInitializationListener() { @Override public void onCreate() { } @Override public void onStart() { activityStarted(); } @Override public void onResume() { activityResumed(); } }; private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner(); /** * The LifecycleOwner for the whole application process. Note that if your application * has multiple processes, this provider does not know about other processes. * * @return {@link LifecycleOwner} for the whole application. */ @NonNull public static LifecycleOwner get() { return sInstance; } static void init(Context context) { sInstance.attach(context); } void activityStarted() { mStartedCounter++; if (mStartedCounter == 1 &amp;&amp; mStopSent) { mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); mStopSent = false; } } void activityResumed() { mResumedCounter++; if (mResumedCounter == 1) { if (mPauseSent) { mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); mPauseSent = false; } else { mHandler.removeCallbacks(mDelayedPauseRunnable); } } } void activityPaused() { mResumedCounter--; if (mResumedCounter == 0) { mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS); } } void activityStopped() { mStartedCounter--; dispatchStopIfNeeded(); } void dispatchPauseIfNeeded() { if (mResumedCounter == 0) { mPauseSent = true; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); } } void dispatchStopIfNeeded() { if (mStartedCounter == 0 &amp;&amp; mPauseSent) { mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); mStopSent = true; } } private ProcessLifecycleOwner() { } void attach(Context context) { mHandler = new Handler(); mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); Application app = (Application) context.getApplicationContext(); app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { ReportFragment.get(activity).setProcessListener(mInitializationListener); } @Override public void onActivityPaused(Activity activity) { activityPaused(); } @Override public void onActivityStopped(Activity activity) { activityStopped(); } }); } @NonNull @Override public Lifecycle getLifecycle() { return mRegistry; }} 从注释里可以看到，该类为整个应用程序过程提供生命周期。在它的attach方法中，通过registerActivityLifecycleCallbacks方法注册了监听了程序的生命周期。在onActivityCreated方法中可以看到给ReportFragment设置了mInitializationListener。 attach方法在哪里调用的呢12345private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner(); static void init(Context context) { sInstance.attach(context); } 调用了一个静态的init方法，进入调用的地方12345678910111213141516171819202122232425262728293031323334353637public class ProcessLifecycleOwnerInitializer extends ContentProvider { @Override public boolean onCreate() { LifecycleDispatcher.init(getContext()); ProcessLifecycleOwner.init(getContext()); return true; } @Nullable @Override public Cursor query(@NonNull Uri uri, String[] strings, String s, String[] strings1, String s1) { return null; } @Nullable @Override public String getType(@NonNull Uri uri) { return null; } @Nullable @Override public Uri insert(@NonNull Uri uri, ContentValues contentValues) { return null; } @Override public int delete(@NonNull Uri uri, String s, String[] strings) { return 0; } @Override public int update(@NonNull Uri uri, ContentValues contentValues, String s, String[] strings) { return 0; }} 这里我们看到了初始化的地方，ProcessLifecycleOwnerInitializer继承自ContentProvider，Lifecycle自动在我们的AndroidManifest.xml中添加了一个ContentProvider，用于初始化ProcessLifecycleOwner和LifecycleDispatcher。 ContentProvider的onCreate()方法执行时间比Application的onCreate()执行时间还要早，而且肯定会执行。所以在ContentProvider的onCreate()方法里面初始化这是是没问题的。 我们看到还调用了LifecycleDispatcher的初始化的方法123456789101112131415161718192021222324252627282930313233class LifecycleDispatcher { private static AtomicBoolean sInitialized = new AtomicBoolean(false); static void init(Context context) { if (sInitialized.getAndSet(true)) { return; } ((Application) context.getApplicationContext()) .registerActivityLifecycleCallbacks(new DispatcherActivityCallback()); } @SuppressWarnings(\"WeakerAccess\") @VisibleForTesting static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { ReportFragment.injectIfNeededIn(activity); } @Override public void onActivityStopped(Activity activity) { } @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) { } } private LifecycleDispatcher() { }} 可以看到这里面也注册了registerActivityLifecycleCallbacks来监听生命周期，并在其onActivityCreated方法中创建了一个ReportFragment，哈哈还是使用ReportFragment。ReportFragment的injectIfNeededIn方法只会创建一个ReportFragment。所以即使我们在ComponentActivity中的onCreate方法中重复调用也只有一个实例。 OK到这里就看完了总结一下： 应用程序创建的时候，会初始化一个空的Fragment，虽然这个Fragment没有布局文件，但是它有一个完整的生命周期，而且生命周期跟它所在的这个Activity同步，所以我们就可以在这个Fragment的生命周期中来管理观察者的生命周期，通过addObserver方法，可以把一个我们自定义的观察者注册到Activiy中的一个集合中，当生命周期变化的时候，循环遍历集合，调用观察者相关的状态方法。 一般情况下lifecycle结合着ViewModel和LiveData一块使用。 Lifecycle的最佳实践 保持UI控制器（activities and fragments）尽可能的精简，他们中不应该有请求数据的代码，这部分的代码我们最好交给 ViewModel去做，然后通过LiveData来更新视图。 尝试编写数据驱动的UI，当数据改变的时候，UI控制器负责更改视图，或者把用户的操作传递给ViewModel 可以使用Data Binding来让activities and fragments中的代码更少更简洁。 如果UI界面非常复杂，可以尝试写一个presenter类来处理UI逻辑，这样可以使UI组件更容易测试。 避免在ViewModel中引用View或者Activity的上下文，如果ViewModel执行时间过长，会导致View和Activity无法被回收。 Lifecycle的用例 比如位置更新，在程序可见的时候，使用细粒度的位置更新，在程序后台运行时使用粗粒度的位置更新 比如视频的缓冲，我们可以在activity销毁的时候，取消视频的缓冲 启动和停止网络连接，在应用进入后台的时候，断开网络连接 暂停和恢复动画，后台时停止动画，回到前台时在启动动画","link":"/2019/04/20/technology/Android-Jetpack之Lifecycles/"},{"title":"Android Jetpack之Room","text":"Room是在Sqlite数据的一个抽象层，拥有更强大的数据访问能力。 导入依赖：12345678910def room_version = \"2.1.0-alpha06\"implementation \"androidx.room:room-runtime:$room_version\"annotationProcessor \"androidx.room:room-compiler:$room_version\" // kotlin扩展和协程支持implementation \"androidx.room:room-ktx:$room_version\"//RxJava 支持库implementation \"androidx.room:room-rxjava2:$room_version\"// 可选 - Guava 的支持库implementation \"androidx.room:room-guava:$room_version\" 下面开始使用 第一步创建实体类假如我们有一个用户表，每个用户的实体就是表中的一列 12345678910111213@Entitypublic class User { @PrimaryKey @NonNull @ColumnInfo(name = \"id_\") public int id; public String name; public String password; public String school;} @Entity： 代表一个表中的实体，默认类名就是表名，如果不想使用类名作为表名，可以给注解添加表名字段@Entity(tableName = &quot;user_table&quot;) @PrimaryKey： 每个实体都需要自己的主键 @NonNull 表示字段，方法，参数返回值不能为空 @ColumnInfo(name = “lastname”) 如果希望表中字段名跟类中的成员变量名不同，添加此字段指明 第二步创建DAO DAO是数据访问对象，指定SQL查询，并让他与方法调用相关联。 DAO必须是一个接口或者抽象类。 默认情况下，所有的查询都必须在单独的线程中执行 1234567891011121314@Daopublic interface UserDao { @Insert void insert(User user); @Query(\"select * from user\") List&lt;User&gt; getUserList(); @Query(\"delete from user\") void deleteAll(); @Update void updateUsers(User... users);} 创建一个接口UserDao 给它添加注解@Dao，表名它是Room的一个查询类 声明一个插入用户的方法insert，并给它添加注解@Insert，不用提供任何SQL语句 声明一个删除全部的方法，deleteAll()，删除方法没有便捷方法，需要使用@Query注解，并且提供相应的SQL语句delete from user 声明一个getUserList方法来查询所有的用户，这个也没有便捷方法，，需要使用@Query注解，并且提供相应的SQL语句select * from user 第三步添加DatabaseRoom是SQLite数据库之上的数据库层，可以让我们轻松的使用系统原始API：SQLiteOpenHelper123456789101112131415161718@Database(entities = {User.class},version = 1)public abstract class UserRoomDatabase extends RoomDatabase { public abstract UserDao userDao(); public static UserRoomDatabase instance; public static UserRoomDatabase getInstance(Context context){ if(instance == null){ synchronized (UserRoomDatabase.class){ if(instance == null){ instance = Room.databaseBuilder(context.getApplicationContext(),UserRoomDatabase.class ,\"user_database\").build(); } } } return instance; }} 创建一个抽象类继承自RoomDatabase 给他添加一个注解@Database表名它是一个数据库，注解有两个参数第一个是数据库的实体，它是一个数组，可以传多个，当数据库创建的时候，会默认给创建好对应的表，第二个参数是数据库的版本号 定义跟数据库一起使用的相关的DAO类 创建一个UserRoomDatabase的单例，防止同时打开多个数据库的实例 使用Room提供的数据库构建器来创建该实例，第一个参数application，第二个参数当前数据库的实体类，第三个参数数据库的名字 第四步开始使用前面三步主要步骤写完了，现在就可以开始使用了，使用的时候，为了让Activity中代码简洁，创建一个UserRepository类来管理这个数据库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class UserRepository { private UserDao mUserDao; private List&lt;User&gt; allUser; public UserRepository(Application application) { //UserRoomDatabase db = UserRoomDatabase.getInstance(application); //mUserDao = db.userDao(); //allUser = mUserDao.getUserList(); //使用ViweModel可以直接使用上面注释了的 new InitThread(application).start(); } public List&lt;User&gt; getAllUser() { return allUser; } public void deleteAll(){ new DeleteAsyncTask(mUserDao).execute(); } public void update(User user){ new UpdateAsyncTask(mUserDao).execute(user); } public void insert(User user){ new InsertAsyncTask(mUserDao).execute(user); } private class InitThread extends Thread{ Application application; InitThread(Application application){ this.application = application; } @Override public void run() { UserRoomDatabase db = UserRoomDatabase.getInstance(application); mUserDao = db.userDao(); allUser = mUserDao.getUserList(); } } //更新 private static class UpdateAsyncTask extends AsyncTask&lt;User, Void, Void&gt; { private UserDao mAsyncTaskDao; UpdateAsyncTask(UserDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final User... params) { mAsyncTaskDao.updateUsers(params[0]); return null; } } //插入 private static class InsertAsyncTask extends AsyncTask&lt;User, Void, Void&gt; { private UserDao mAsyncTaskDao; InsertAsyncTask(UserDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final User... params) { mAsyncTaskDao.insert(params[0]); return null; } } //删除 private static class DeleteAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; { private UserDao mAsyncTaskDao; DeleteAsyncTask(UserDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(Void... voids) { mAsyncTaskDao.deleteAll(); return null; } }} 这个类的作用就是初始化数据库和响应的DAO类，对外提供插入、查询等方法。 注意：数据库的创建，表的插入和删除操作，Room会强制要求在非UI线程中使用，否则会崩溃。 在Activity中初始化UserRepository之后，就可以进行相关的操作了 使用LiveData和ViewModel当数据变化的时候，LiveData可以观察到数据的变化，可以让我们实时更新UI ViewModel可以更好的保存Activity中的数据，比如屏幕旋转的时候数据不会丢失 ViewModel与Room和LiveData一起工作可以替换以前的loader。ViewModel确保数据在设备配置更改后仍然存在。当数据库发生更改时，Room会通LiveData，而LiveData反过来又用修改后的数据更的UI。 将DAO中的查询更改为下面 12@Query(\"select * from user\") LiveData&lt;List&lt;User&gt;&gt; getUserList(); 然后创建ViewModel1234567891011121314151617181920212223242526public class UserViewModel extends AndroidViewModel { private LiveData&lt;List&lt;User&gt;&gt; mUsers; private UserRepository mRepository; public UserViewModel(Application application) { super(application); mRepository = new UserRepository(application); mUsers = mRepository.getAllUser(); } public LiveData&lt;List&lt;User&gt;&gt; getUsers(){ return mUsers; } public void insertUser(User user){ mRepository.insert(user); } public void deleteAll(){ mRepository.deleteAll(); } public void update(User user){ mRepository.update(user); }} 我们单独使用LiveData的时候，都是使用MutableLiveData，当与Room一块使用的时候只能使用LiveData。 Activity中使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RoomActivity extends AppCompatActivity { List&lt;User&gt; mUsers = new ArrayList&lt;&gt;(); UserRepository mRepository; MyAdapter mAdapter; int index = 0; private UserViewModel mViewModel; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_room);// mRepository = new UserRepository(getApplication());// mUsers = new ArrayList&lt;&gt;(); RecyclerView recyclerView = findViewById(R.id.recycleview); LinearLayoutManager manager = new LinearLayoutManager(this); recyclerView.setLayoutManager(manager); mAdapter = new MyAdapter(mUsers,this); recyclerView.setAdapter(mAdapter); mViewModel = ViewModelProviders.of(this).get(UserViewModel.class); mViewModel.getUsers().observe(this, new Observer&lt;List&lt;User&gt;&gt;() { @Override public void onChanged(List&lt;User&gt; users) { mUsers.clear(); mUsers.addAll(users); mAdapter.notifyDataSetChanged(); } }); } public void insert(View view) { User user = new User(); user.id =index; user.name = \"张三\"+ Math.random()*100; user.school = \"北大\"+ Math.random()*100; user.password = \"123\"+ Math.random()*100;// mRepository.insert(user); mViewModel.insertUser(user); index++; } public void query(View view) {// List&lt;User&gt; allUser = mRepository.getAllUser();// mUsers.addAll(allUser);// mAdapter.notifyDataSetChanged(); } public void deleteAll(View view) { mViewModel.deleteAll(); } public void update(View view) { User user = new User(); user.id =0; user.name = \"张三\"+ Math.random()*100; user.school = \"北大\"+ Math.random()*100; user.password = \"123\"+ Math.random()*100; mViewModel.update(user); }} 数据库升级当数据库中的表或者表中的字段有变化的时候，我们需要升级数据的版本，这个时候，我们不希望现在数据库中的数据丢失 Room提供了相应的类（Migration）来完成数据库的迁移，需要传入一个旧版本和新版本，比如现在在user表中新加一个age字段 在User类中新加一个字段 1public int age; 编写Migration类，编写sql更改数据库 123456private static final Migration MIGRATION_1_2 = new Migration(1, 2) { @Override public void migrate(SupportSQLiteDatabase database) { database.execSQL(\"alter table user add age INTEGER NOT NULL default 0\"); } }; 更改数据库的版本由1变成2 12@Database(entities = {User.class},version = 2,exportSchema = false)public abstract class UserRoomDatabase extends RoomDatabase {} 更改数据库的创建方法 1234instance = Room.databaseBuilder(context.getApplicationContext(),UserRoomDatabase.class ,\"user_database\") .addMigrations(MIGRATION_1_2) .build(); 然后重新运行程序就可以看到age字段已经加到表里了。 addMigrations方法，里面可以接收多个参数，比如现在只是编写了版本1-2的升级方法MIGRATION_1_2，假如我们还有2-3版本的还可以编写一个MIGRATION_2_3，添加到后面。 更新数据库的版本 OK,到这里Room的简单使用就完成啦。下面来看看它的源码吧 前面我们知道数据库的创建是从Room.databaseBuilder(...).build();方法开始，很明显看出来这是通过建造者模式创建出来的。传入一些参数到RoomDatabase.Builder中，最终的创建方法肯定就是在build中。123456789101112131415161718192021222324252627282930 public T build() { ...... if (mFactory == null) { mFactory = new FrameworkSQLiteOpenHelperFactory(); } //数据库配置 DatabaseConfiguration configuration = new DatabaseConfiguration( mContext, mName, mFactory, mMigrationContainer, mCallbacks, mAllowMainThreadQueries, mJournalMode.resolve(mContext), mQueryExecutor, mTransactionExecutor, mMultiInstanceInvalidation, mRequireMigration, mAllowDestructiveMigrationOnDowngrade, mMigrationsNotRequiredFrom); //前面创建的UserRoomDatabase是个抽象类，编译期间会生成对应的实现类UserRoomDatabase_Impl，获取UserRoomDatabase的实现类 T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX); //初始化数据库 db.init(configuration); return db; }} 创建了一个SQLiteOpenHelper的工厂类FrameworkSQLiteOpenHelperFactory1234567public final class FrameworkSQLiteOpenHelperFactory implements SupportSQLiteOpenHelper.Factory { @Override public SupportSQLiteOpenHelper create(SupportSQLiteOpenHelper.Configuration configuration) { return new FrameworkSQLiteOpenHelper( configuration.context, configuration.name, configuration.callback); }} 这个工厂方法可以创建一个FrameworkSQLiteOpenHelper，它是SupportSQLiteOpenHelper接口的实现类。 1234567class FrameworkSQLiteOpenHelper implements SupportSQLiteOpenHelper { private final OpenHelper mDelegate; FrameworkSQLiteOpenHelper(Context context, String name, Callback callback) { mDelegate = createDelegate(context, name, callback); } 可以看到在其构造方法中创建了一个代理类OpenHelper1static class OpenHelper extends SQLiteOpenHelper {......} OpenHelper继承自系统的SQLiteOpenHelper，它用来监听数据库的创建(onCreate)升级(onUpgrade)等操作。然后回调给RoomOpenHelper来处理。 回到build()方法中，将数据库的配置封装到DatabaseConfiguration中，然后获取我们之前写的抽象类UserRoomDatabase的一个实现类，这个实现类是注解器在编译期间自动创建的。 位置在：build-&gt;generated-&gt;source-&gt;apt-&gt;debug-&gt;你的包名中找到。最后初始化数据库。怎么创建的可以去查一下编译时注解的原理。12345678910111213141516171819202122232425262728static &lt;T, C&gt; T getGeneratedImplementation(Class&lt;C&gt; klass, String suffix) { //包名 final String fullPackage = klass.getPackage().getName(); //全名 String name = klass.getCanonicalName(); final String postPackageName = fullPackage.isEmpty() ? name : (name.substring(fullPackage.length() + 1)); //拼成UserRoomDatabase_Impl final String implName = postPackageName.replace('.', '_') + suffix; //noinspection TryWithIdenticalCatches try { //通过反射找到生成的类，然后实例化 @SuppressWarnings(\"unchecked\") final Class&lt;T&gt; aClass = (Class&lt;T&gt;) Class.forName( fullPackage.isEmpty() ? implName : fullPackage + \".\" + implName); return aClass.newInstance(); } catch (ClassNotFoundException e) { throw new RuntimeException(\"cannot find implementation for \" + klass.getCanonicalName() + \". \" + implName + \" does not exist\"); } catch (IllegalAccessException e) { throw new RuntimeException(\"Cannot access the constructor\" + klass.getCanonicalName()); } catch (InstantiationException e) { throw new RuntimeException(\"Failed to create an instance of \" + klass.getCanonicalName()); }} 上面的方法就是根据我们传入的数据库的类名，拼接出Room编译器给自动生成的实现类的名字，然后通过反射找到这个类并实例化返回。 下面看一下这个自动生成的类UserRoomDatabase_Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public final class UserRoomDatabase_Impl extends UserRoomDatabase { private volatile UserDao _userDao; @Override protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration configuration) { final SupportSQLiteOpenHelper.Callback _openCallback = new RoomOpenHelper(configuration, new RoomOpenHelper.Delegate(2) { @Override public void createAllTables(SupportSQLiteDatabase _db) { _db.execSQL(\"CREATE TABLE IF NOT EXISTS `User` (`id_` INTEGER NOT NULL, `name` TEXT, `password` TEXT, `school` TEXT, `age` INTEGER NOT NULL, PRIMARY KEY(`id_`))\"); _db.execSQL(\"CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)\"); _db.execSQL(\"INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, \\\"c59ead1e532b11ea2062c3f5e814a66b\\\")\"); } @Override public void dropAllTables(SupportSQLiteDatabase _db) { _db.execSQL(\"DROP TABLE IF EXISTS `User`\"); } @Override protected void onCreate(SupportSQLiteDatabase _db) { if (mCallbacks != null) { for (int _i = 0, _size = mCallbacks.size(); _i &lt; _size; _i++) { mCallbacks.get(_i).onCreate(_db); } } } @Override public void onOpen(SupportSQLiteDatabase _db) { mDatabase = _db; internalInitInvalidationTracker(_db); if (mCallbacks != null) { for (int _i = 0, _size = mCallbacks.size(); _i &lt; _size; _i++) { mCallbacks.get(_i).onOpen(_db); } } } @Override public void onPreMigrate(SupportSQLiteDatabase _db) { DBUtil.dropFtsSyncTriggers(_db); } @Override public void onPostMigrate(SupportSQLiteDatabase _db) { } @Override protected void validateMigration(SupportSQLiteDatabase _db) { final HashMap&lt;String, TableInfo.Column&gt; _columnsUser = new HashMap&lt;String, TableInfo.Column&gt;(5); _columnsUser.put(\"id_\", new TableInfo.Column(\"id_\", \"INTEGER\", true, 1)); _columnsUser.put(\"name\", new TableInfo.Column(\"name\", \"TEXT\", false, 0)); _columnsUser.put(\"password\", new TableInfo.Column(\"password\", \"TEXT\", false, 0)); _columnsUser.put(\"school\", new TableInfo.Column(\"school\", \"TEXT\", false, 0)); _columnsUser.put(\"age\", new TableInfo.Column(\"age\", \"INTEGER\", true, 0)); final HashSet&lt;TableInfo.ForeignKey&gt; _foreignKeysUser = new HashSet&lt;TableInfo.ForeignKey&gt;(0); final HashSet&lt;TableInfo.Index&gt; _indicesUser = new HashSet&lt;TableInfo.Index&gt;(0); final TableInfo _infoUser = new TableInfo(\"User\", _columnsUser, _foreignKeysUser, _indicesUser); final TableInfo _existingUser = TableInfo.read(_db, \"User\"); if (! _infoUser.equals(_existingUser)) { throw new IllegalStateException(\"Migration didn't properly handle User(com.chs.androiddailytext.jetpack.User).\\n\" + \" Expected:\\n\" + _infoUser + \"\\n\" + \" Found:\\n\" + _existingUser); } } }, \"c59ead1e532b11ea2062c3f5e814a66b\", \"c0809d515e95fc9eec52ad8880ec6aae\"); final SupportSQLiteOpenHelper.Configuration _sqliteConfig = SupportSQLiteOpenHelper.Configuration.builder(configuration.context) .name(configuration.name) .callback(_openCallback) .build(); final SupportSQLiteOpenHelper _helper = configuration.sqliteOpenHelperFactory.create(_sqliteConfig); return _helper; } @Override protected InvalidationTracker createInvalidationTracker() { final HashMap&lt;String, String&gt; _shadowTablesMap = new HashMap&lt;String, String&gt;(0); HashMap&lt;String, Set&lt;String&gt;&gt; _viewTables = new HashMap&lt;String, Set&lt;String&gt;&gt;(0); return new InvalidationTracker(this, _shadowTablesMap, _viewTables, \"User\"); } @Override public void clearAllTables() { super.assertNotMainThread(); final SupportSQLiteDatabase _db = super.getOpenHelper().getWritableDatabase(); try { super.beginTransaction(); _db.execSQL(\"DELETE FROM `User`\"); super.setTransactionSuccessful(); } finally { super.endTransaction(); _db.query(\"PRAGMA wal_checkpoint(FULL)\").close(); if (!_db.inTransaction()) { _db.execSQL(\"VACUUM\"); } } } @Override public UserDao userDao() { if (_userDao != null) { return _userDao; } else { synchronized(this) { if(_userDao == null) { _userDao = new UserDao_Impl(this); } return _userDao; } } }} createOpenHelper方法，创建SupportSQLiteOpenHelper的实现类FrameworkSQLiteOpenHelper，前面我们知道他的构造方法中创建了一个代理类OpenHelper它继承自系统的SQLiteOpenHelper，这个就是我们如果不使用Room，而是自己使用系统提供的类操作数据库的时候需要创建的类，这里Room帮我们创建好了，这个方法是在前面build()方法中的 db.init(configuration)中调用的 createOpenHelper方法中创建了SupportSQLiteOpenHelper.Callback这个回调，并实现它的回调方法从代码中看到它是一个RoomOpenHelper。 OpenHelper监听系统回调，监听到之后会回调RoomOpenHelper的相关方法，RoomOpenHelper又会回调UserRoomDatabase_Impl中的相关方法。 onCreate（）中Sql语句创建user表和room_master_table表，dropAllTables方法删除数据库，validateMigration方法实现数据库升级 userDao()方法创建UserDao_Impl的实例，这个UserDao_Impl也是注解处理器给我们自动生成的，这里面就是我们定义的UserDao中增删改查的真正实现的地方。 然后在看build()方法中的init方法 1234567891011121314151617public void init(@NonNull DatabaseConfiguration configuration) { mOpenHelper = createOpenHelper(configuration); boolean wal = false; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) { wal = configuration.journalMode == JournalMode.WRITE_AHEAD_LOGGING; mOpenHelper.setWriteAheadLoggingEnabled(wal); } mCallbacks = configuration.callbacks; mQueryExecutor = configuration.queryExecutor; mTransactionExecutor = new TransactionExecutor(configuration.transactionExecutor); mAllowMainThreadQueries = configuration.allowMainThreadQueries; mWriteAheadLoggingEnabled = wal; if (configuration.multiInstanceInvalidation) { mInvalidationTracker.startMultiInstanceInvalidation(configuration.context, configuration.name); } } createOpenHelper(configuration)就是调用了UserRoomDatabase_Impl中的createOpenHelper方法。 mQueryExecutor 和 mTransactionExecutor 是两个线程池，查询和事物的线程池。这就是为啥前面例子中我们的查询方法不用自己放到非UI线程中执行，而插入和更新方法却需要自己创建子线程执行了。 下面来看看升级的方法，前面我们知道OpenHelper这个代理类继承了系统的SQLiteOpenHelper，会监听系统的数据库相关事件，我们找到它中的升级方法1234public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) { mMigrated = true; mCallback.onUpgrade(getWrappedDb(sqLiteDatabase), oldVersion, newVersion); } mCallback就是我们在UserRoomDatabase_Impl中创建的RoomOpenHelper一路传进来的12345678910111213141516171819202122232425262728293031323334353637public void onUpgrade(SupportSQLiteDatabase db, int oldVersion, int newVersion) { boolean migrated = false; if (mConfiguration != null) { //根据版本号查找对应的migrations List&lt;Migration&gt; migrations = mConfiguration.migrationContainer.findMigrationPath( oldVersion, newVersion); if (migrations != null) { //迁移之前的初始化工作 mDelegate.onPreMigrate(db); //循环执行我们写的sql for (Migration migration : migrations) { migration.migrate(db); } //验证升级结果 mDelegate.validateMigration(db); mDelegate.onPostMigrate(db); updateIdentity(db); migrated = true; } } //如果没有执行我们的sql if (!migrated) { if (mConfiguration != null &amp;&amp; !mConfiguration.isMigrationRequired(oldVersion, newVersion)) { //删除清空表 mDelegate.dropAllTables(db); mDelegate.createAllTables(db); } else { throw new IllegalStateException(\"A migration from \" + oldVersion + \" to \" + newVersion + \" was required but not found. Please provide the \" + \"necessary Migration path via \" + \"RoomDatabase.Builder.addMigration(Migration ...) or allow for \" + \"destructive migrations via one of the \" + \"RoomDatabase.Builder.fallbackToDestructiveMigration* methods.\"); } } } 这里面的mDelegate就是我们在UserRoomDatabase_Impl中new出来的RoomOpenHelper.Delegate，并实现了它里面的方法，所以上面代码中调用Delegate最终都会到达UserRoomDatabase_Impl中的相关方法执行。 findMigrationPath方法根据版本号找到相应的migrations，前面使用中我们知道migrations中封装了我们升级数据库的sql语句。 循环执行我们的migrations，执行我们写的升级的sql语句，执行完之后验证是否升级成功。 如果没有执行找到需要执行的migrations ，并且mConfiguration.isMigrationRequired(oldVersion, newVersion)为false，就会清空数据库中所有的表。1234567public boolean isMigrationRequired(int fromVersion, int toVersion) { final boolean isDowngrade = fromVersion &gt; toVersion; if (isDowngrade &amp;&amp; allowDestructiveMigrationOnDowngrade) { return false; } ......} 可以看到当旧版本大于新版本的时候或者allowDestructiveMigrationOnDowngrade为true的时候返回false。 allowDestructiveMigrationOnDowngrade这个标志位可以在数据库创建的时候指定1234Room.databaseBuilder(context.getApplicationContext(),UserRoomDatabase.class ,\"user_database\") .fallbackToDestructiveMigration() .build(); 加上它之后升级就会清空数据库中以前的数据。一般情况下我们都是希望保留数据的，所以需要些我们自己的Migration类，定义升级的sql。 OK结束","link":"/2019/04/20/technology/Android-Jetpack之Room/"},{"title":"Android Tinker集成采坑","text":"Android Tinker集成采坑 官方文档 https://github.com/Tencent/tinker/wiki 官方demo怎么配置都可以从demo中找到 https://github.com/Tencent/tinker/tree/dev/tinker-sample-android Tinker提供了两种接入方式，命令行接入和gradle接入。正常的项目中都基本都使用gradle，一次配置好以后就可以很方便的使用了，所以本次只使用gradle方式。 本文基于1.9.13版本，因为有好几个地方都需要用到版本信息，所以将它放在gradle.properties文件中方便版本的管理1TINKER_VERSION=1.9.13 在总工程的的build.gradle配置tinker的classpath,因为tinker定义了一些自己的gradle脚本，后面在配置参数的时候会用到。1234classpath(&quot;com.tencent.tinker:tinker-patch-gradle-plugin:${TINKER_VERSION}&quot;) { changing = TINKER_VERSION?.endsWith(&quot;-SNAPSHOT&quot;) exclude group: &apos;com.android.tools.build&apos;, module: &apos;gradle&apos; } 然后在app的gradle文件中配置核心库和谷歌的分包库，现在的应用功能都很多所以体积很大一般都会用到multidex123456789//核心sdk库api(&quot;com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}&quot;) { changing = true }implementation(&quot;com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}&quot;) { changing = true }//注解编译器，生成application的时候用annotationProcessor(&quot;com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}&quot;) { changing = true }compileOnly(&quot;com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}&quot;) { changing = true }implementation &quot;com.android.support:multidex:1.0.3&quot; 先配置app的gradle文件中android这个标签下的内容12345678910111213141516171819202122232425262728293031323334 //配置签名，这里使用demo中的签名文件，真实项目中替换成自己的 signingConfigs { release { try { storeFile file(\"./keystore/release.keystore\") storePassword \"testres\" keyAlias \"testres\" keyPassword \"testres\" } catch (ex) { throw new InvalidUserDataException(ex.toString()) } } debug { storeFile file(\"./keystore/debug.keystore\") } }// 支持大工程模式 dexOptions { jumboMode = true }//release包开始混淆 buildTypes { release { minifyEnabled true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-android.txt'), project.file('proguard-rules.pro') } debug { debuggable true minifyEnabled false signingConfig signingConfigs.debug } } 然后开始配置tinker的参数，官方指南上gradle参数详解官方指南上有参数的详解，建议都看一遍，更容易知道参数的作用和应该怎么配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301def bakPath = file(\"${buildDir}/bakApk/\")ext { //是否启用tinker tinkerEnabled = true//每次打包完都需要更改下面的三个路径，如果支持多渠道打包，下面第四个参数也需要修改 //old apk 的路径 tinkerOldApkPath = \"${bakPath}/app-release-0508-10-52-50.apk\" //old apk 混淆 mapping 文件的路径 tinkerApplyMappingPath = \"${bakPath}/app-release-0508-10-52-50-mapping.txt\" //old apk R文件的路径 tinkerApplyResourcePath = \"${bakPath}/app-release-0508-10-52-50-R.txt\" //多渠道打包的路径 tinkerBuildFlavorDirectory = \"${bakPath}/app-1018-17-32-47\"}static def gitSha() {// 每次打包的时候版本要一致，官方demo的是git的版本，这里使用versionName String gitRev = \"1.0\" return gitRev}def getOldApkPath() { return hasProperty(\"OLD_APK\") ? OLD_APK : ext.tinkerOldApkPath}def getApplyMappingPath() { return hasProperty(\"APPLY_MAPPING\") ? APPLY_MAPPING : ext.tinkerApplyMappingPath}def getApplyResourceMappingPath() { return hasProperty(\"APPLY_RESOURCE\") ? APPLY_RESOURCE : ext.tinkerApplyResourcePath}def getTinkerIdValue() { return hasProperty(\"TINKER_ID\") ? TINKER_ID : gitSha()}def buildWithTinker() { return hasProperty(\"TINKER_ENABLE\") ? Boolean.parseBoolean(TINKER_ENABLE) : ext.tinkerEnabled}def getTinkerBuildFlavorDirectory() { return ext.tinkerBuildFlavorDirectory}//判断是否启用tinkerif (buildWithTinker()) { apply plugin: 'com.tencent.tinker.patch' tinkerPatch { /** * old apk 的路径 */ oldApk = getOldApkPath() /** * 在产生patch的时候是否忽略tinker的警告，最好不忽略 * case 1: minSdkVersion小于14，但是dexMode的值为\"raw\" * case 2: 新编译的安装包出现新增的四大组件(Activity, BroadcastReceiver...)； * case 3: 定义在dex.loader用于加载补丁的类不在main dex中; * case 4: 定义在dex.loader用于加载补丁的类出现修改； * case 5: resources.arsc改变，但没有使用applyResourceMapping编译 */ ignoreWarning = false /** * 是否启用签名，一般强制使用 */ useSign = true /** * 是否启用tinker */ tinkerEnable = buildWithTinker() /** * Warning, applyMapping will affect the normal android build! */ buildConfig { /** * 指定old apk 混淆时的打包文件 */ applyMapping = getApplyMappingPath() /** * 指定old apk 的资源文件 */ applyResourceMapping = getApplyResourceMappingPath() /** * 每个patch文件的唯一标识符 */ tinkerId = getTinkerIdValue() /** * 如果我们有多个dex,编译补丁时可能会由于类的移动导致变更增多。若打开keepDexApply模式，补丁包将根据基准包的类分布来编译。 */ keepDexApply = false /** * 是否使用加固模式，仅仅将变更的类合成补丁。注意，这种模式仅仅可以用于加固应用中。 */ isProtectedApp = false /** * 是否支持新增非export的Activity */ supportHotplugComponent = false } dex { /** * 只能是'raw'或者'jar'。 * 对于'raw'模式，我们将会保持输入dex的格式。 * 对于'jar'模式，我们将会把输入dex重新压缩封装到jar。如果你的minSdkVersion小于14，你必须选择‘jar’模式， * 而且它更省存储空间，但是验证md5时比'raw'模式耗时。默认我们并不会去校验md5,一般情况下选择jar模式即可。 */ dexMode = \"jar\" /** * 需要处理dex路径，支持*、?通配符，必须使用'/'分割。路径是相对安装包的，例如assets/... */ pattern = [\"classes*.dex\", \"assets/secondary-dex-?.jar\"] /** *这一项非常重要，它定义了哪些类在加载补丁包的时候会用到。 * 这些类是通过Tinker无法修改的类，也是一定要放在main dex的类。 * 这里需要定义的类有： * 1. 你自己定义的Application类； * 2. Tinker库中用于加载补丁包的部分类，即com.tencent.tinker.loader.*； * 3. 如果你自定义了TinkerLoader，需要将它以及它引用的所有类也加入loader中； * 4. 其他一些你不希望被更改的类，例如Sample中的BaseBuildInfo类。 * 这里需要注意的是，这些类的直接引用类也需要加入到loader中。或者你需要将这个类变成非preverify。 * 5. 使用1.7.6版本之后的gradle版本，参数1、2会自动填写。若使用newApk或者命令行版本编译，1、2依然需要手动填写 */ loader = [ //use sample, let BaseBuildInfo unchangeable with tinker// \"com.hsm.tinkertest.BuildInfo\" ] } //lib相关的配置项 lib { /** * 需要处理lib路径，支持*、?通配符，必须使用'/'分割。与dex.pattern一致, 路径是相对安装包的，例如assets/... */ pattern = [\"lib/*/*.so\"] } //res相关的配置项 res { /** * 需要处理res路径，支持*、?通配符，必须使用'/'分割。与dex.pattern一致, 路径是相对安装包的， * 例如assets/...，务必注意的是，只有满足pattern的资源才会放到合成后的资源包。 */ pattern = [\"res/*\", \"assets/*\", \"resources.arsc\", \"AndroidManifest.xml\"] /** * 若满足ignoreChange的pattern，在编译时会忽略该文件的新增、删除与修改 */ ignoreChange = [\"assets/sample_meta.txt\"] /** * 对于修改的资源，如果大于largeModSize，我们将使用bsdiff算法。这可以降低补丁包的大小， * 但是会增加合成时的复杂度。默认大小为100kb */ largeModSize = 100 } //用于生成补丁包中的'package_meta.txt'文件 packageConfig { /** * configField(\"key\", \"value\"), 默认我们自动从基准安装包与新安装包的Manifest中读取tinkerId,并自动写入configField。在这里， * 你可以定义其他的信息， 在运行时可以通过TinkerLoadResult.getPackageConfigByName得到相应的数值。 * 但是建议直接通过修改代码来实现，例如BuildConfig。 */ configField(\"patchMessage\", \"tinker is sample to use\") configField(\"platform\", \"all\") /** * patch version via packageConfig */ configField(\"patchVersion\", \"1.0\") } /** * 7zip路径配置项，执行前提是useSign为true */ sevenZip { /** * 将自动根据机器属性获得对应的7za运行文件 */ zipArtifact = \"com.tencent.mm:SevenZip:1.1.10\" /** * optional，default '7za' * you can specify the 7za path yourself, it will overwrite the zipArtifact value */// path = \"/usr/local/bin/7za\" } } List&lt;String&gt; flavors = new ArrayList&lt;&gt;(); project.android.productFlavors.each { flavor -&gt; flavors.add(flavor.name) } //是否配置了多渠道 boolean hasFlavors = flavors.size() &gt; 0 def date = new Date().format(\"MMdd-HH-mm-ss\") /** * old apk复制到指定目录 */ android.applicationVariants.all { variant -&gt; /** * task type, you want to bak */ def taskName = variant.name tasks.all { if (\"assemble${taskName.capitalize()}\".equalsIgnoreCase(it.name)) { it.doLast { copy { def fileNamePrefix = \"${project.name}-${variant.baseName}\" def newFileNamePrefix = hasFlavors ? \"${fileNamePrefix}\" : \"${fileNamePrefix}-${date}\" def destPath = hasFlavors ? file(\"${bakPath}/${project.name}-${date}/${variant.flavorName}\") : bakPath from variant.outputs.first().outputFile into destPath rename { String fileName -&gt; fileName.replace(\"${fileNamePrefix}.apk\", \"${newFileNamePrefix}.apk\") } from \"${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt\" into destPath rename { String fileName -&gt; fileName.replace(\"mapping.txt\", \"${newFileNamePrefix}-mapping.txt\") } from \"${buildDir}/intermediates/symbols/${variant.dirName}/R.txt\" into destPath rename { String fileName -&gt; fileName.replace(\"R.txt\", \"${newFileNamePrefix}-R.txt\") } } } } } } //多渠道 project.afterEvaluate { //sample use for build all flavor for one time if (hasFlavors) { task(tinkerPatchAllFlavorRelease) { group = 'tinker' def originOldPath = getTinkerBuildFlavorDirectory() for (String flavor : flavors) { def tinkerTask = tasks.getByName(\"tinkerPatch${flavor.capitalize()}Release\") dependsOn tinkerTask def preAssembleTask = tasks.getByName(\"process${flavor.capitalize()}ReleaseManifest\") preAssembleTask.doFirst { String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15) project.tinkerPatch.oldApk = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk\" project.tinkerPatch.buildConfig.applyMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt\" project.tinkerPatch.buildConfig.applyResourceMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt\" } } } task(tinkerPatchAllFlavorDebug) { group = 'tinker' def originOldPath = getTinkerBuildFlavorDirectory() for (String flavor : flavors) { def tinkerTask = tasks.getByName(\"tinkerPatch${flavor.capitalize()}Debug\") dependsOn tinkerTask def preAssembleTask = tasks.getByName(\"process${flavor.capitalize()}DebugManifest\") preAssembleTask.doFirst { String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13) project.tinkerPatch.oldApk = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk\" project.tinkerPatch.buildConfig.applyMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt\" project.tinkerPatch.buildConfig.applyResourceMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt\" } } } } }}task sortPublicTxt() { doLast { File originalFile = project.file(\"public.txt\") File sortedFile = project.file(\"public_sort.txt\") List&lt;String&gt; sortedLines = new ArrayList&lt;&gt;() originalFile.eachLine { sortedLines.add(it) } Collections.sort(sortedLines) sortedFile.delete() sortedLines.each { sortedFile.append(\"${it}\\n\") } }} OK，参数配置完成，下面开始写代码。 先写一个TinkerManager类来管理Tinker的初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TinkerManager { private static final String TAG = \"Tinker.TinkerManager\"; private static ApplicationLike applicationLike; /** * 保证只初始化一次 */ private static boolean isInstalled = false; public static void setTinkerApplicationLike(ApplicationLike appLike) { applicationLike = appLike; } public static ApplicationLike getTinkerApplicationLike() { return applicationLike; } public static void setUpgradeRetryEnable(boolean enable) { UpgradePatchRetry.getInstance(applicationLike.getApplication()).setRetryEnable(enable); } public static void installTinker(ApplicationLike appLike) { if (isInstalled) { TinkerLog.w(TAG, \"install tinker, but has installed, ignore\"); return; } //监听patch文件加载过程中的事件 LoadReporter loadReporter = new DefaultLoadReporter(appLike.getApplication()); //监听patch文件合成过程中的事件 PatchReporter patchReporter = new DefaultPatchReporter(appLike.getApplication()); //监听patch文件接收到之后可以做一些校验 PatchListener patchListener = new CustomPatchListener(appLike.getApplication()); //升级策略 AbstractPatch upgradePatchProcessor = new UpgradePatch(); TinkerInstaller.install(appLike, loadReporter, patchReporter, patchListener, CustomResultService.class, upgradePatchProcessor); isInstalled = true; }} 这里面有几个类需要注意 LoadReporter类：监听patch文件加载过程中的事件，这里使用DefaultLoadReporter，如果有需要可以继承DefaultLoadReporter写自己的业务逻辑 PatchReporter ：监听patch文件合成过程中的事件，这里使用DefaultPatchReporter，如果哟需要可以继承DefaultPatchReporter写自己的业务逻辑 PatchListener ：监听patch文件接收到之后可以做一些校验，这个一般用的比较多，为了保证我们下载的patch包的没有被篡改，可以重写PatchListener，写一些自己的校验 AbstractPatch ：升级策略，一般不用修改 CustomResultService：继承自系统的DefaultTinkerResultService，决定在patch安装完以后的后续操作，因为tinker修复完之后需要重启才能生效，tinker默认是加载完patch包之后直接杀死进程。这样可能会不太友好，如果不想直接杀进程可以继承DefaultTinkerResultService类，写我们自己的逻辑。 CustomPatchListener和CustomResultService的样例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class CustomPatchListener extends DefaultPatchListener { private String currentMD5; public void setCurrentMD5(String md5Value) { this.currentMD5 = md5Value; } public CustomPatchListener(Context context) { super(context); } /** * 校验 * @return */ @Override public int patchCheck(String path, String patchMd5) { //做自己的校验 return super.patchCheck(path, patchMd5); }}/** * 决定在patch安装完以后的后续操作，默认实现是杀进程 */public class CustomResultService extends DefaultTinkerResultService { private static final String TAG = \"Tinker.CustomResultService\"; //返回patch文件的结果 @Override public void onPatchResult(final PatchResult result) { if (result == null) { TinkerLog.e(TAG, \"CustomResultService received null result!!!!\"); return; } TinkerLog.i(TAG, \"CustomResultService receive result: %s\", result.toString()); //first, we want to kill the recover process TinkerServiceInternals.killTinkerPatchServiceProcess(getApplicationContext()); Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() { @Override public void run() { if (result.isSuccess) { Toast.makeText(getApplicationContext(), \"patch success, please restart process\", Toast.LENGTH_LONG).show(); } else { Toast.makeText(getApplicationContext(), \"patch fail, please check reason\", Toast.LENGTH_LONG).show(); } } }); // is success and newPatch, it is nice to delete the raw file, and restart at once // for old patch, you can't delete the patch file if (result.isSuccess) { deleteRawPatchFile(new File(result.rawPatchFilePath)); //默认是直接重启体验可能不好，这里只是在后台重启 if (checkIfNeedKill(result)) { if (Utils.isBackground()) { TinkerLog.i(TAG, \"it is in background, just restart process\"); restartProcess(); } else { TinkerLog.i(TAG, \"tinker wait screen to restart process\"); new Utils.ScreenState(getApplicationContext(), new Utils.ScreenState.IOnScreenOff() { @Override public void onScreenOff() { restartProcess(); } }); } } else { TinkerLog.i(TAG, \"I have already install the newly patch version!\"); } } } /** * you can restart your process through service or broadcast */ private void restartProcess() { TinkerLog.i(TAG, \"app is background now, i can kill quietly\"); //you can send service or broadcast intent to restart your process android.os.Process.killProcess(android.os.Process.myPid()); }} 为了使真正的Application实现可以在补丁包中修改，tinker建议Appliction类的所有逻辑移动到ApplicationLike代理类中。 12345678910111213141516171819202122232425262728293031323334353637@DefaultLifeCycle(application = \".SampleTinkerApplication\", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class CustomTinkerLike extends DefaultApplicationLike { CustomTinkerLike mCustomTinkerLike; public CustomTinkerLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) { super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent); } @Override public void onCreate() { super.onCreate(); } @Override public void onBaseContextAttached(Context base) { super.onBaseContextAttached(base); //必须使用multiDex MultiDex.install(base); mCustomTinkerLike = this; TinkerManager.setTinkerApplicationLike(this); //在 installed 之前设置 TinkerManager.setUpgradeRetryEnable(true); //installTinker after load multiDex //or you can put com.tencent.tinker.** to main dex TinkerManager.installTinker(this); Tinker tinker = Tinker.with(getApplication()); } @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) { getApplication().registerActivityLifecycleCallbacks(callback); }} 自定义一个CustomTinkerLike继承自DefaultApplicationLike，以前在我们自定义的Application中初始化的代码都移动到这里的onCreate()方法中。 添加注解DefaultLifeCycle，第一个是application的名字，编译的时候会自动给我们生成一个application类，然后把这个生成的application注册到AndroidManifest.xml中。 最后Activity中定义一个按钮点击加载patch包1234public void load(View view) { TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\"); } 到这里配置和代码就都完成了，下面开始打包，先打基础包 线上的包基本都是release包，前面已经配置了签名，所以这就只打release包。 可以使用命令行输入命令./gradlew assemableRelease，也可以使用studio的快捷操作，快捷操作图片如下 打完包之后，tinker会将outputs/release文件夹下的打包好的文件复制一份到bakApk文件夹中一份，并重命名，这个bakApk文件夹是前面在gradle中配置的。还有混淆的mapping文件和R文件也复制一份重命名放到bakApk文件夹下面。 把打包好的apk装到手机上，然后修改一些代码，开始打补丁包 如图修改gradle中的oldApk的信息。然后调用tinker的命令打包如下图 打包完成之后在outputs文件夹下会多出来一个tinkerPatch文件夹。patch_signed_7zip.apk就死我们需要的patch包了。直接放到前面加载sdk文件的路径，或者从网络下载到该路径，之后调用加载的方法就完成修复了。","link":"/2019/06/02/technology/Android-Tinker集成采坑/"},{"title":"Android事件分发机制","text":"Android事件分发机制 想要了解Android的事件分发机制，首先需要知道事件是从哪里开始的。从之前的一篇文章View是如何被添加到屏幕上的的最后一幅图，可以知道，我们打开一个界面后，界面的层级从顶层开始是 Activity-&gt;PhoneWindow-&gt;DecorView-&gt;… 所以当我们手指点击到屏幕上之后，事件的分发也是在Activity中开始。执行Activity中的dispatchTouchEvent方法那就从这里开始看1234567891011121314public boolean dispatchTouchEvent(MotionEvent ev) { //如果是DOWN事件 if (ev.getAction() == MotionEvent.ACTION_DOWN) { //此方法里面是空的，可以重写此方法 onUserInteraction(); } //如果getWindow().superDispatchTouchEvent(ev)返回true //那么dispatchTouchEvent方法就返回true //反之就执行activity的onTouchEvent方法 if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev);} 首先判断是不是DOWN事件，如果是执行onUserInteraction()，这个方法里面啥也没有，我们可以重写这个方法来实现我们的关于DOWN事件的逻辑。 然后调用getWindow().superDispatchTouchEvent(ev)，如果它返回true，那么dispatchTouchEvent就返回true。如果返回false，就执行activity的onTouchEvent方法。 Activity的onTouchEvent方法很简单，如果一个事件没有被Activity下的任何一个veiw接受就结束返回true，只有点击到Window外面才会返回true，一般情况下都返回false。12345678public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 下面来看看getWindow().superDispatchTouchEvent(ev)这个方法，getWindow()方法返回一个Window对象，它是一个抽象类，只有一个子类那就是PhoneWindow，所以无PhoneWindow中查看superDispatchTouchEvent(ev)方法123public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } mDecor是一个DecorView对象，public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks,DecorView继承自FrameLayout，所以它也是一个ViewGroup它是我们一个页面的最顶级的View。点进DecorView中可以看到123public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } 它直接调用了其父类的dispatchTouchEvent方法，继续跟进就进入到了ViewGroup中的dispatchTouchEvent方法了。 现在我们知道，当我们点击屏幕的时候，事件通过Activity传递到PhoneWindow在传递到ViewGroup中开始真正的分发。下面开始查看ViewGroup中的dispatchTouchEvent方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; //安全验证 if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //开始处理一个DOWN事件 if (actionMasked == MotionEvent.ACTION_DOWN) { //当开始处理一个DOWN事件的时候，清除掉之前的所有的事件和标志位 cancelAndClearTouchTargets(ev); resetTouchState(); } //定义一个boolean类型的变量记录是否拦截事件 final boolean intercepted; //如果是DOWN事件并且当前触摸的对象mFirstTouchTarget不为空 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //disallowIntercept可以拦截除了Down事件以外的事件，因为前面的DOWN中清空了所有标志位 //FLAG_DISALLOW_INTERCEPT可以通过requestDisallowInterceptTouchEvent方法来更改。一般是子view调用这个方法。 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { //onInterceptTouchEvent默认返回false，不拦截事件 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { //没有触摸目标或者不是DOWN事件，说明拦截 intercepted = true; } // 如果拦截了，就进行正常的事件分发 // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // 检查是否取消 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; //定义一个新的触摸对象 TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //如果没取消，并且不拦截事件 if (!canceled &amp;&amp; !intercepted) { View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; //清理指针id防止不同步 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; //如果新的触摸对象为空并且子view个数大于0 if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); //找到一个可以接收事件的子节点 // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //倒叙遍历子view for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); //如果view是可获取焦点的 if (childWithAccessibilityFocus != null) { //当前view不可获取焦点 if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //如果view是不可见状态或者在执行动画，或者触摸范围不是在view的范围之内，就跳出循环继续循环下面的 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } //找到当前触摸的view newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { //子view在触摸范围内，在给它一个标志位 newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //dispatchTransformedTouchEvent分发事件，如果child不为null,就调用child的dispatchTouchEvent方法， //child为null就调用父类的dispatchTouchEvent方法。 //返回值就是子veiw是否处理事件 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //addTouchTarget方法给mFirstTouchTarget赋值，addTouchTarget指向当前的子view。 //所以如果所有子view都不消耗事件，mFirstTouchTarget就为null newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // mFirstTouchTarget == null表示没有子veiw消耗事件 if (mFirstTouchTarget == null) { // 就把它当成一个普通的veiw来执行dispatchTransformedTouchEvent方法 //第三个参数传null，进去后会调用父类的dispatchTouchEvent方法， //最终调用onTouchEvent方法来处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; //如果DOWN事件处理完毕 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; 除了DOWN事件的其余事件分发给子view处理 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 上面就是ViewGroup的事件分发的流程，重要部分都做了注释，总结一下就是，dispatchTouchEvent方法中，onInterceptTouchEvent方法是否拦截事件，默认不拦截，想要拦截我们需要重写此方法。如果拦截就通过dispatchTransformedTouchEvent方法调用自身的onTouchvent()方法，否则就还是通过dispatchTransformedTouchEvent方法调用子view的dispatchTouchEvent方法。如果子view还是ViewGroup，那么重复上面的调用流程，如果子view是View，那么执行View的dispatchTouchEvent方法。下面去看一下View的dispatchTouchEvent方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) { //焦点的判断 if (event.isTargetAccessibilityFocus()) { // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) { return false; } // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); } boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); //5.0以后的嵌套滑动 if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture stopNestedScroll(); } //安全判断 if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //我们是否设置了mOnTouchListener，如果设置了执行它的onTouch方法 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } //执行onTouchEvent方法。到这里我们知道没如果我们设置了一个view的 //mOnTouchListener方法，那么先执行它的onTouch方法，返回false才执行onTouchEvent if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result; } View的dispatchTouchEvent方法就简单多了，首先判断我们有没有设置OnTouchListener方法，如果设置了就执行它的Touch方法，只有Touch方法返回false的时候，才会继续去执行View的onTouchEvent方法。所以我们知道OnTouchListener的优先级高于onTouchEvent。 OK事件分发看完了，下面去View的onTouchEvent看一下事件的处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //是否是可点击的 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //如果一个vew设置了点击事件或者长按事件，即使它是DISABLED的， //也会消费这个事件，只是不响应。也就是这里直接返回true，但是下面的代码都不执行了。 return clickable; } //如果view设置了代理执行下面的方法 if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //如果是可点击的，就开始处理ACTION_UP，ACTION_DOWN，ACTION_CANCEL，ACTION_MOVE事件。 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // 按钮在我们之前就被释放了 // 按下显示。让它显示被压的 // 现在状态(在调度单击之前)以确保用户可以看到它。 setPressed(true, x, y); } //如果没有处理长按事件或者长按事件返回了false //mHasPerformedLongPress在DOWN的时候置为false,在DOWN中 //监测是否有长按事件，如果有长按事件mHasPerformedLongPress会置为true if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // 如果没有长按事件，移除掉长按的回调 removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { //使用Runnable来执行一个点击事件，而不是直接执行 if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } //是否处理长按事件 mHasPerformedLongPress = false; if (!clickable) { //监测长按事件 checkForLongClick(0, x, y); break; } if (performButtonActionOnTouchDown(event)) { break; } // 是否在一个滚动容器中 boolean isInScrollingContainer = isInScrollingContainer(); // 如果是在容器中，发送一个100毫秒的延时post //在其run方法中监测长按事件 if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // 如果不在容器中，直接检查长按事件 //长按事件的监测，发送一个500毫秒的延时post， //在run方法中如果检测到是长按就给上面的mHasPerformedLongPress标志位赋值为true setPressed(true, x, y); checkForLongClick(0, x, y); } break; case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; } break; } return true; } return false; } onTouchEvent方法中，只要CLICKABLE和LONG_CLICKABLE有一个为true就消费这个事件，在DOWN方法中处理长按事件，在UP方法中处理点击事件。LONG_CLICKABLE默认为false,CLICKABLE的值跟具体的view有关，比如Button默认是true,TextView默认是false。通过setClickable和setLongClickable可以改变这两个值。setOnClickListener和setOnLongClickListener会把这两个值设置为true。 OK，View的事件分发的源码查看完毕，看一下流程图 总结一下： 一个事件序列是从手指按下屏幕(ACTION_DOWN)开始，到手指离开屏幕(ACTION_UP)结束，中间有一系列的(ACTION_MOVE)事件，非人为的结束事件会走到ACTION_CANCEL中 正常情况下一个事件序列只能由一个View拦截消耗，因为某一个View一旦决定拦截事件，那么这个事件就只能由它来处理。并且它的onInterceptTouchEvent方法不会在被调用。 一旦一个View开始处理事件，如果它不消耗ACTION_DOWN事件，也就是onTouchEvent返回了false，那么同一个事件序列中的其他事件都不会再交给他处理，并且把事件重新交给它的父容器来处理。父容器的onTouchEvent方法会被调用。 事件的分发过程是由外到内的，事件总是先传递到父容器，在由父容器分发给子View,子View可以通过requestDisallowInterceptTouchEvent方法来干预父容器的执行，ACTION_DOWN事件除外，因为它会在ACTION_DOWN事件中清空标志位。 ViewGroup中的onInterceptTouchEvent方法默认返回false，所有ViewGroup默认不拦截任何事件。而View中没有onInterceptTouchEvent方法，一旦有事件传递给它，它的onTouchEvent方法就会被调用。 View的onTouchEvent方法默认返回true，也就是默认处理事件，除非它是不可点击的(clickable和longClickable都为false)。LONG_CLICKABLE默认为false,CLICKABLE的值跟具体的view有关，比如Button默认是true,TextView默认是false。通过setClickable和setLongClickable可以改变这两个值。setOnClickListener和setOnLongClickListener会把这两个值设置为true。 View的enable属性不会影响onTouchEvent的默认返回值，即使它是enable状态，clickable和longClickable只要有一个为true，那么它的onTouchEvent就返回true。 onClick会响应的前提是，View是可点击的，并且收到了ACTION_DOWN和ACTION_UP事件，当长按事件返回true的时候，onClick是不会响应的。 onLongClick是在ACTION_DOWN中判断的，想要执行长按事件，longClickable需要为true。","link":"/2019/03/31/technology/Android事件分发机制/"},{"title":"C++基础知识","text":"C++基础知识 Hello World从hello wrld开始 需要导入iostream这个头文件 c++中打印使用cout关键字。不过使用的时候需要加上命名空间std。每次都加std太麻烦，可以在外面声明一个全局的using namespace std 命名空间相当于java中的包，主要为了防止重名 123456789101112#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;void main() { //没声明之前 //std::cout &lt;&lt; \"hello world\" &lt;&lt; std::endl; //声明之后 cout &lt;&lt; \"hello world\" &lt;&lt; endl; system(\"pause\");} 自定义命名空间123456789101112131415161718192021222324252627namespace NSP_A { int a = 1; struct student { int age; char *name; };}namespace NSP_B { int a = 2; //命名空间嵌套 namespace NSP_C { int c = 90; }}void main() { cout &lt;&lt; NSP_A::a &lt;&lt; endl; cout &lt;&lt; NSP_B::a &lt;&lt; endl; cout &lt;&lt; NSP_B::NSP_C::c &lt;&lt; endl; //使用命名空间中的结构体 using NSP_A::student; student t; t.age = 20; cout &lt;&lt; t.age &lt;&lt; endl; system(\"pause\");} C中没有布尔类型，C++中有了布尔类型，使用bool修饰。bool类型在内存中占一个字节。 C++中也有跟java一样的三目运算，不过C++中的三目运算运算完之后可以直接赋值，java中不可以。1234567891011121314151617int main() { bool success = true; if (success) { cout &lt;&lt; \"成功\" &lt;&lt; endl; cout &lt;&lt; sizeof(bool) &lt;&lt; endl; } else { cout &lt;&lt; \"失败\" &lt;&lt; endl; } //三目运算，最后可以直接复制 int a = 10, b = 20; ((a &gt; b) ? a : b) = 30; cout &lt;&lt; b &lt;&lt; endl; system(\"pause\");} C++中的引用。使用&amp;符号修饰。 123456int main() { int a = 20; int &amp;b = a; cout &lt;&lt; b &lt;&lt; endl; system(\"pause\");} 上面的代码中，b是a的引用。相当于a的一个别名。它跟指针不同，指针是指向变量的地址，引用只是变量的一个别名。 引用和指针的比较： 引用能干的事情，指针都能干，不过引用写起来别指针方便。引用可以直接操作变量，而指针需要在前面加个* 引用必须要有值不能为空。比如我们向一个函数传递一个引用参数，如果为空的话，编译期间就会报错，而如果是传递指针，指针可以为空，编译期间不报错，运行时就会报错了。这样来看使用引用更好。 12345678910111213141516171819202122232425//指针值交换void swap_1(int *a, int *b) { int c = 0; c = *a; *a = *b; *b = c;}//引用值交换void swap_2(int &amp;a, int &amp;b) { int c = 0; c = a; a = b; b = c;}void main() { int x = 10; int y = 20; printf(\"%d,%d\\n\", x, y); //swap_1(&amp;x, &amp;y); swap_2(x, y); printf(\"%d,%d\\n\", x, y); system(\"pause\");} 引用主要用到的地方 作为函数的参数或者返回值 123456789101112131415161718192021struct Teacher{ char* name; int age;};//引用作为参数void myprint(Teacher &amp;t){ cout &lt;&lt; t.name &lt;&lt; \",\" &lt;&lt; t.age &lt;&lt; endl; t.age = 21;}//指针作为参数void myprint2(Teacher *t){ //(*t).name }void main(){ Teacher t; t.name = \"Jason\"; t.age = 20; myprint(t); myprint2(&amp;t); system(\"pause\");} 拿指针的引用来代替二级指针 123456789101112131415161718192021struct Teacher { char* name; int age;};//使用二级指针void getTeacher(Teacher **p) { Teacher *tmp = (Teacher*)malloc(sizeof(Teacher)); tmp-&gt;age = 20; *p = tmp;}//使用引用void getTeacher(Teacher* &amp;p) { p = (Teacher*)malloc(sizeof(Teacher)); p-&gt;age = 20;}void main() { Teacher *t = NULL; getTeacher(&amp;t); system(\"pause\");} 指针常量和常量指针 指针常量：就是不改变地址，但是可以改变它所指向的内容 常量指针：就是指向一个常量的指针，这个常量不可以被修改 123456789101112void main() { //指针常量 int a = 2, b = 3; int *const p1 = &amp;a; //p1 = &amp;b; 是错误的地址不能改变 *p1 = 4; //常量指针 const int *p2 = &amp;a; p2 = &amp;b; //*p2 = 9; 是错误的，值不能改变} 类123456789101112131415161718192021222324252627282930313233343536373839class teacher {public: //构造函数，相当于activity中的onCreate teacher(); //析构函数,相当于activity中的onDestory ~teacher();private: int age; public: void setage(int age){ this-&gt;age = 20; } int getage() { return age; }};//无参构造函数teacher::teacher(){ cout &lt;&lt; \"构造函数\" &lt;&lt; endl;}//有参构造函数，有参构造函数会覆盖默认的构造函数teacher::teacher(char*name,int age){ cout &lt;&lt; \"构造函数\" &lt;&lt; endl;}teacher::~teacher(){ cout &lt;&lt; \"析构函数\" &lt;&lt; endl;}int main() { { teacher t; t.setage(20); cout &lt;&lt; t.getage() &lt;&lt; endl; } system(\"pause\");} 除了构造函数，析构函数，C++中还有拷贝构造函数。 123456789101112131415161718class Teacher{private: char *name; int age;public: Teacher(char *name, int age){ this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; \"有参构造函数\" &lt;&lt; endl; } //拷贝构造函数（值拷贝） //默认拷贝构造函数，就是值拷贝 Teacher(const Teacher &amp;obj){ this-&gt;name = obj.name; this-&gt;age = obj.age; cout &lt;&lt; \"拷贝构造函数\" &lt;&lt; endl; }}; 上面代码中的拷贝构造函数就是默认的拷贝构造函数，不写它也会存在。 默认的拷贝构造函数拷贝的是指。这样有时候会有问题，比如下面，将t2赋值给t2，他俩都指向同一块内存区域，当t1调用了它的析构函数释放了内存之后，t2在释放内存就会出错。这种称为浅拷贝1234567891011121314151617181920212223242526272829303132class Teacher{private: char *name; int age;public: Teacher(char *name, int age){ this-&gt;name = (char*)malloc(100); strcpy(this-&gt;name,name); this-&gt;age = age; cout &lt;&lt; \"有参构造函数\" &lt;&lt; endl; } ~Teacher(){ cout &lt;&lt; \"析构\" &lt;&lt; endl; //释放内存 free(this-&gt;name); } void myprint(){ cout &lt;&lt; name &lt;&lt; \",\" &lt;&lt; age &lt;&lt; endl; }};void func(){ Teacher t1(\"rose\", 20); Teacher t2 = t1; t2.myprint();}void main(){ func(); system(\"pause\");} 为了避免上面的问题，我们可以复写默认的拷贝构造函数，不拷贝值而是重新申请内存拷贝内容。12345678910111213141516171819202122232425262728293031323334353637383940class Teacher{private: char *name; int age;public: Teacher(char *name, int age){ int len = strlen(name); this-&gt;name = (char*)malloc(len+1); strcpy(this-&gt;name, name); this-&gt;age = age; cout &lt;&lt; \"有参构造函数\" &lt;&lt; endl; } ~Teacher(){ cout &lt;&lt; \"析构\" &lt;&lt; endl; //释放内存 free(this-&gt;name); } //深拷贝 Teacher(const Teacher &amp;obj){ //复制name属性 int len = strlen(obj.name); this-&gt;name = (char*)malloc(len+1); strcpy(this-&gt;name,obj.name); this-&gt;age = obj.age; } void myprint(){ cout &lt;&lt; name &lt;&lt; \",\" &lt;&lt; age &lt;&lt; endl; }};void func(){ Teacher t1(\"rose\", 20); Teacher t2 = t1; t2.myprint();}void main(){ func(); system(\"pause\");} C++可以和C混编，所以C++中也可以使用结构体，虽然跟C中一样也叫struct，不过对C中的struct做了一些扩展。1234567891011121314151617181920struct teacher {private: int age;public: void setAge(int age) { this-&gt;age = age; } int getAge() { return age; }};int main() { { struct teacher t; t.setAge(20); cout &lt;&lt; t.getAge() &lt;&lt; endl; } system(\"pause\");} struct默认为public，class默认为private。 class可以用来声明模板，struct不可以。 前面只是简单的了解了类，C++中写一个类，一般先写一个头文件，在里面声明要写的类，然后写一个C++文件来实现这个类中的方法。最后在main中使用。 头文件：student.h12345678910111213//保证只会被引用一次，防止重复引用#pragma once;class student {public: int age; char* name;public: void setAge(int age); int getAge(); void setName(char* name); char* getName();}; 然后写student.cpp1234567891011121314#include \"student.h\"void student::setAge(int age) { this-&gt;age = age;}int student::getAge() { return this-&gt;age;}void student::setName(char* name) { this-&gt;name = name;}char* student::getName() { return this-&gt;name;} 最后main中调用12345678910int main() { student s; s.age = 20; char name[] = \"cha\"; s.setName(name); cout &lt;&lt; s.getName() &lt;&lt; endl; system(\"pause\");} 构造函数的属性初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Teacher {private: char* name;public: Teacher(char* name) { this-&gt;name = name; cout &lt;&lt; \"Teacher有参构造函数\" &lt;&lt; endl; } ~Teacher() { cout &lt;&lt; \"Teacher析构函数\" &lt;&lt; endl; } char* getName() { return this-&gt;name; }};class Student {private: int id; //属性对象 Teacher t1; Teacher t2;public: Student(int id, char *t1_n, char* t2_n) : t1(t1_n), t2(t2_n) { this-&gt;id = id; cout &lt;&lt; \"Student有参构造函数\" &lt;&lt; endl; } void myprint() { cout &lt;&lt; id &lt;&lt; \",\" &lt;&lt; t1.getName() &lt;&lt; \",\" &lt;&lt; t2.getName() &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"Student析构函数\" &lt;&lt; endl; }};void func() { char name[] = \"cha\"; Student s1(15, name, name); //Student s2(20, name, name); s1.myprint(); //s2.myprint();}void main() { func(); system(\"pause\");} 怎么给Student中的成员变量Teacher中的name属性赋值呢？经过尝试是不能从构造方法中直接赋值的编译不通过，我们可以通过在构造函数后面加上一个冒号从后面赋值比如: t1(t1_n), t2(t2_n) 上面的代码，Student类中有Teacher类这个成员变量，那么他们的构造函数和析构函数式什么时候调用的呢？运行之后结果如下1234567Teacher有参构造函数Teacher有参构造函数Student有参构造函数15,cha,chaStudent析构函数Teacher析构函数Teacher析构函数 可以看到，创建的时候，内部成员先调用构造函数，然后自身在调用。销毁的时候，自身先调用析构函数，内部成员在调用析构函数。 C++动态内存分配 c++中通过new关键字分配内存，通过delete关键字释放内存 c中通过malloc关键字申请内存，通过free关键字释放内存。 c++中也可以通过malloc和free来管理内存，跟第一种的区别是，通过new和delete管理，会执行构造函数和析构函数，而通过malloc和free来管理内存，不会执行构造函数和析构函数。 数组释放的时候，需要使用delete[]。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Teacher {private: const char* name;public: Teacher(const char* name) { this-&gt;name = name; cout &lt;&lt; \"Teacher有参构造函数\" &lt;&lt; endl; } ~Teacher() { cout &lt;&lt; \"Teacher析构函数\" &lt;&lt; endl; } void setName(char* name) { this-&gt;name = name; } const char* getName() { return this-&gt;name; }};void func() { //C++ //会调用构造和析构函数 Teacher *t1 = new Teacher(\"jack\"); cout &lt;&lt; t1-&gt;getName() &lt;&lt; endl; //释放 delete t1; //C //Teacher *t2 = (Teacher*)malloc(sizeof(Teacher)); //t2-&gt;setName(\"jack\"); //free(t2);}void main() { func(); //数组类型 //C //int *p1 = (int*)malloc(sizeof(int) * 10); //p1[0] = 9; //free(p1); //C++ int *p2 = new int[10]; p2[0] = 2; //释放数组 [] delete[] p2; system(\"pause\");} C++中的静态属性和方法静态类型的属性不能再main函数中初始化，应该在全局初始化 访问的时候，可以通过类名直接访问，也可以通过类对象访问12345678910111213141516171819202122232425262728293031323334353637383940class Teacher {public: char* name; static int total;public: Teacher(char* name) { this-&gt;name = name; cout &lt;&lt; \"Teacher有参构造函数\" &lt;&lt; endl; } ~Teacher() { cout &lt;&lt; \"Teacher析构函数\" &lt;&lt; endl; } void setName(char* name) { this-&gt;name = name; } char* getName() { return this-&gt;name; } //静态函数 static void count() { total++; cout &lt;&lt; total &lt;&lt; endl; }};//静态属性初始化赋值int Teacher::total = 9;void main() { Teacher::total++; cout &lt;&lt; Teacher::total &lt;&lt; endl; //直接通过类名访问 Teacher::count(); //也可以通过对象名访问 Teacher t1((char*)\"yuehang\"); t1.count(); system(\"pause\");} C++中类的大小C/C++ 内存分区：栈、堆、全局（静态、全局）、常量区（字符串）、程序代码区 1234567891011121314151617181920212223class A{public: int i; int j; int k; static int m;};class B{public: int i; int j; int k; void myprintf(){ cout &lt;&lt; \"方法\" &lt;&lt; endl; }};void main(){ cout &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; sizeof(B) &lt;&lt; endl; system(\"pause\");} 上面的代码中打印的结果都是12。因为静态变量和函数都是共享的，不包含在类的里面。 既然函数是共享的，那怎么知道是谁调用了它呢，调用的时候传入this，就可以区别开了。this是当前对象的指针。12345678910111213141516171819202122232425262728293031323334353637383940414243class Teacher{private: char* name; int age;public: Teacher(char* name,int age){ this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; \"Teacher有参构造函数\" &lt;&lt; endl; } ~Teacher(){ cout &lt;&lt; \"Teacher析构函数\" &lt;&lt; endl; } //常函数，修饰的是this //既不能改变指针的值，又不能改变指针指向的内容 //const Teacher* const this void myprint() const{ printf(\"%#x\\n\",this); //改变属性的值是不行的 //this-&gt;name = \"yuehang\"; //改变this指针的值也是不行的 //this = (Teacher*)0x00009; cout &lt;&lt; this-&gt;name &lt;&lt; \",\" &lt;&lt; this-&gt;age &lt;&lt; endl; } void myprint2(){ cout &lt;&lt; this-&gt;name &lt;&lt; \",\" &lt;&lt; this-&gt;age &lt;&lt; endl; }};void main(){ Teacher t1((char*)\"jack\",20); const Teacher t2((char*)\"rose\", 18); //常量对象只能调用常量函数，不能调用非常量函数 //t2.myprint2(); //常函数，当前对象不能被修改，防止数据成员被非法访问 printf(\"%#x\\n\", &amp;t1); t1.myprint(); printf(\"%#x\\n\", &amp;t2); t2.myprint(); system(\"pause\");} 上面的代码中 ，使用const来修饰一个函数，这个函数就是一个常量函数。如果一个类中有常量函数，那么这个类的对象不能被修改。可以防止类中的属性被非法访问。 友元函数和友元类友元函数：1234567891011121314151617181920212223242526272829303132class A { //友元函数 friend void modify_i(A *p, int a);private: int i;public: A(int i) { this-&gt;i = i; } void modify_i(int a) { this-&gt;i = a; } void myprint() { cout &lt;&lt; i &lt;&lt; endl; }};//友元函数的实现，在友元函数中可以访问私有的属性void modify_i(A *p, int a) { p-&gt;i = a;}void main() { A* a = new A(10); a-&gt;myprint(); //modify_i(a, 20); //a-&gt;modify_i(20); a-&gt;myprint(); system(\"pause\");} 正常情况下，A中的属性i是私有的，不能被外部修改，如果非得要修改的话，可以通过友元函数。使用friend关键字修饰，比如上面定义一个友元函数modify_i。通过这个函数就可以修改私有属性i了。 友元函数，我们可以在类的内部实现，也可以在外部实现，如上面的代码。 友元类：1234567891011121314151617181920212223class A { //友元类 friend class B;private: int i;public: A(int i) { this-&gt;i = i; } void myprint() { cout &lt;&lt; i &lt;&lt; endl; }};class B {public: //B这个友元类可以访问A类的任何成员 void accessAny() { a.i = 30; }private: A a;}; 友元类也是通过friend关键字修饰。在类A中声明友元类B，那么B中就可以访问和修改A中的私有变量了。 C++中的运算符重载12345678910111213141516171819202122232425262728293031323334class Point {public: int x; int y;public: Point(int x = 0, int y = 0) { this-&gt;x = x; this-&gt;y = y; } //成员函数，运算符重载 Point operator+(Point &amp;p2){ Point tmp(this-&gt;x + p2.x, this-&gt;y + p2.y); return tmp; } void myprint() { cout &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; endl; }};//重载+号Point operator+(Point &amp;p1, Point &amp;p2) { Point tmp(p1.x + p2.x, p1.y + p2.y); return tmp;}void main() { Point p1(10, 20); Point p2(20, 10); Point p3 = p1 + p2; p3.myprint(); system(\"pause\");} 上面的代码中，执行p1+p2让结果p3中的数值是p1和p2中的数值之和。这时候就用到运算符的重载。使用operator关键字来修饰，上面例子中修饰了加号，我们同样可以修饰减号，乘号，除号等。 跟前面的友元函数一样，我们可以把重载函数写在类的里面，也可以写在外面，如上面代码中，取其一即可。 前面运算符重载的代码中，重载的属性x和y都是public（公有的），假如是私有的属性，外面不能访问这时候可以通过友元函数来完成运算符的重载比如:friend Point operator+(Point &amp;p1, Point &amp;p2); 继承多态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Man {public: Man(char* name, int age) { this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; \"Man 构造函数\" &lt;&lt; endl; } ~Man() { cout &lt;&lt; \"Man 析构函数\" &lt;&lt; endl; } void sayHai() { cout &lt;&lt; \"hai\" &lt;&lt; endl; }private: char * name; int age;};class Animal {};class Student : public Man , public Animal {public: Student(char* gride) :Man((char*)\"jack\",18) { cout &lt;&lt; \"Student 构造函数\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"Student 析构函数\" &lt;&lt; endl; } void study() { cout &lt;&lt; \"学习\" &lt;&lt; endl; } void sayHai() { cout &lt;&lt; \"Student hai\" &lt;&lt; endl; }private: char *gride;};void func() { //父类构造函数先调用 //子类的析构函数先调用 Student s((char*)\"chs\");}void main() { func(); Student s((char*)\"100\"); s.sayHai(); s.Man::sayHai(); //1.父类类型的引用或指针 Man *m_p = &amp;s; m_p-&gt;sayHai(); Man &amp;m = s; m.sayHai(); system(\"pause\");} C++中继承使用冒号来修饰，跟java不一样，C++中可以多继承。比如下面代码，Student继承自人和动物。 子类向构造方法传参，java中可以直接使用super关键字，c++中没有，想要传参需要在子类构造方法后面传比如: Man((char*)&quot;jack&quot;,18) 父类的构造函数先执行，子类的析构函数先执行。 如果子类中有跟父类同名的方法，比如上面代码中的sayHai方法，使用子类对象调用的时候调用的是子类的sayHai，如果想调用父类的此函数，需要指定父类显示调用如s.Man::sayHai(); 上面代码可以看到，继承的时候父类前面都加了访问修饰符。一般情况下都使用public，默认是private 基类 继承方式 子类 public public继承 public public protected继承 protected public private继承 private protected public继承 protected protected protected继承 protected protected private继承 private private public继承 子类无权访问 private protected继承 子类无权访问 private private继承 子类无权访问 虚继承和虚函数虚继承： 不同路径继承来的同名成员只有一份拷贝。12345678910111213141516171819202122232425class A{public: char* name;};class A1 : virtual public A{ };class A2 : virtual public A{};class B : public A1, public A2{};void main(){ B b; b.name = \"大海\"; //如果没有 virtual关键字只能 指定父类显示调用 //b.A1::name = \"大海\"; //b.A2::name = \"大海\"; system(\"pause\");} 上面的代码中A1,A2都继承A，B继承了A1和A2，A中有个name属性，那么如果我们调用b.name就会报错，因为系统不知道你是调用A1的还是A2的。这时候只能显示的调用指定调用哪一个的比如b.A1::name = &quot;大海&quot;。 正常情况下我们希望直接使用b.name就能调用，这时候继承的时候使用virtual关键字来修饰A，就可以了，这是虚继承。 虚函数： 相当于java中的多态。使用多态可以增加程序的可扩展性，使用virtual关键字修饰函数 动态多态：程序运行过程中，觉得哪一个函数被调用（重写） 静态多态：重载 能够使用多态的条件： 使用了继承 父类的引用指向子类的实现 子类重写了父类的函数 例子： 定义一个动物基类1234567#pragma onceclass Animal {public: virtual void eat(); virtual void drink();}; 12345678910#include \"Animal.h\"#include &lt;iostream&gt;using namespace std;void Animal::eat(){ cout &lt;&lt; \"吃\" &lt;&lt; endl;}void Animal::drink() { cout &lt;&lt; \"喝\" &lt;&lt; endl;} 定义一个兔子继承动物1234567#pragma once#include \"Animal.h\"class Rabbit : public Animal { virtual void eat(); virtual void drink();}; 12345678910#include \"Rabbit.h\"#include &lt;iostream&gt;using namespace std;void Rabbit::eat(){ cout &lt;&lt; \"兔子吃\" &lt;&lt;endl;}void Rabbit::drink() { cout &lt;&lt; \"兔子喝\" &lt;&lt; endl;} 使用：业务函数中需要传入一个基类Animal，使用的时候，Animal的子类和和它自己都能传入，使用虚函数之后，就可以调用自己的相关方法了。123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include \"Animal.h\"#include \"Rabbit.h\"using namespace std;//业务函数void bizAnimal(Animal &amp;a) { a.eat(); a.drink();}void main() { Animal a; bizAnimal(a); Rabbit r; bizAnimal(r); system(\"pause\");} 纯虚函数纯虚函数相当于java中的抽象类 123456789101112131415161718192021222324252627class Shape{public: //纯虚函数 virtual void sayArea() = 0; void print(){ cout &lt;&lt; \"hi\" &lt;&lt; endl; }};//圆class Circle : public Shape{public: Circle(int r){ this-&gt;r = r; } void sayArea(){ cout &lt;&lt; \"圆的面积：\" &lt;&lt; (3.14 * r * r) &lt;&lt; endl; }private: int r;};void main(){ //Shape s; Circle c(10); system(\"pause\");} 当一个类有一个纯虚函数的时候，这个类就是一个抽象类。 抽象类不能实例化对象 子类继承抽象类，必须要实现纯虚函数，如果没有实现，那么子类也是抽象类。 接口跟抽象类的写法一模一样，只是用到的时候，逻辑上叫它接口。 模板函数和模板类模板函数相当于java中的泛型，泛型主要解决业务逻辑一样，数据类型不一样的问题 比如下面代码 12345678910111213void swap(int&amp; a,int&amp; b){ int tmp = 0; tmp = a; a = b; b = tmp;}void swap(char&amp; a, char&amp; b){ char tmp = 0; tmp = a; a = b; b = tmp;} 这两个函数都是实现的一样的功能就是交换，只是传入的数据不一样，这时候就可以抽取一个模板。使用template关键字来修饰，让类型自动推导。 12345678910111213141516171819template &lt;typename T&gt;void swap(T&amp; a, T&amp; b){ T tmp = 0; tmp = a; a = b; b = tmp;}void main(){ //根据实际类型，自动推导 int a = 10, b = 20; swap&lt;int&gt;(a,b); cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl; char x = 'v', y = 'w'; swap(x, y); cout &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; endl; system(\"pause\");} 模板类：1234567891011121314151617181920212223242526272829303132333435363738//模板类template&lt;class T&gt;class A{public: A(T a){ this-&gt;a = a; }protected: T a;};//普通类继承模板类class B : public A&lt;int&gt;{public: B(int a,int b) : A&lt;int&gt;(a){ this-&gt;b = b; }private: int b;};//模板类继承模板类template &lt;class T&gt;class C : public A&lt;T&gt;{public: C(T c, T a) : A&lt;T&gt;(a){ this-&gt;c = c; }protected: T c;};void main(){ //实例化模板类对象 //List&lt;String&gt; list; A&lt;int&gt; a(6); system(\"pause\");} 异常C++ 异常处理，根据抛出的异常数据类型，进入到相应的catch块中123456789101112131415161718void main() { try { int age = 300; if (age &gt; 200) { throw &quot;10.0&quot;; } } catch (int a) { cout &lt;&lt; &quot;int异常&quot; &lt;&lt; endl; } catch (const char *b) { cout &lt;&lt; b &lt;&lt; endl; } catch (...) { cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; endl; } system(&quot;pause&quot;);} 上面代码中我们throw什么类型的异常，就会进入对应的下面catch中。catch (...)代表捕获为止异常。 我们也可以自定义自己的异常类1234567891011121314151617181920212223class MyException {};void mydiv(int a, int b) { if (b == 0) { throw MyException(); //不要抛出异常指针 //throw new MyException; }}void main() { try { mydiv(8, 0); } catch (MyException&amp; e2) { cout &lt;&lt; \"MyException引用\" &lt;&lt; endl; } catch (MyException* e1) { cout &lt;&lt; \"MyException指针\" &lt;&lt; endl; delete e1; } system(\"pause\");} 上面代码中，定义自己的异常类MyException，抛出异常的时候可以直接throw MyException()然后捕获。也可以使用/throw new MyException不过通过new的这种方式抛出的是异常的指针，捕获到之后还要释放内存，所以不要使用这种方式太麻烦。 C++ 标准的异常： C++ 提供了一系列标准的异常，这些类都是 exception 类派生而来的 中，我们可以在程序中使用这些标准的异常。 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 我们也可以通过集成exception来自定义一个异常。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdexcept&gt;//自定义（类似于JavaNullPointerException）class NullPointerException : public exception {public: NullPointerException(const char* msg) : exception(msg) { }};void mydiv(int a, int b) { if (b &gt; 10) { //标准异常 throw out_of_range(\"超出范围\"); } else if (b == NULL) { throw NullPointerException(\"空指针\"); } else if (b == 0) { //标准异常 throw invalid_argument(\"参数不合法\"); }}void main() { try { mydiv(8, NULL); } catch (out_of_range e1) { cout &lt;&lt; e1.what() &lt;&lt; endl; } catch (NullPointerException&amp; e2) { cout &lt;&lt; e2.what() &lt;&lt; endl; } catch (...) { } system(\"pause\");} 类型的转换C++提供了4中类型转换操作符 const_cast：修改类型的const或volatile属性 static_cast：静态类型转换，如int转换成char，指针与void之间互转。如：float转成void、Bean转成void、函数指针转成void*等；子类指针/引用与 父类指针/引用 转换。 dynamic_cast：动态类型转换，比如子类和父类之间多态类型的转换 reinterpret_cast：对指针、引用进行原始转换 使用格式： TYPE B = static_cast(TYPE)(a) 类型强制转换的时候，其实我们可以直接使用(TYPE)这种形式转换比如int i; double j = (int)i，C++吧转换类型细化，可以让意图更加明显，可读性更高。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void* func(int type){ switch (type){ case 1: { int i = 9; return &amp;i; } case 2: { int a = 'X'; return &amp;a; } default:{ return NULL; } } }void func2(char* c_p){ cout &lt;&lt; *c_p &lt;&lt; endl;}void main(){ //int i = 0; 自动转换 可读性不高 //double d = i; //double d = 9.5; //int i = d; int i = 8; double d = 9.5; //意图明显 可读性高 i = static_cast&lt;int&gt;(d); //void* -&gt; char* //char* c_p = (char*)func(2); //char* c_p = static_cast&lt;char*&gt;(func(2)); //C++ 意图明显 func2(static_cast&lt;char*&gt;(func(2))); //C func2((char*)(func(2))); system(\"pause\");} 假如我们想要修改一个使用const修饰的常量，正常情况下无法修改，只能通过指针间接的去修改，但是别人阅读起这个代码来就比较费劲了。而使用const_cast，意图明显就更加容易理解。1234567891011121314void func(const char c[]){ //通过指针间接赋值，其他人并不知道，这次转型是为了去常量 //char* c_p = (char*)c; //c_p[1] = 'X'; //提高了可读性 char* c_p = const_cast&lt;char*&gt;(c); c_p[1] = 'Y'; cout &lt;&lt; c &lt;&lt; endl;}void main(){ char c[] = \"hello\"; func(c); system(\"pause\");} 子类和父类之间多态类型的转换使用dynamic_cast来提高可读性,防止不可预见的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Person{public: virtual void print(){ cout &lt;&lt; \"人\" &lt;&lt; endl; }};class Boy : public Person{public: void print(){ cout &lt;&lt; \"boy\" &lt;&lt; endl; } void chasing(){ cout &lt;&lt; \"泡妞\" &lt;&lt; endl; }};class Girl : public Person{public: void print(){ cout &lt;&lt; \"girl\" &lt;&lt; endl; } void carebaby(){ cout &lt;&lt; \"生孩子\" &lt;&lt; endl; }};void func(Person* obj){ //调用子类的特有的函数，转为实际类型 //并不知道转型失败 //Boy* b = (Boy*)obj; //b-&gt;print(); //转型失败，返回NULL Boy* b = dynamic_cast&lt;Man*&gt;(obj); if (b != NULL){ b-&gt;chasing(); } Girl* w = dynamic_cast&lt;Woman*&gt;(obj); if (g != NULL){ g-&gt;carebaby(); }}void main(){ //Girl g1; //Person *p1 = &amp;g1; //func(p1); Girl g2; Girl* w_p = &amp;g2; system(\"pause\");} 上的代码中，一个函数中需要传入一个Person对象，方法内部使用原始转换方式强制转换成Boy对象。加入我们传入一个Girl对象进来，其实是转型失败的。使用原始方式即使转型失败我们也察觉不到。使用dynamic_cast，如果转型失败会返回一个NULL值。 使用reinterpret_cast来转型函数指针12345678910111213141516171819202122232425262728using namespace std;void func1(){ cout &lt;&lt; \"func1\" &lt;&lt; endl;}char* func2(){ cout &lt;&lt; \"func2\" &lt;&lt; endl; return \"abc\";}//定义函数指针类型typedef void(*f_p)();void main(){ //函数指针数组 f_p f_array[6]; //赋值 f_array[0] = func1; //C方式 //f_array[1] = (f_p)(func2); //C++方式 f_array[1] = reinterpret_cast&lt;f_p&gt;(func2); f_array[1](); system(\"pause\");} C++中的io操作12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;fstream&gt;//IO流//文本文件操作void main(){ char* fname = \"c://dest.txt\"; //输出流 ofstream fout(fname); //创建失败 if (fout.bad()){ return; } fout &lt;&lt; \"大海\" &lt;&lt; endl; fout &lt;&lt; \"哈哈哈\" &lt;&lt; endl; //关闭 fout.close(); //读取 ifstream fin(fname); if (fin.bad()){ return; } char ch; while (fin.get(ch)){ //输出 cout &lt;&lt; ch; } fin.close(); system(\"pause\");} 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;fstream&gt;//二进制文件void main(){ char* src = \"c://test.jpg\"; char* dest = \"c://test_1.jpg\"; //输入流 ifstream fin(src, ios::binary); //输出流 ofstream fout(dest, ios::binary); if (fin.bad() || fout.bad()){ return; } //end of file while (!fin.eof()){ //读取 char buff[1024] = {0}; fin.read(buff,1024); //写入 fout.write(buff,1024); } //关闭 fin.close(); fout.close(); system(\"pause\");} C++对象的持久化123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person{public: Person() { } Person(char * name, int age) { this-&gt;name = name; this-&gt;age = age; } void print() { cout &lt;&lt; name &lt;&lt; \",\" &lt;&lt; age &lt;&lt; endl; }private: char * name; int age;};void main(){ Person p1(\"老蔡\", 22); Person p2(\"老吴\", 18); //输出流 ofstream fout(\"c://obj.data\", ios::binary); fout.write((char*)(&amp;p1), sizeof(Person)); //指针能够读取到正确的数据，读取内存区的长度 fout.write((char*)(&amp;p2), sizeof(Person)); fout.close(); //输入流 ifstream fin(\"c://obj.data\", ios::binary); Person tmp; //从哪里读 督导哪里结束 传入一个指针来操作加载进来的对象 fin.read((char*)(&amp;tmp), sizeof(Person)); tmp.print(); fin.read((char*)(&amp;tmp), sizeof(Person)); tmp.print(); system(\"pause\");} C++标准模板库(stl standard template library ) 1234567891011121314151617#include &lt;string&gt;using namespace std;void main(){ string s1 = \"craig david\"; string s2(\" 7 days\"); string s3 = s1 + s2; cout &lt;&lt; s3 &lt;&lt; endl; //转c字符串 const char* c_str = s3.c_str(); cout &lt;&lt; c_str &lt;&lt; endl; //s1.at(2); system(\"pause\");} 序列式容器：元素的排列顺序与元素本身无关，由添加的顺序决定。 序列容器一般有：List,vertor,queue,dequeue,stack,priority queue, 关联式容器：如set,map 1234567891011121314151617181920212223242526#include &lt;vector&gt;void main(){ //动态数组 //不需要使用动态内存分配，就可以使用动态数组 vector&lt;int&gt; v; v.push_back(12); v.push_back(10); v.push_back(5); for (int i = 0; i &lt; v.size(); i++) { cout &lt;&lt; v[i] &lt;&lt; endl; } //返回第一个元素 v.front() //返回最后一个元素 v.back() //清空 v.clear() //删除指定元素 v.erase(v.begin(),b.end()) system(\"pause\");}","link":"/2019/05/19/technology/C-基础知识/"},{"title":"RecycleView的绘制流程","text":"RecycleView的绘制流程 RecycleView继承自ViewGroup，绘制流程肯定也是遵循View的，测量(onMeasure),布局(onLayout),绘制(onDdraw)三大流程。所以从这三个地方开始查看，本篇是27.1.1版本的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182protected void onMeasure(int widthSpec, int heightSpec) { //mLayout是LayoutManager如果为null，就走默认测量然后返回 if (mLayout == null) { defaultOnMeasure(widthSpec, heightSpec); return; } //是否自动测量，比如常用的LinearLayoutManager和GridLayoutManager中默认直接返回true if (mLayout.isAutoMeasureEnabled()) { //获取长宽的测量规格 final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //内部还是调用了mRecyclerView.defaultOnMeasure走默认测量 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); //判断宽高的测量模式是不是精确测量 final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //如果测量模式是精确值比如match_partent，写死的值或者adapter是null，结束测量 if (measureSpecModeIsExactly || mAdapter == null) { return; } 如果测量步骤是开始 if (mState.mLayoutStep == State.STEP_START) { //布局的第一步，更新适配器，决定运行哪个动画，保存有关当前视图的信息，如果有必要，运行预测布局并保存其信息。 dispatchLayoutStep1(); } // 在第二步设置尺寸，预布局和旧尺寸要一致 mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; dispatchLayoutStep2(); //现在可以从子元素中得到宽和高 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); // 如果RecyclerView 没有精确的高度和宽度，并且只有一个孩子 // 我们需要重新测量 if (mLayout.shouldMeasureTwice()) { mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); } } else { //如果子view的大小不影响recycleview的大小 if (mHasFixedSize) { mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); return; } // 自定义测量 if (mAdapterUpdateDuringMeasure) { startInterceptRequestLayout(); onEnterLayoutOrScroll(); processAdapterUpdatesAndSetAnimationFlags(); onExitLayoutOrScroll(); if (mState.mRunPredictiveAnimations) { mState.mInPreLayout = true; } else { // consume remaining updates to provide a consistent state with the layout pass. mAdapterHelper.consumeUpdatesInOnePass(); mState.mInPreLayout = false; } mAdapterUpdateDuringMeasure = false; stopInterceptRequestLayout(false); } else if (mState.mRunPredictiveAnimations) { setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); return; } if (mAdapter != null) { mState.mItemCount = mAdapter.getItemCount(); } else { mState.mItemCount = 0; } startInterceptRequestLayout(); mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); stopInterceptRequestLayout(false); mState.mInPreLayout = false; // clear } } 从上面的代码来看，先判断LayoutManager是否为null，如果是结束测量，然后判断测量模式是不是精确模式，也就是布局文件中设置match_parent和写死固定值，如果是结束测量。如果是wrap_content继续执行下面的方法。 如果是刚开始测量的状态，执行 dispatchLayoutStep1()方法，如果判断不是精准模式，在执行dispatchLayoutStep2()方法。dispatchLayoutStep1()主要是做一些清空和初始化操作，dispatchLayoutStep2()是真正的测量子view的宽高来决定recycleview的宽高。 初始化操作的代码就不看了，从dispatchLayoutStep1()的注释来看主要做了以下步骤：1. adapter的更新 2.决定应该运行哪个动画 3. 保存视图当前的信息 4. 如果需要，运行预测布局并保存信息。 下面来看dispatchLayoutStep2()方法 1234567891011121314151617181920212223private void dispatchLayoutStep2() { //开始中断布局请求 startInterceptRequestLayout(); onEnterLayoutOrScroll(); //设置状态为 布局和动画状态 mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; // 开始布局 mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; mPendingSavedState = null; // 是否禁用动画 mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; mState.mLayoutStep = State.STEP_ANIMATIONS; onExitLayoutOrScroll(); stopInterceptRequestLayout(false);} 从上面代码可以看到，开始布局那mLayout是LayoutManager对象，调用了LayoutManager中的onLayoutChildren方法，所以从这里我们可以知道，最终的布局是交给LayoutManager来完成的，系统提供了三个LayoutManager，线性的，网格的和瀑布流的，我们也可以自己继承LayoutManager来实现我们自己的LayoutManager。 所有item的布局都是在onLayoutChildren中实现，下面看LinearLayoutManager中的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { // layout algorithm: // 1) 通过检子view和其他变量找到一个锚点坐标和锚点位置 // 2) 从底部开始填充 // 3) 从顶部开始填充 // 4) 处理2和3两种方式的滚动 ...... final View focused = getFocusedChild(); if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) { mAnchorInfo.reset(); mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // 计算锚点的位置 updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; }else{......} ...... //一般情况下会选取最上（反向布局则是最下）的子View作为锚点参考 if (mAnchorInfo.mLayoutFromEnd) { // 更新锚点坐标 updateLayoutStateToFillStart(mAnchorInfo); //设置开始位置 mLayoutState.mExtra = extraForStart; //开始填充 fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; final int firstElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) { extraForEnd += mLayoutState.mAvailable; } // 更新锚点坐标 updateLayoutStateToFillEnd(mAnchorInfo); //设置结束位置 mLayoutState.mExtra = extraForEnd; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; //开始填充 fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) { // end could not consume all. add more items towards start extraForStart = mLayoutState.mAvailable; updateLayoutStateToFillStart(firstElement, startOffset); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; } }else{ ...... } ......} 这段代码比较多，本篇省略缓存的部分，只看绘制，主要是通过子view和其他变量找到锚点信息，通过锚点信息判断出是从下往上填充还是从上往下填充，updateLayoutStateToFillStart和updateLayoutStateToFillEnd不断更新锚点的值，其实就是计算屏幕的上方或者下方是否还有剩余的空间，在调用fill方法填充的时候，如果空间不足就不会执行填充的方法。然后在fill(recycler, mLayoutState, state, false)方法中填充View。 mAnchorInfo是AnchorInfo类用来保存锚点的信息，它有三个主要变量 int mPosition;//锚点参考view在整个布局中的位置，是第几个 int mCoordinate; //锚点的起始坐标 boolean mLayoutFromEnd; 是否从尾部开始布局默认是false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /** * 填充由layoutState给定的布局，它独立于LinearLayoutManager之外，稍微改一下可以用于我们的自定义的LayoutManager * @param recycler 当前的回收对象 * @param layoutState 记录如何填充空间 * @param state 控制滚动的步骤 * @param stopOnFocusable 如果为true，则在第一个可聚焦的新子元素中停止填充 * @return 它添加的像素数。适用于滚动函数 */int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) { // 我们应该设置最大偏移量是 mFastScroll + available final int start = layoutState.mAvailable; if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) { // TODO ugly bug fix. should not happen if (layoutState.mAvailable &lt; 0) { layoutState.mScrollingOffset += layoutState.mAvailable; } //回收掉已经滑出屏幕的View recycleByLayoutState(recycler, layoutState); } int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; //循环填充：进入条件有足够的空白空间和有更多数据 while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) { layoutChunkResult.resetInternal(); if (VERBOSE_TRACING) { TraceCompat.beginSection(\"LLM LayoutChunk\"); } //向屏幕上填充一个View layoutChunk(recycler, state, layoutState, layoutChunkResult); if (VERBOSE_TRACING) { TraceCompat.endSection(); } if (layoutChunkResult.mFinished) { break; } layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; /** * Consume the available space if: * * layoutChunk did not request to be ignored * * OR we are laying out scrap children * * OR we are not doing pre-layout */ if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null || !state.isPreLayout()) { //如果进行了填充，减去填充使用的空间 layoutState.mAvailable -= layoutChunkResult.mConsumed; // 保留一个单独的剩余空间，因为mAvailable对于回收非常重要 remainingSpace -= layoutChunkResult.mConsumed; } if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) { layoutState.mScrollingOffset += layoutChunkResult.mConsumed; if (layoutState.mAvailable &lt; 0) { layoutState.mScrollingOffset += layoutState.mAvailable; } recycleByLayoutState(recycler, layoutState); } if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) { break; } } if (DEBUG) { validateChildOrder(); } return start - layoutState.mAvailable; } fill()方法中回收移除不可见的View，在屏幕上堆叠出可见的Viw，堆叠的原理就是看看当前界面有没有剩余的空间，如果有就拿一个新的View填充上去，填充工作使用layoutChunk(recycler, state, layoutState, layoutChunkResult)方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) { //找到将要布局的View,先从缓存中找找不到在创建 View view = layoutState.next(recycler); ...... LayoutParams params = (LayoutParams) view.getLayoutParams(); //如果ViewHolder的列表不为null if (layoutState.mScrapList == null) { if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) { //添加view，最终调用ViewGroup的addView方法 addView(view); } else { //添加view， 最终调用ViewGroup的addView方法 addView(view, 0); } } else { if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) { //将要消失的view addDisappearingView(view); } else { //将要消失的view addDisappearingView(view, 0); } } //测量子view measureChildWithMargins(view, 0, 0); result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; //横排和竖排不同模式下 子view的四个边的边距 if (mOrientation == VERTICAL) { if (isLayoutRTL()) { right = getWidth() - getPaddingRight(); left = right - mOrientationHelper.getDecoratedMeasurementInOther(view); } else { left = getPaddingLeft(); right = left + mOrientationHelper.getDecoratedMeasurementInOther(view); } if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) { bottom = layoutState.mOffset; top = layoutState.mOffset - result.mConsumed; } else { top = layoutState.mOffset; bottom = layoutState.mOffset + result.mConsumed; } } else { top = getPaddingTop(); bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view); if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) { right = layoutState.mOffset; left = layoutState.mOffset - result.mConsumed; } else { left = layoutState.mOffset; right = layoutState.mOffset + result.mConsumed; } } //布局这个子view layoutDecoratedWithMargins(view, left, top, right, bottom); ...... } layoutChunk方法就是找到一个子view，寻找子view是先去缓存中寻找找不到在通过调用createViewHolder()创建一个新的，缓存的逻辑此篇不往下看，只看绘制流程 找到view之后，通过addView方法，加入到ViewGroup中 通过measureChildWithMargins方法测量一个子view，会把我们通过recycleview.addItemDecoration方法设置的分割线的大小也计算进去，之后计算子view的四个边的边距 最后通过layoutDecoratedWithMargins方法布局一个子view。layoutDecoratedWithMargins中调用就是view的layout方法。 到此dispatchLayoutStep2()这个方法算是看完了，到此所有子view的测量（measure）和布局（layout），然后执行dispatchLayoutStep2()这个方法后面的方法 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec) 根据子view的大小来设置自身（RecycleView）的大小。 RecycleView的onMeasure方法看完了，下面来看一下它的onLayout方法。123456protected void onLayout(boolean changed, int l, int t, int r, int b) { TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true; } 里面调用了 dispatchLayout()方法12345678910111213141516171819202122232425262728void dispatchLayout() { if (mAdapter == null) { Log.e(TAG, &quot;No adapter attached; skipping layout&quot;); // leave the state in START return; } if (mLayout == null) { Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;); // leave the state in START return; } mState.mIsMeasuring = false; //如果状态还是开始状态，那么从新走一遍dispatchLayoutStep1();和dispatchLayoutStep2(); if (mState.mLayoutStep == State.STEP_START) { dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) { // 数据更改后重新执行dispatchLayoutStep2(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); } else { // 确保是精准模式 mLayout.setExactMeasureSpecsFrom(this); } dispatchLayoutStep3(); } 在onMeasure的源码中我们知道，如果RecycleView设置的是精准模式（比如match_partent，写死的值）就直接返回了，那么它的状态还是State.STEP_START，到了onLayout方法后还是会执行dispatchLayoutStep1()和dispatchLayoutStep2()方法。 也就是说如果RecycleView设置的wrap_content，那么就先去测量和布局子view，根据子view的宽高来确定自身的宽高，反之如果RecycleView设置的是精准模式，就在onLayou中去测量和布局子veiw。 这里有出来一个dispatchLayoutStep3()，第三步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private void dispatchLayoutStep3() { mState.assertLayoutStep(State.STEP_ANIMATIONS); startInterceptRequestLayout();//开始中断布局 onEnterLayoutOrScroll(); mState.mLayoutStep = State.STEP_START; if (mState.mRunSimpleAnimations) { // 找到当前的位置，并处理更改动画 for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) { ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore()) { continue; } long key = getChangedHolderKey(holder); final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) { //运行一个变更动画 final boolean oldDisappearing = mViewInfoStore.isDisappearing( oldChangeViewHolder); final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) { // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); } else { final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( oldChangeViewHolder); // we add and remove so that any post info is merged. mViewInfoStore.addToPostLayout(holder, animationInfo); ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); if (preInfo == null) { handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); } else { animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); } } } else { mViewInfoStore.addToPostLayout(holder, animationInfo); } } // 触发动画 mViewInfoStore.process(mViewInfoProcessCallback); } mLayout.removeAndRecycleScrapInt(mRecycler); mState.mPreviousLayoutItemCount = mState.mItemCount; mDataSetHasChangedAfterLayout = false; mDispatchItemsChangedEvent = false; mState.mRunSimpleAnimations = false; mState.mRunPredictiveAnimations = false; mLayout.mRequestedSimpleAnimations = false; if (mRecycler.mChangedScrap != null) { mRecycler.mChangedScrap.clear(); } if (mLayout.mPrefetchMaxObservedInInitialPrefetch) { // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); } //布局完成 mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) { dispatchOnScrolled(0, 0); } recoverFocusFromState(); resetFocusInfo(); } 可以看到，dispatchLayoutStep3()主要做了一些收尾的工作，这是布局的最后一步，保存视图和动画的信息，并做一些清理的工作。 onLayout方法就完了，最后看onDraw()方法12345678public void onDraw(Canvas c) { super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) { mItemDecorations.get(i).onDraw(c, this, mState); }} onDraw方法很简单，就是绘制分割线，我们通过recycleview.addItemDecoration方法设置的分割线就在这里开始绘制，调用的是我们自定义分割线的时候里面写的onDraw方法。绘制的区域就是我们在自定义分割线的时候重写的getItemOffsets方法中的设置的偏移。这部分的测量工作在dispatchLayoutStep2()-&gt;onLayoutChildren-&gt;fill-&gt;layoutChunk-&gt;measureChildWithMargins这个方法中。12345678910111213141516171819public void measureChildWithMargins(View child, int widthUsed, int heightUsed) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //获取装饰线条 就是我们添加的分割线 final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child); widthUsed += insets.left + insets.right; heightUsed += insets.top + insets.bottom; //计算长和宽的测量模式 加上margin，padding 和 分隔线的长宽 final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, canScrollHorizontally()); final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, canScrollVertically()); if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) { child.measure(widthSpec, heightSpec); } } 上面代码中就是获取线条的长宽，然后子veiw的可使用的宽高要减去这部分的值。 OK到这里RecycleView的绘制流程查看完成。 参考文章 https://www.jianshu.com/p/f91b41c8f487 https://www.jianshu.com/p/0c41bf63072a https://www.jianshu.com/p/616ca453aa17 https://www.jianshu.com/p/8fa71076179d","link":"/2019/04/05/technology/RecycleView的绘制流程/"},{"title":"Andorid组件化跳转路由","text":"Andorid组件化跳转路由 简单介绍路由在组件化工程中有非常重要的作用，两个没有相互引用的module之间怎么通信呢。 可以使用EventBus，使用广播，使用类加载，使用反射，scheme，隐式意图等等，这些方法各自都有优缺点，现在开源用的比较多的路由框架中ARouter中使用的是类加载的方法下面我们也使用类加载的方式自己封装一个小路由。 那怎么使用类加载的方法来进行不同组件之间通信呢。很简单只要我们能拿到一个类的全类名就可以啦 比如，新建一个工程appcom.chs.mymodule.MainActivity，并创建两个module，一个订单组件com.chs.order.OrderActivity，一个积分组件com.chs.integral.IntegralActivity。现在从app模块跳到订单模块只需如下操作就可以啦1234567try { Class&lt;?&gt; clzz = Class.forName(\"com.chs.order.OrderActivity\"); Intent intent = new Intent(this,clzz); startActivity(intent); } catch (Exception e) { e.printStackTrace(); } 如果每次都这么写类名的话有点麻烦，各种点容易写错。那可不可以封装一下，其实我们只要拿到OrderActivity中的类名就可以了。 所以我们可以把这些需要跳转的类保存起来，比如保存到一个map中，跳转的时候就通过key拿到类名，然后继续通过Intent跳转。 简单实现首先新建一个实体类用来保存路径和对应的类12345678910111213141516171819202122232425262728public class PathBean { private String path; private Class&lt;?&gt; clzz; public PathBean() { } public PathBean(String path, Class&lt;?&gt; clzz) { this.path = path; this.clzz = clzz; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } public Class&lt;?&gt; getClzz() { return clzz; } public void setClzz(Class&lt;?&gt; clzz) { this.clzz = clzz; }} 然后新建一个管理类，用来保存注册过来的路径，和类信息12345678910111213141516171819202122232425262728293031323334353637383940public class RecordPathManager { public static Map&lt;String, List&lt;PathBean&gt;&gt; groupMap = new HashMap&lt;&gt;(); public static void joinGroup(String groupName,String pathName,Class&lt;?&gt; clzz){ List&lt;PathBean&gt; pathBeans = groupMap.get(groupName); if(pathBeans == null){ pathBeans = new ArrayList&lt;&gt;(); pathBeans.add(new PathBean(pathName,clzz)); groupMap.put(groupName,pathBeans); }else { if(!isExit(pathName,pathBeans)){ pathBeans.add(new PathBean(pathName,clzz)); } groupMap.put(groupName,pathBeans); } } private static boolean isExit(String pathName,List&lt;PathBean&gt; list){ for (PathBean bean : list) { if(pathName.equals(bean.getPath())){ return true; } } return false; } public static Class&lt;?&gt; getTargetClass(String groupName,String pathName){ List&lt;PathBean&gt; list = groupMap.get(groupName); if(list == null){ return null; }else { for (PathBean bean : list) { if(pathName.equalsIgnoreCase(bean.getPath())){ return bean.getClzz(); } } } return null; }} 该类非常简单，一个Map，一个存的方法和一个取的方法。为了提高效率这里分一下组，每一个module是一个组，key就是这个module的名字，value就是该组下面的类信息的集合。 最后是怎么存呢，当然是存的越早越好，要不然还没存好就跳转显然拿不到相关的类。所以我们在app模块中的application中存 应用打包的时候，app模块肯定是依赖的所有的模块，所以子模块中的类它肯定也能拿到。所以注册的代码如下 12345678910public class App extends BaseApplication { @Override public void onCreate() { super.onCreate(); RecordPathManager.joinGroup(\"order\",\"OrderActivity\", OrderActivity.class); RecordPathManager.joinGroup(\"integral\",\"IntegralActivity\", IntegralActivity.class); ...... }} 将需要跳转的类activity的模块名，类名和类信息保存到管理类的Map中。使用的时候如下 1234567try { Class&lt;?&gt; clzz = RecordPathManager.getTargetClass(\"integral\",\"IntegralActivity\"); Intent intent = new Intent(this,clzz); startActivity(intent); } catch (Exception e) { e.printStackTrace(); } 看起来比开始简单了一点点，不过这个在activity中一个一个的注册也是太麻烦，就几个类还好，几十上百的类估计会把自己写吐了，那能不能让系统帮我们写注册的代码呢，当然可以啦，这时候就用到APT的技术来实现啦。 使用APT自动完成注册。下面仿照ARouter来实现一个简单跳转的路由， 项目结构如上图： annotation是注解module 是个java module compiler是注解处理器 必须是个java module order和integral是两个字module arouter用来定义存储的规范 先在annotation中定义一个编译时注解1234567@Retention(RetentionPolicy.CLASS)@Target(ElementType.TYPE)public @interface ARouter { String path(); String group() default \"\";} 在定义一个RouterBean，相当于前面简单实现中的PathBean对象，用来存储路径，类，组名等。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class RouterBean { public enum Type{ /** * activity类型 */ ACTIVITY; } private Type mType; /** * 类结点 */ private Element mElement; /** * 组名 */ private String group; /** * 路由的地址 */ private String path; private Class&lt;?&gt; mClazz; private RouterBean() { } private RouterBean(Type type, Class&lt;?&gt; clazz, String path, String group) { this.mType = type; this.mClazz = clazz; this.path = path; this.group = group; } public static RouterBean create(Type type,Class&lt;?&gt; clazz,String path,String group){ return new RouterBean(type,clazz,path,group); } private RouterBean(Builder builder) { mElement = builder.mElement; group = builder.group; path = builder.path; } public Type getType() { return mType; } public Element getElement() { return mElement; } public String getGroup() { return group; } public String getPath() { return path; } public Class&lt;?&gt; getClzz() { return mClazz; } public void setType(Type type) { mType = type; } public void setGroup(String group) { this.group = group; } public void setPath(String path) { this.path = path; } public static final class Builder{ private Element mElement; private String group; private String path; public Builder setElement(Element element) { mElement = element; return this; } public Builder setGroup(String group) { this.group = group; return this; } public Builder setPath(String path) { this.path = path; return this; } public RouterBean build(){ if(path==null||path.length()==0){ throw new IllegalArgumentException(\"path 为空 比如 /app/MainActivity\"); } return new RouterBean(this); } } @Override public String toString() { return \"RouterBean{\" + \"group='\" + group + '\\'' + \", path='\" + path + '\\'' + '}'; }} 下面在arouter_api 这个module中定义两个接口ARouterLoadGroup和ARouterLoadPath。 一个工程中会有很多个module，如果每次把说有的类都加载比较耗费内存，所以设计一个组来管理，组名就是当前的module的名字，它下面管理着该module下的所有注册的activity类，只有用户到了该module的时候才会加载 我们生成类会继承自这两个接口。1234567891011121314/** *key:\"app\", value:\"app\"分组对应的路由详细对象类 */public interface ARouterLoadGroup { Map&lt;String,Class&lt;? extends ARouterLoadPath&gt;&gt; loadGroup();}public interface ARouterLoadPath { /** * 比如传入 /app/MainActivity 通过app找到对应的组，然后通过/app/MainActivity找到对应的class */ Map&lt;String, RouterBean&gt; loadPath();} 下面来到了重头戏注解管理器compiler中。 先在其gradle文件中引入相关的工具12345678910111213141516171819202122apply plugin: 'java-library'dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) compileOnly'com.google.auto.service:auto-service:1.0-rc4' annotationProcessor'com.google.auto.service:auto-service:1.0-rc4' // 帮助我们通过类调用的形式来生成Java代码 implementation \"com.squareup:javapoet:1.9.0\" // 依赖注解 implementation project(':annotation')}// java控制台输出中文乱码tasks.withType(JavaCompile) { options.encoding = \"UTF-8\"}sourceCompatibility = \"7\"targetCompatibility = \"7\" auto-service是谷歌提供的可以用来自动触发注解管理器运行。 javapoet是著名的square公司出品，用来生成java类的工具 javapoet有8个常用的类 类对象 说明 MethodSpec 代表一个构造函数或者方法声明 TypeSpec 代表一个类，接口，或者枚举声明 FieldSpec 代表一个成员变量，一个字段的声明 JavaFile 包含一个顶级的Java文件 ParameterSpec 用来创建参数 AnnotationSpec 用来创建注解 ClassName 用来包装一个类 TypeName 类型，比如添加返回值类型使用TypeName.VOID JavaPort字符串的格式化规则 符号 描述 $L|字面量 比如 “int value=$L”,10$S|字符串 比如 $S,”hello”$T|类、接口 比如 $T,MainActivity$N|变量 比如 user.$N,name 上面两个表中的数据比较重要，下面写注解管理器的时候都会用到。 具体用法可以到https://github.com/square/javapoet中查看 因为相关的类是我们自己生成的，所以事先我们肯定知道它最后的样子，先看看需要生成的类的最后的样子1234567891011121314151617public class ARouter$$Group$$app implements ARouterLoadGroup { @Override public Map&lt;String, Class&lt;? extends ARouterLoadPath&gt;&gt; loadGroup() { Map&lt;String,Class&lt;? extends ARouterLoadPath&gt;&gt; groupMap = new HashMap&lt;&gt;(); groupMap.put(\"app\",ARouter$$Path$$app.class); return groupMap; }}public class ARouter$$Path$$app implements ARouterLoadPath { @Override public Map&lt;String, RouterBean&gt; loadPath() { Map&lt;String,RouterBean&gt; pathMap = new HashMap&lt;&gt;(); pathMap.put(\"/app/Main2Activity\",RouterBean.create(RouterBean.Type.ACTIVITY,Main2Activity.class,\"/app/Main2Activity\",\"app\")); pathMap.put(\"/app/MainActivity\",RouterBean.create(RouterBean.Type.ACTIVITY,MainActivity.class,\"/app/MainActivity\",\"app\")); return pathMap; }} 分别继承前面定义的两个接口，一个用来初始化该组的map，并存入路径信息，一个是路径信息类，初始化并保存相关的路径和类信息。 需要注意的是第一个类中使用了第二个类，所以生成类的时候要先生成第二个类，然后在生成第一个类 下面比对着上面的两个类开始编写注解管理器:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297@AutoService(Processor.class)//这里是注解的全类名比如 com.chs.annotation.ARouter，这里保存到一个常量中了@SupportedAnnotationTypes(Const.ACTIVITY_ANNOTATION_TYPE)@SupportedSourceVersion(SourceVersion.RELEASE_7)@SupportedOptions({Const.MODULE_NAME,Const.APT_PACKAGE})public class ARouterProcessor extends AbstractProcessor { /** * 结点工具类 类 函数 属性都是element */ private Elements elementUtils; /** * 类信息工具 */ private Types typeUtils; /** * 打印工具类 */ private Messager mMessager; /** * 文件生成器 */ private Filer mFiler; /** * 组名 */ private String moduleName; /** * 生成的apt文件的路径 包名 */ private String packageNameForAPT; /** * 临时存放路径的类 生成的时候遍历 * key 组名 如app value 组的路由路径 如 ARouter$$Path$$app.class */ private Map&lt;String, List&lt;RouterBean&gt;&gt; tempPathMap = new HashMap&lt;&gt;(); /** * 临时存放组的类 * 比如 key app value ARouter$$Path$$app */ private Map&lt;String, String&gt; tempGroupMap = new HashMap&lt;&gt;(); @Override public synchronized void init(ProcessingEnvironment processingEnvironment) { super.init(processingEnvironment); elementUtils = processingEnv.getElementUtils(); typeUtils = processingEnv.getTypeUtils(); mMessager = processingEnv.getMessager(); mFiler = processingEnv.getFiler(); Map&lt;String, String&gt; options = processingEnv.getOptions(); mMessager.printMessage(Diagnostic.Kind.NOTE,options.toString()); if(!EmptyUtils.isEmpty(options)){ moduleName = options.get(Const.MODULE_NAME); packageNameForAPT = options.get(Const.APT_PACKAGE); mMessager.printMessage(Diagnostic.Kind.NOTE,\"moduleName:\"+moduleName); mMessager.printMessage(Diagnostic.Kind.NOTE,\"packageNameForAPT:\"+packageNameForAPT); } if(EmptyUtils.isEmpty(moduleName)||EmptyUtils.isEmpty(packageNameForAPT)){ throw new IllegalArgumentException(\"注解处理器需要的参数 module或packageName为空，需要在gradle中配置\"); } } @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) { if(!EmptyUtils.isEmpty(set)){ //获取所有被ARouter注解的元素集合 Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class); if(!EmptyUtils.isEmpty(elements)){ try { parseElements(elements); } catch (IOException e) { e.printStackTrace(); } } return true; } return false; } /** * 解析所有别ARouter注解的元素集合 * @param elements */ private void parseElements(Set&lt;? extends Element&gt; elements) throws IOException { //通过element工具获取Activity的类型 activity的路径为 android.app.Activity TypeElement typeElement = elementUtils.getTypeElement(Const.ACTIVITY); //获取activity的TypeMirror TypeMirror activityTypeMirror = typeElement.asType(); for (Element element : elements) { //获取每个元素的类信息 TypeMirror elementTypeMirror = element.asType(); mMessager.printMessage(Diagnostic.Kind.NOTE,\"遍历的元素信息为:\"+elementTypeMirror.toString()); //获取每个类上的ARouter 注解对应的path值 ARouter aRouter = element.getAnnotation(ARouter.class); //封装RouterBean RouterBean routerBean = new RouterBean.Builder() .setGroup(aRouter.group()) .setPath(aRouter.path()) .setElement(element) .build(); //防止用户乱写 判断注解是作用在activity上面 if(typeUtils.isSubtype(elementTypeMirror,activityTypeMirror)){ routerBean.setType(RouterBean.Type.ACTIVITY); }else { throw new IllegalArgumentException(\"@ARouter 目前只能用在Activity上面\"); } //存放到临时的map中 方便后面组装 valueOfPathMap(routerBean); } //ARouterLoadGroup和ARouterLoadPath的类型 TypeElement groupElementType = elementUtils.getTypeElement(Const.AROUTER_GROUP); TypeElement pathElementType = elementUtils.getTypeElement(Const.AROUTER_PATH); //1 先生成路由的path文件 比如 ARouter$$Path$$order createPathFile(pathElementType); //2 在生成路由的组文件 比如 ARouter$$GROUP$$order 因为组中用到了上面的类 createGroupFile(groupElementType,pathElementType); } /** * 生成group对应的path ARouter$$Path$$order * @param pathElementType */ private void createPathFile(TypeElement pathElementType) throws IOException { if(EmptyUtils.isEmpty(tempPathMap)){ return; } //方法的返回值Map&lt;String, RouterBean&gt; TypeName typeName = ParameterizedTypeName.get( ClassName.get(Map.class),ClassName.get(String.class),ClassName.get(RouterBean.class)); //遍历分组，每一个分组创建一个路径文件ARouter$$Path$$order for (Map.Entry&lt;String, List&lt;RouterBean&gt;&gt; entry : tempPathMap.entrySet()) { //方法体 public Map&lt;String, RouterBean&gt; loadPath() {} MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(Const.PATH_METHOD_NAME) .addAnnotation(Override.class) .addModifiers(Modifier.PUBLIC) .returns(typeName); //Map&lt;String, RouterBean&gt; pathMap = new HashMap&lt;&gt;(); methodBuilder.addStatement(\"$T&lt;$T,$T&gt; $N = new $T&lt;&gt;()\",ClassName.get(Map.class) ,ClassName.get(String.class),ClassName.get(RouterBean.class),Const.PATH_PARAMA_NAME ,HashMap.class); List&lt;RouterBean&gt; values = entry.getValue(); for (RouterBean bean : values) { // pathMap.put(\"/order/Order_MainActivity\",RouterBean.create(RouterBean.Type.ACTIVITY // , Order_MainActivity.class,\"/order/Order_MainActivity\",\"order\")); methodBuilder.addStatement(\"$N.put($S,$T.create($T.$L,$T.class,$S,$S))\", Const.PATH_PARAMA_NAME, bean.getPath(), ClassName.get(RouterBean.class), ClassName.get(RouterBean.Type.class), bean.getType(), ClassName.get((TypeElement) bean.getElement()), bean.getPath(), bean.getGroup()); } methodBuilder.addStatement(\"return $N\",Const.PATH_PARAMA_NAME); String finalClassName = Const.PATH_FILD_NAME + entry.getKey(); mMessager.printMessage(Diagnostic.Kind.NOTE, \"APT生成的path类为\"+packageNameForAPT+finalClassName); JavaFile.builder(packageNameForAPT, TypeSpec.classBuilder(finalClassName) //该类实现的接口 .addSuperinterface(ClassName.get(pathElementType)) .addModifiers(Modifier.PUBLIC) //方法体 .addMethod(methodBuilder.build()) .build()) .build() .writeTo(mFiler); tempGroupMap.put(entry.getKey(),finalClassName); } } /** * 生成group ARouter$$Group$$order * @param groupElementType * @param pathElementType */ private void createGroupFile(TypeElement groupElementType, TypeElement pathElementType) throws IOException { if(EmptyUtils.isEmpty(tempPathMap)||EmptyUtils.isEmpty(tempGroupMap)){ return; } //public Map&lt;String, Class&lt;? extends ARouterLoadPath&gt;&gt; loadGroup() { TypeName methodReturn = ParameterizedTypeName.get(ClassName.get(Map.class),ClassName.get(String.class) ,ParameterizedTypeName.get(ClassName.get(Class.class), //Class&lt;? extends ARouterLoadPath&gt; WildcardTypeName.subtypeOf(ClassName.get(pathElementType)))); //方法体 public Map&lt;String, RouterBean&gt; loadPath() {} MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(Const.GROUP_METHOD_NAME) .addAnnotation(Override.class) .addModifiers(Modifier.PUBLIC) .returns(methodReturn); // Map&lt;String, Class&lt;? extends ARouterLoadPath&gt;&gt; groupMap = new HashMap&lt;&gt;(); methodBuilder.addStatement(\"$T&lt;$T,$T&gt; $N = new $T&lt;&gt;()\", ClassName.get(Map.class) ,ClassName.get(String.class), ParameterizedTypeName.get(ClassName.get(Class.class), WildcardTypeName.subtypeOf(ClassName.get(pathElementType))), Const.GROUP_PARAMA_NAME ,HashMap.class); //groupMap.put(\"order\",ARouter$$Path$$order.class); for (Map.Entry&lt;String, String&gt; entry : tempGroupMap.entrySet()) { methodBuilder.addStatement(\"$N.put($S,$T.class)\", Const.GROUP_PARAMA_NAME, entry.getKey(), //指定的包名下 ClassName.get(packageNameForAPT,entry.getValue())); } methodBuilder.addStatement(\"return $N\",Const.GROUP_PARAMA_NAME); String finalClassName = Const.GROUP_FILD_NAME + moduleName; mMessager.printMessage(Diagnostic.Kind.NOTE, \"APT生成的group类为\"+packageNameForAPT+finalClassName); JavaFile.builder(packageNameForAPT, TypeSpec.classBuilder(finalClassName) //该类实现的接口 .addSuperinterface(ClassName.get(groupElementType)) .addModifiers(Modifier.PUBLIC) //方法体 .addMethod(methodBuilder.build()) .build()) .build() .writeTo(mFiler); } private static boolean isExit(String pathName,List&lt;RouterBean&gt; list){ for (RouterBean bean : list) { if(pathName.equalsIgnoreCase(bean.getPath())){ return true; } } return false; } private void valueOfPathMap(RouterBean routerBean) { if(checkRouterPath(routerBean)){ mMessager.printMessage(Diagnostic.Kind.NOTE,\"routerBean对象\"+routerBean.toString()); //开始放入map List&lt;RouterBean&gt; list = tempPathMap.get(routerBean.getGroup()); if(EmptyUtils.isEmpty(list)){ list = new ArrayList&lt;&gt;(); list.add(routerBean); tempPathMap.put(routerBean.getGroup(),list); }else { if(!isExit(routerBean.getPath(),list)){ list.add(routerBean); } } }else { mMessager.printMessage(Diagnostic.Kind.ERROR,\"@ARouter注解没有按照规范些 /app/MainActivity\"); } } private boolean checkRouterPath(RouterBean routerBean) { String path = routerBean.getPath(); String group = routerBean.getGroup(); if(EmptyUtils.isEmpty(path)||!path.startsWith(\"/\")){ mMessager.printMessage(Diagnostic.Kind.ERROR,\"@ARouter注解没有按照规范些 /app/MainActivity\"); return false; } if(path.lastIndexOf(\"/\")== 0){ mMessager.printMessage(Diagnostic.Kind.ERROR,\"@ARouter注解没有按照规范些 /app/MainActivity\"); return false; } String finalGroup = path.substring(1,path.indexOf(\"/\",1)); mMessager.printMessage(Diagnostic.Kind.NOTE,\"finalGroup:\"+finalGroup); if(finalGroup.contains(\"/\")){ mMessager.printMessage(Diagnostic.Kind.ERROR,\"@ARouter注解没有按照规范些 /app/MainActivity\"); return false; } if(!EmptyUtils.isEmpty(group)&amp;&amp;!group.equalsIgnoreCase(moduleName)){ mMessager.printMessage(Diagnostic.Kind.ERROR,\"group必须是当前模块的名字\"); return false; }else { routerBean.setGroup(finalGroup); } return true; }}public class EmptyUtils { public static boolean isEmpty(CharSequence c){ return c==null||c.length()==0; } public static boolean isEmpty(Collection&lt;?&gt; c){ return c==null||c.isEmpty(); } public static boolean isEmpty(final Map&lt;?,?&gt; c){ return c==null||c.isEmpty(); }}//Const类中都是一些常量字符串。 上面类上的@SupportedOptions 这个注解可以接收从build.grale中传过来的参数。比如我们在build.gradle中把module的名字和最后生成的类的包名传过来123456//rootProject.ext.packageNameForAPT是在gradle中定义的常量com.chs.module.apt javaCompileOptions { annotationProcessorOptions { arguments = [moduleName: project.getName(), packageNameForAPT: rootProject.ext.packageNameForAPT] } } 在每个需要生成类的module中都引入注解和注解管理器12implementation project(&apos;:annotation&apos;)annotationProcessor project(&apos;:complier&apos;) 最后重新build工程，在对应module的build文件夹下就会生成相应的类了，比如appmodule中在路径 \\app\\build\\generated\\source\\apt\\debug\\com.chs.module.apt下面就可以看到生成的类ARouter$$Group$$app和ARouter$$Path$$app 最后使用生成的类来实现跳转 1234567891011121314151617181920ARouterLoadGroup group = new ARouter$$Group$$order(); Map&lt;String, Class&lt;? extends ARouterLoadPath&gt;&gt; map = group.loadGroup(); // 通过order组名获取对应路由路径对象 Class&lt;? extends ARouterLoadPath&gt; clazz = map.get(\"order\"); try { // 类加载动态加载路由路径对象 ARouter$$Path$$order path = (ARouter$$Path$$order) clazz.newInstance(); Map&lt;String, RouterBean&gt; pathMap = path.loadPath(); // 获取目标对象封装 RouterBean bean = pathMap.get(\"/order/Order_MainActivity\"); if (bean != null) { Intent intent = new Intent(this, bean.getClzz()); intent.putExtra(\"name\", \"lily\"); startActivity(intent); } } catch (Exception e) { e.printStackTrace(); } 最后集成打包的时候 所有子模块app、order、integral通过APT生成的类文件都会打包到apk里面，不用担心找不到 运行之后会看到跳转成功，不过跳转一次写这么多代码好像不是我们想要的啊，我们理想中的跳转应该是下面的样子123RouterManager.getInstance().build(\"/personal/Personal_MainActivity\") .withString(\"name\",\"chs\") .navigation(this); 这就需要我们把前面的跳转的代码封装一下啦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class RouterManager { private static RouterManager instence; private LruCache&lt;String, ARouterLoadGroup&gt; groupCache; private LruCache&lt;String, ARouterLoadPath&gt; pathCache; private String path; private String group; private static final String GROUP_PRFIX_NAME = \".ARouter$$Group$$\"; public static RouterManager getInstance(){ if(instence == null){ synchronized (RouterManager.class){ if(instence == null){ instence = new RouterManager(); } } } return instence; } public RouterManager() { groupCache = new LruCache&lt;&gt;(100); pathCache = new LruCache&lt;&gt;(100); } public BundleManager build(String path) { if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) { throw new IllegalArgumentException(\"未按规范配置，如：/app/MainActivity\"); } group = subFromPath2Group(path); this.path = path; return new BundleManager(); } /** * 判断path 的格式是否符合规范 * @param path 需要当行的路径 * @return */ private String subFromPath2Group(String path) { if(path.lastIndexOf(\"/\") == 0){ throw new IllegalArgumentException(\"@ARouter注解未按规范配置，如：/app/MainActivity\"); } String finalGroup = path.substring(1, path.indexOf(\"/\", 1)); if (TextUtils.isEmpty(finalGroup)) { throw new IllegalArgumentException(\"@ARouter注解未按规范配置，如：/app/MainActivity\"); } return finalGroup; } public Object navigation(Context context, BundleManager bundleManager, int code) { String groupClassName = context.getPackageName() + \".apt\" + GROUP_PRFIX_NAME + group; Log.e(\"chs &gt;&gt;&gt; \", \"groupClassName -&gt; \" + groupClassName); try { ARouterLoadGroup aRouterLoadGroup = groupCache.get(groupClassName); if(aRouterLoadGroup == null){ Class&lt;?&gt; clazz = Class.forName(groupClassName); aRouterLoadGroup = (ARouterLoadGroup) clazz.newInstance(); groupCache.put(groupClassName,aRouterLoadGroup); } // 获取路由路径类ARouter$$Path$$app 的map if (aRouterLoadGroup.loadGroup().isEmpty()) { throw new RuntimeException(\"路由加载失败\"); } ARouterLoadPath aRouterLoadPath = pathCache.get(path); if(aRouterLoadPath == null){ Class&lt;?&gt; clazz = aRouterLoadGroup.loadGroup().get(group); if (clazz != null){ aRouterLoadPath = (ARouterLoadPath) clazz.newInstance(); pathCache.put(path,aRouterLoadPath); } } if(aRouterLoadPath.loadPath().isEmpty()){ throw new RuntimeException(\"路由路径加载失败\"); } RouterBean routerBean = aRouterLoadPath.loadPath().get(path); if (routerBean != null) { switch (routerBean.getType()){ case ACTIVITY: Intent intent = new Intent(context, routerBean.getClzz()); intent.putExtras(bundleManager.getBundle()); if (bundleManager.isResult()) { ((Activity) context).setResult(code, intent); ((Activity) context).finish(); }else { if (code &gt; 0) { // 跳转时是否回调 ((Activity) context).startActivityForResult(intent, code, bundleManager.getBundle()); } else { context.startActivity(intent, bundleManager.getBundle()); } } break; } } }catch (Exception e) { e.printStackTrace(); } return null; }} 上面代码中的核心类其实就是前面的跳转的代码 通过传入的path路径，截取出group的名字 然后根据组的名字，包名，和定义好的前缀拼接出完成的组类的名字，然后通过类加载实例化出这个对象 实例完成之后调用其loadGroup方法，根据group找出存path的map，最后拿到相关的class执行跳转。 为了提高运行的效率，使用两个LruCache类来缓存组类和path类，先去这里面取，取不到在创建。 我们在activity中跳转的时候，有时候会传递参数，所以前面的代码中创建了一个类BundleManager来管理参数，将参数封装到Bundle中传递，BundleManager类很简单就是封装了一下Bundle。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BundleManager { private Bundle bundle = new Bundle(); private boolean isResult; public Bundle getBundle() { return bundle; } public boolean isResult() { return isResult; } public BundleManager withString(@NonNull String key, @Nullable String value) { bundle.putString(key, value); return this; } public BundleManager withResultString(@NonNull String key, @Nullable String value) { bundle.putString(key, value); isResult = true; return this; } public BundleManager withBoolean(@NonNull String key, boolean value) { bundle.putBoolean(key, value); return this; } public BundleManager withInt(@NonNull String key, int value) { bundle.putInt(key, value); return this; } public BundleManager withBundle(@NonNull Bundle bundle) { this.bundle = bundle; return this; } public Object navigation(Context context) { return RouterManager.getInstance().navigation(context,this,-1); } public Object navigation(Context context,int code) { return RouterManager.getInstance().navigation(context,this,code); }} OK到这里一个简单的跳转路由就完成了。","link":"/2019/07/23/architecture/Andorid组件化跳转路由/"},{"title":"UI绘制流程--View的绘制流程","text":"上一篇UI绘制流程–View是如何被添加到屏幕上的我们学习了View是怎么添加到屏幕上的，这一片来学习View绘制流程，它的入口在入口ActivityThread.handleResumeActivity()。 本篇基于9.0的源码以前的一篇文章 Activity启动流程，最后我Activity启动的最后走到了ActivityThread中执行handleResumeActivity方法并里面执行了activity的onResume方法我们在来看这个方法1234567891011121314151617181920212223242526public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... final Activity a = r.activity; ... final Activity a = r.activity; ... //获取Window也就是PhoneWindow r.window = r.activity.getWindow(); //获取PhoneWindow中的DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); //获取PhoneWindow的参数 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ... a.mWindowAdded = true; wm.addView(decor, l); ... Looper.myQueue().addIdleHandler(new Idler()); } 代码中performResumeActivity就是去执行activity的onResume方法，之后创建了一个ViewManager ，然后拿到WindowManager的LayoutParams，最后通过addView方法把DecorView和LayoutParams放入ViewManager中。那ViewManager是什么呢 从这里我们可以知道，view的添加和绘制是onResume之后才开始的，所以onResume的时候我们是拿不到View的宽和高的 我们看到它是通过a.getWindowManager()获得，a是activity，那就去activity中找一下这个方法123public WindowManager getWindowManager() { return mWindowManager; } 这里直接返回了activity的一个成员变量mWindowManager，那我们去找一下这个成员变量的赋值的地方，可以找到一个set方法1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 可以看到是调用了WindowManagerImpl中的createLocalWindowManager方法来创建的123public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mContext, parentWindow); } 结果返回了一个WindowManagerImpl对象，所以上面的ViewManager其实就是一个WindowManagerImpl对象。所以呢最后调用的就是它的addView方法1234public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } 它又调用了mGlobal的addView方法，mGlobal是个WindowManagerGlobal对象在成员变量中直接通过单例创建WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();去看它的addView方法12345678910111213141516171819202122232425public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ... ViewRootImpl root; View panelParentView = null; ... //创建一个ViewRootImpl并设置参数 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); //保存传过来的view,ViewRootImpl,LayoutParams mViews.add(view); mRoots.add(root); mParams.add(wparams); ... root.setView(view, wparams, panelParentView); ... } 看到这里创建了一个ViewRootImpl，给传过来的DecorView置LayoutParams参数，然后放到对应的集合中缓存，最后调用root.setView方法将他们关联起来。1234567public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized (this) { ... requestLayout(); ... view.assignParent(this); } 里面代码太多了，我们只关注里面的 requestLayout()方法就行1234567891011121314public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { //判断是不是主线程 checkThread(); mLayoutRequested = true; scheduleTraversals(); }}void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); }} 判断是不是在当前线程，当前activity的启动时在主线程，这就是为什么不能再子线程中更新UI，不过这里我们知道上面的方法时在onResume之后执行的，所以如果我们在onResume之前的子线程中执行一个很快的更新UI的操作，如果没有执行到这里就不会报错 首先判断是不是在主线程然后调用了scheduleTraversals方法。12345678910111213void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); }} 我们看到mChoreographer.postCallback方法中传了一个mTraversalRunnable参数到队列中去执行，mTraversalRunnable是TraversalRunnable对象，TraversalRunnable其实是一个Runnable对象，所以真正的的执行的代码在其run方法中。123456789101112131415final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } void doTraversal() { ... //真正的开始执行绘制 performTraversals(); ... } } 又调用了performTraversals方法12345678910111213141516private void performTraversals() { //DecorView final View host = mView; ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... //measure过程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... //layout过程 performLayout(lp, mWidth, mHeight); ... //绘制过程 performDraw();} 代码比较多，只提取出3个主要的方法，这几个方法主要执行View的主要绘制流程：测量，布局和绘制。 以上代码其实就是将我们的顶级view-&gt;DecorView添加到窗口上，关联到ViewRootImpl中，并调用requestLayout(); 方法请求绘制，最后到了performTraversals方法中执行performMeasure，performLayout，performDraw真正的开始绘制。 下面就分别来看一下这三个方法。1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { if (mView == null) { return; } Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 可以看到这里调用了mView的measure方法，这个mView就是我们的前面add进来的DecorView。它是一个FrameLayout。点进去查看123456789101112131415161718192021public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ...}protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } 首先我们看到点进来之后到了View这个类中，measure这个方法时final类型的，所以不能被重写，因此就算他是FrameLayout最终也是在View类中执行measure的方法。 measure方法中又调用了onMeasure方法，然后直接调用setMeasuredDimension方法，最后调用了setMeasuredDimensionRaw方法。这些方法时干什么的呢， 首先我们先找到传入的参数widthMeasureSpec和heightMeasureSpec了解这两个参数的作用。 这两个参数是怎么来的呢，回到我们上面的performTraversals()方法，可以看到int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 第一个参数表示窗口的宽度，第二个参数表示当前view也就是DectorView的LayoutParams12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec;} 可以看到根据我们View设置的MATCH_PARENT还是WRAP_CONTENT等返回了一个通过MeasureSpec.makeMeasureSpec方法返回了一个int类型的值measureSpec，那它代表什么呢? 我们在测量View的时候需要知道两点： 第一点View的测量模式 第二点View的尺寸 measureSpec表示一个32的整数值，其高两位代表测量模式SpecMode,底30位表示该测量模式下的尺寸SpecSize。 我们进入MeasureSpace类可以看到3个常量123456789101112131415/** * 表示父容器不对子容器进行限制，子容器可以是任意大小， * 一般是系统内部使用 */public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;/** * 精准测量模式，当view的layout_width 或者 layout_height指定为固定值值 * 或者为match_parent的时候生效，这时候view的测量值就是SpecSize */public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;/** * 父容器指定一个固定的大小，子容器可以使不超过这个值的任意大小 * 对应我们的wrap_content */public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; 对于DecorView这个顶级View来说，它的MeasureSpec 由窗口的尺寸和其自身的LayoutParams决定。 我们在回到measure方法中查看onMeasure方法，我们知道measure方法是个final方法不能被子类重写，不过onMeasure方法就没这个限制了，DecorView继承自FrameLayout,所以我们进入FrameLayout中查看它的onMeasure方法1234567891011121314151617181920212223242526272829303132333435363738394041protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { ... for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { //循环测量子view measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } ... // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } //设置自身的宽高 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); } 这里找出所有的子View，然后循环调用measureChildWithMargins方法测量子view的宽高，之后调用setMeasuredDimension确定自己的宽高1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //获取子控件的测量规格 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);} 先获取子控件的宽高的测量规格，然后调用子控件的measure方法传入测量规格，子控件的测量规格是怎么获取的呢,点进去看到getChildMeasureSpec这个方法是在ViewGroup类中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 /** * @param spec 父控件的测量规格 * @param padding 父控件已经占用的大小（减去padding和margin） * @param childDimension 子控件LayoutParams中的尺寸 * @return a MeasureSpec integer for the child */public static int getChildMeasureSpec(int spec, int padding, int childDimension) { //父控件的测量模式 int specMode = MeasureSpec.getMode(spec); //父控件的尺寸 int specSize = MeasureSpec.getSize(spec); //子容器可用大小要减去父view的padding和子view的margin int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // 如果父控件是精准尺寸，也就是父控件知道自己的大小 case MeasureSpec.EXACTLY: //如果子view设置了尺寸比如100dp,那么测量大小就是100dp if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //如果子view设置的MATCH_PAREN想要沾满父view //父view是精准模式，那么把父view的size给它 resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //如果子view设置的WRAP_CONTENT，那么它想随意决定自己的大小 //你可以随意玩，但是不能大于父控件的大小， //那么暂时把父view的size给它 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 如果父控件是最大模式，也就是父控件也不知道自己的大小 case MeasureSpec.AT_MOST: //子控件设定了具体值 if (childDimension &gt;= 0) { //那就返回这个具体值 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //子view想和父view一样大，但是父view也不知道自己多大 //把暂时父view的size给它，约束它不能超过父view resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //子view想要自己确定尺寸 //不能大于父view的size resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父view是不确定的，一般是系统调用开发中不用 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 对于普通的view来说它的MeasureSpec由其父view的MeasureSpec和自身的LayoutParams来决定 parentSpecMode/childLayoutParams EXACTLY AT_MOST UNSPECIFIED dp/px EXACTLY / chileSize EXACTLY / chileSize EXACTLY / chileSize match_parent EXACTLY / parentSize AT_MOST /parentSize 0 wrap_content AT_MOST/ parentSize AT_MOST /parentSize 0 当view采用固定宽高的时候，不管父容器是什么模式，子view的MeasureSpec都是精确模式，并且大小就是其LayoutParams中设置的大小 当view的宽或高是match_parent的时候，如果父容器是精准模式，那么子view的也是精准模式，其大小是父view的剩余空间，如果父容器是最大模式，那么子view也是最大模式，其大小暂时设为父view的大小并不能超过父view的大小。 当view的宽或高是wrap_content的时候，不管父容器是什么模式，子view总是最大化，并且不超过父容器的剩余空间。 OK总结一下 ViewGroup执行measure方法-&gt;里面通过onMeasure方法递归测量子控件的宽高，测量完后通过setMeasuredDimension调用setMeasuredDimensionRaw方法最终保存自己的宽高。 View执行measure-&gt;onMeasure测量自己-&gt;测量完后通过setMeasuredDimension调用setMeasuredDimensionRaw方法最终保存自己的宽高 我们回到view的onMeasure方法1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 可以看到它在调用setMeasuredDimension传参的的时候调用了getDefaultSize方法12345678910111213141516public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result; } 这个逻辑很简单，首先UNSPECIFIED我们不用管一般系统用，然后我们看到AT_MOST和EXACTLY最后的结果是一样的都赋值为specSize，这个specSize就是view测量后的大小。也就是getSuggestedMinimumWidth和getSuggestedMinimumHeight两个方法返回的值。123protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); } 从上面可以看出如果view没有设置背景，则返回mMinWidth，反之则宽度为mMinWidth和背景宽度的最大值。mMinWidth对应我们xml中设置的android:minWidth属性值，如果没设置则为0，mBackground.getMinimumWidth()则是返回的Drawable的原始宽度。 从上面的getDefaultSize方法我们可以得出一个结论，当我们直接继承view自定义控件的时候，需要重写其onMeasure方法，然后设置其wrap_content时候的大小，否则即便我们在布局中使用wrap_content，实际情况也相当于match_parent。原因可以从上面的表中看到，如果一个view设置了wrap_content，那么其测量模式是AT_MOST,在这种模式下view的宽高都等于父容器的剩余空间大小。 那怎么解决上面的问题呢？看一个重写onMeasure的例子123456789101112131415161718192021222324protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 宽的测量规格 int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); // 宽的测量尺寸 int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); // 高度的测量规格 int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); // 高度的测量尺寸 int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); //根据View的逻辑得到，比如TextView根据设置的文字计算wrap_content时的大小。 //这两个数据根据实现需求计算。 int wrapWidth,wrapHeight; // 如果是是AT_MOST则对哪个进行特殊处理 if(widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, wrapHeight); }else if(widthSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(wrapWidth, heightSpecSize); }else if(heightSpecMode == MeasureSpec.AT_MOST){ setMeasuredDimension(widthSpecSize, wrapHeight); }} 我们只需给view指定一个默认的宽高，并在AT_MOST的时候设置宽高即可，默认宽高的大小根据实际情况来 OK，measure的方法就看完了下面来看layout的流程，这个比measure简单多了12345678//lp顶层布局的布局属性，顶层布局的宽和高private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { ... final View host = mView; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); } 这里吧mView赋值给host然后调用了其layout方法，我们知道mView其实就是DecorView。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame来确定4个顶点的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { //父容器确定子view的位置 onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) { if(mRoundScrollbarRenderer == null) { mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); } } else { mRoundScrollbarRenderer = null; } mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } final boolean wasLayoutValid = isLayoutValid(); mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; if (!wasLayoutValid &amp;&amp; isFocused()) { mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS; if (canTakeFocus()) { // We have a robust focus, so parents should no longer be wanting focus. clearParentsWantFocus(); } else if (getViewRootImpl() == null || !getViewRootImpl().isInLayout()) { clearFocusInternal(null, /* propagate */ true, /* refocus */ false); clearParentsWantFocus(); } else if (!hasParentWantsFocus()) { // original requestFocus was likely on this view directly, so just clear focus clearFocusInternal(null, /* propagate */ true, /* refocus */ false); } } else if ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) != 0) { mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS; View focused = findFocus(); if (focused != null) { if (!restoreDefaultFocus() &amp;&amp; !hasParentWantsFocus()) { focused.clearFocusInternal(null, /* propagate */ true, /* refocus */ false); } } } if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) { mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT; notifyEnterOrExitForAutoFillIfNeeded(true); } } layout的流程首先通过setFrame方法设定view的4个顶点的位置，4个顶点确定了，view在父容器中的位置也就确定了，然后调用onLayout方法来确定子元素的位置。onLayout需要不同的ViewGroup去自己实现比如LinearLayout和RelativeLayout的实现是不同的。 OK，layout也看完了下面看最后一步Draw的流程1234567891011121314151617private void performDraw() { ... boolean canUseAsync = draw(fullRedrawNeeded); ...}private boolean draw(boolean fullRedrawNeeded) { ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) { ...} private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets) { ... mView.draw(canvas); ... } 通过一系列的跳转，我们终于找到关键方法mView.draw(canvas)，从这里就进入了view中的draw方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; //绘制背景 if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // 绘制自己 if (!dirtyOpaque) onDraw(canvas); // 绘制子view dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // 绘制装饰 前景滚动条(foreground, scrollbars) onDrawForeground(canvas); // 绘制默认的焦点突出显示 drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we're done... return; } ... view的绘制过程上面注释已经写清楚了 绘制背景 (background.draw(canvas)) 绘制自己 (onDrow) 绘制子view（dispatchDrow） 绘制装饰（前景、滚动条） 如果我们是自定义view，就去实现onDraw方法，如果我们是自定义ViewGroup,那就去实现dispatchDraw方法，dispatchDraw方法中会遍历子view调用子view的draw方法。 到这里draw方法就看完了，view的绘制流程也执行完毕！ ps: view中有个特殊的方法setWillNotDraw12345678910111213/** * If this view doesn't do any drawing on its own, set this flag to * allow further optimizations. By default, this flag is not set on * View, but could be set on some View subclasses such as ViewGroup. * * Typically, if you override {@link #onDraw(android.graphics.Canvas)} * you should clear this flag. * * @param willNotDraw whether or not this View draw on its own */ public void setWillNotDraw(boolean willNotDraw) { setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); } 从注释中看出来，如果一个view不需要绘制任何东西，这个标志位设置为true之后，系统会进行相应的优化。 默认情况下，view没有启动这个标志位，但是ViewGroup是会默认启动这个标志位的。所以当我们继承ViewGroup的时候并且明确知道需要通过onDraw来绘制内容的时候，我们需要显示的关闭这个标志位。","link":"/2019/03/24/technology/UI绘制流程-View的绘制流程/"},{"title":"Activity启动流程(上)","text":"Android看源码的两个网站： Android看源码的两个网站： https://www.androidos.net.cn/ http://androidxref.com/ Activity启动部分的代码真的很多，断断续续看了一个多星期，而且看这种frameworks层的代码不像在AndroidStudio中看代码方便可以直接点一个方法或者类逃过去，只能通过上面的网站看代码，用到哪个类只能一个一个的去找，所以一定要有耐心，等看完之后对启动流程这块有一个宏观的认识之后也挺有成就感的，由于篇幅太长分成两篇。 OK从我们最熟悉的startActivity(intent)开始1234567public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { startActivityForResult(intent, -1); } } 不管有没有传参数最终都调用了startActivityForResult方法12345678910111213141516171819202122232425public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { mParent.startActivityFromChild(this, intent, requestCode); } } } 首先判断mParent == null，mParent 是当前Activity的父类，第一次启动的时候mParent为空，所以走上面为空的逻辑可以看到调用了mInstrumentation.execStartActivity 这里传入参数有两个比较重要 mMainThread.getApplicationThread()是ApplicationThread的本地IBinder对象，用来进程间通讯。 mToken是Binder的代理对象，指向ActivityManagerService，告诉系统谁要启动这个activity Instrumentation中文翻译为仪表器，每个Activity都持有一个Instrumentation对象，用来监控应用程序和系统的交互，每个进程中只有一个Instrumentation实例。 继续查看Instrumentation中的execStartActivity方法。源码位置在/frameworks/base/core/java/android/app/Instrumentation.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) { intent.putExtra(Intent.EXTRA_REFERRER, referrer); } if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) { result = am.onStartActivity(intent); } if (result != null) { am.mHits++; return result; } else if (am.match(who, null, intent)) { am.mHits++; if (am.isBlocking()) { return requestCode &gt;= 0 ? am.getResult() : null; } break; } } } } try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(\"Failure from system\", e); } return null; } ActivityMonitor，Activity监视器，监视的特定意图类型的信息不用管，然后走到ActivityManager.getService().startActivity，看一下ActivityManager.getService()位置在frameworks/base/core/java/android/app/ActivityManager.java12345678910111213public static IActivityManager getService() { return IActivityManagerSingleton.get(); } private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; AMS 全称 ActivityManagerService 服务端对象，负责管理系统中所有的activity，系统创建的时候就创建了 getService调用了IActivityManagerSingleton.get()方法，getService调用了IActivityManagerSingleton是一个Singleton类，从系统中获取AMS这个binder对象，然后转换为其代理对象IActivityManager返回。这里是使用了AIDL实现的。 回到Instrumentation的execStartActivity方法，最终调用了IActivityManager的startActivity方法。IActivityManager是AMS在本地的代理，所以其实是调用了ActivityManagerService的startActivity方法. 源码位置在frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId()); } @Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/); } public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) { enforceNotIsolatedCaller(\"startActivity\"); //检查调用者的权限 userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\"); // TODO: Switch to user app stacks here. return mActivityStartController.obtainStarter(intent, \"startActivityAsUser\") .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute(); } 这里一连串的调用，startActivityAsUser方法比startActivity多了一个参数userId,AMS会根据这个UserId来确定调用者的权限，最终通过ActivityStartController.obtainStarter这个方法获得一个包含activity所有信息的ActivityStarter对象并调用其execute方法。 ActivityStarter，搜集逻辑并决定如何把intent和flag转换成activity。 进入execute方法位置 /frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456789101112131415161718192021222324252627//根据前面提供的参数来启动activity int execute() { try { if (mRequest.mayWait) { return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup); } else { return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup); } } finally { onExecutionComplete(); } } 上面startActivityAsUser方法中调用了setMayWait方法，所以 mRequest.mayWait是true的,所以我们走startActivityMayWait方法。12345ActivityStarter setMayWait(int userId) { mRequest.mayWait = true; mRequest.userId = userId; return this; } startActivityMayWait方法非常长，只看主要部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup) { ...... int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason, allowPendingRemoteAnimationRegistryLookup); ...... mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[0]); return res; } } private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) { ...... //获取进程记录 if (caller != null) { callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) { //获取进程的pid和uid并赋值 callingPid = callerApp.pid; callingUid = callerApp.info.uid; } else { Slog.w(TAG, \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting: \" + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; } } ...... //创建将要启动的activity的记录类 ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, checkedOptions, sourceRecord); if (outActivity != null) { outActivity[0] = r; } ...... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity); } 判断传过来的IApplicationThread是不是null,然后通过AMS的getRecordForAppLocked方法得到一个ProcessRecord对象callerApp，ProcessRecord用于描述一个应用程序进程。 创建ActivityRecord类，ActivityRecord用来描述一个activity，然后赋值给outActivity数组的第0位，最后继续调用重载的startActivity，并传入outActivity数组 123456789101112131415161718192021222324private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { int result = START_CANCELED; try { mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); } finally { // If we are not able to proceed, disassociate the activity from the task. Leaving an // activity in an incomplete state can lead to issues, such as performing operations // without a window container. final ActivityStack stack = mStartActivity.getStack(); if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) { stack.finishActivityLocked(mStartActivity, RESULT_CANCELED, null /* intentResultData */, \"startActivity\", true /* oomAdj */); } mService.mWindowManager.continueSurfaceLayout(); } postStartActivityProcessing(r, result, mTargetStack); return result; } 这个startActivity方法调用了startActivityUnchecked方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); //处理Activity的启动模式，确定Activity的启动模式 computeLaunchingTaskFlags(); computeSourceStack(); mIntent.setFlags(mLaunchFlags); ActivityRecord reusedActivity = getReusableIntentActivity(); int preferredWindowingMode = WINDOWING_MODE_UNDEFINED; int preferredLaunchDisplayId = DEFAULT_DISPLAY; if (mOptions != null) { preferredWindowingMode = mOptions.getLaunchWindowingMode(); preferredLaunchDisplayId = mOptions.getLaunchDisplayId(); } // windowing mode and preferred launch display values from {@link LaunchParams} take // priority over those specified in {@link ActivityOptions}. if (!mLaunchParams.isEmpty()) { if (mLaunchParams.hasPreferredDisplay()) { preferredLaunchDisplayId = mLaunchParams.mPreferredDisplayId; } if (mLaunchParams.hasWindowingMode()) { preferredWindowingMode = mLaunchParams.mWindowingMode; } } if (reusedActivity != null) { //当设置NEW_TASK或者CLEAR_TASK模式的时候将重用任务 //但是仍然违反锁定模式任务，因为该任务将要被清除 // 该设备将要离开锁定任务 if (mService.getLockTaskController().isLockTaskModeViolation(reusedActivity.getTask(), (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) { Slog.e(TAG, \"startActivityUnchecked: Attempt to violate Lock Task Mode\"); return START_RETURN_LOCK_TASK_MODE_VIOLATION; } //如果我们清除顶部并重新设定为默认启动模式 // ({@code LAUNCH_MULTIPLE}) activity. The existing activity will be finished. final boolean clearTopAndResetStandardLaunchMode = (mLaunchFlags &amp; (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)) == (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) &amp;&amp; mLaunchMode == LAUNCH_MULTIPLE; //根据Activity启动模式来设置栈 if (mStartActivity.getTask() == null &amp;&amp; !clearTopAndResetStandardLaunchMode) { mStartActivity.setTask(reusedActivity.getTask()); } if (reusedActivity.getTask().intent == null) { // This task was started because of movement of the activity based on affinity... // Now that we are actually launching it, we can assign the base intent. reusedActivity.getTask().setIntent(mStartActivity); } // 这将交付一个新的intent if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || isDocumentLaunchesIntoExisting(mLaunchFlags) || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) { final TaskRecord task = reusedActivity.getTask(); //FLAG_ACTIVITY_CLEAR_TOP模式下把所有activity移除 final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity, mLaunchFlags); if (reusedActivity.getTask() == null) { reusedActivity.setTask(task); } if (top != null) { if (top.frontOfTask) { // Activity aliases may mean we use different intents for the top activity, // so make sure the task now has the identity of the new intent. top.getTask().setIntent(mStartActivity); } //当栈顶activity可以服用时，传入当前栈顶的activity deliverNewIntent(top); } } mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity); reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity); final ActivityRecord outResult = outActivity != null &amp;&amp; outActivity.length &gt; 0 ? outActivity[0] : null; // 如果当前重用的activity不为null,并且是活的，就把它设为结果 if (outResult != null &amp;&amp; (outResult.finishing || outResult.noDisplay)) { outActivity[0] = reusedActivity; } if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) { // We don't need to start a new activity, and the client said not to do anything // if that is the case, so this is it! And for paranoia, make sure we have // 正确恢复顶部的 activity. resumeTargetStackIfNeeded(); return START_RETURN_INTENT_TO_CALLER; } if (reusedActivity != null) { setTaskFromIntentActivity(reusedActivity); if (!mAddingToTask &amp;&amp; mReuseTask == null) { // We didn't do anything... but it was needed (a.k.a., client don't use that // intent!) And for paranoia, make sure we have correctly resumed the top activity. resumeTargetStackIfNeeded(); if (outActivity != null &amp;&amp; outActivity.length &gt; 0) { outActivity[0] = reusedActivity; } return mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP; } } } if (mStartActivity.packageName == null) { final ActivityStack sourceStack = mStartActivity.resultTo != null ? mStartActivity.resultTo.getStack() : null; if (sourceStack != null) { sourceStack.sendActivityResultLocked(-1 /* callingUid */, mStartActivity.resultTo, mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED, null /* data */); } ActivityOptions.abort(mOptions); return START_CLASS_NOT_FOUND; } // 如果即将启动的activity跟栈顶的activity相同，我们需要确定它的启动模式. final ActivityStack topStack = mSupervisor.mFocusedStack; final ActivityRecord topFocused = topStack.getTopActivity(); final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop); final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null &amp;&amp; top.realActivity.equals(mStartActivity.realActivity) &amp;&amp; top.userId == mStartActivity.userId &amp;&amp; top.app != null &amp;&amp; top.app.thread != null &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0 || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)); if (dontStart) { // For paranoia, make sure we have correctly resumed the top activity. topStack.mLastPausedActivity = null; if (mDoResume) { mSupervisor.resumeFocusedStackTopActivityLocked(); } ActivityOptions.abort(mOptions); if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) { // We don't need to start a new activity, and the client said not to do // anything if that is the case, so this is it! return START_RETURN_INTENT_TO_CALLER; } deliverNewIntent(top); // Don't use mStartActivity.task to show the toast. We're not starting a new activity // but reusing 'top'. Fields in mStartActivity may not be fully initialized. mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredWindowingMode, preferredLaunchDisplayId, topStack); return START_DELIVERED_TO_TOP; } boolean newTask = false; final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTask() : null; // Should this be considered a new task? int result = START_SUCCESS; if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) { newTask = true; result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, topStack); } else if (mSourceRecord != null) { result = setTaskFromSourceRecord(); } else if (mInTask != null) { result = setTaskFromInTask(); } else { // This not being started from an existing activity, and not part of a new task... // just put it in the top task, though these days this case should never happen. setTaskToCurrentTopOrCreateNewTask(); } if (result != START_SUCCESS) { return result; } mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName, mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId); mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent, mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid)); if (newTask) { EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, mStartActivity.userId, mStartActivity.getTask().taskId); } ActivityStack.logStartActivity( EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask()); mTargetStack.mLastPausedActivity = null; mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, mStartActivity); mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions); //根据Activity的启动模式来判断是直接插入已存在的栈顶还是新开栈插入 //判断是否需要activity可见 if (mDoResume) { final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) { //如果activity还没有聚焦就不能让它成为resume可以让它成为start mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mService.mWindowManager.executeAppTransition(); } else { //如果是聚焦的就移到前台 if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) { mTargetStack.moveToFront(\"startActivityUnchecked\"); } mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); } } else if (mStartActivity != null) { mSupervisor.mRecentTasks.add(mStartActivity.getTask()); } mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack); mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode, preferredLaunchDisplayId, mTargetStack); return START_SUCCESS; } startActivityUnchecked方法主要用来管理栈相关的逻辑，计算activity的启动模式有关的flag，将目标activity置于栈顶，执行目标activity的resume流程，经过一系列的判断，最后都会走入mSupervisor.resumeFocusedStackTopActivityLocked这个方法。位置在/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123456789101112131415161718192021boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) { if (!readyToResume()) { return false; } //传入的当前栈不为null并且是获取焦点 if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) { return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); } //获取要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || !r.isState(RESUMED)) { mFocusedStack.resumeTopActivityUncheckedLocked(null, null); } else if (r.isState(RESUMED)) { // Kick off any lingering app transitions form the MoveTaskToFront operation. mFocusedStack.executeAppTransition(targetOptions); } return false; } 如果传入的targetStack不为null，并且是获取焦点的，就调用它的resumeTopActivityUncheckedLocked方法，如果是null,并且能拿到要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord就调用mFocusedStack的resumeTopActivityUncheckedLocked方法。总之最后进入resumeTopActivityUncheckedLocked方法。 位置/frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011121314151617181920212223boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // 避免递归调用 mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); //当恢复顶部activity时，它可能需要暂停 final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) { checkReadyForSleep(); } } finally { mStackSupervisor.inResumeTopActivity = false; } return result; } 上面的方法中返回的结果是调用了resumeTopActivityInnerLocked方法,这个方法代码太多，只看主要的123456789101112131415161718192021222324252627private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { ...... //获取需要启动的activity final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); ...... //暂停栈中所有的activity boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false); //让现在正在显示的activity进入暂停状态，虽然这里传入的是next，跟进去后里面暂停的activity还是通过mResumedActivity获得的 if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Pausing \" + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, next, false); } ...... //next.app和next.app.thread分别代表ProcessRecord和IApplicationThread对象， //如果这两个都不为null说明目标activity所属进程已经存在 //可以直接执行resume流程 if (next.app != null &amp;&amp; next.app.thread != null) { ... mStackSupervisor.scheduleResumeTopActivities(); }else{ //当进程不存在的时候执行下面方法启动activity mStackSupervisor.startSpecificActivityLocked(next, true, true); } } resumeTopActivityInnerLocked这个方法就是把现在正在显示的activity暂停，把将要启动的activity变成可见。既正在显示的pause，将要启动的resume。 所以现在分成两部分看，先看旧的activity暂停在看新的activity显示 12345678910111213141516171819202122232425262728293031323334 final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean pauseImmediately) { ...... //当前前台的activity ActivityRecord prev = mResumedActivity; ...... //检测prev所对应的进程是否创建，正常情况下是是肯定存在的 if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Enqueueing pending pause: \" + prev); try { EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev), prev.shortComponentName, \"userLeaving=\" + userLeaving); mService.updateUsageStats(prev, false); //mService是ActivityManagerService //PauseActivityItem封装了Activity的pause请求，它继承自ActivityLifecycleItem //ActivityLifecycleItem继承自ClientTransactionItem mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately)); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, \"Exception thrown during pause\", e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ......} 上面的代码中mService是ActivityManagerService，它的getLifecycleManager()返回一个ClientLifecycleManager对象，这个类是android9.0新加入的工具类，用来辅助管理activity的生命周期，它会发从EXECUTE_TRANSACTION到ActivityThread.H里面继续处理。 /frameworks/base/services/core/java/com/android/server/am/ClientLifecycleManager.java 1234567891011121314151617 void scheduleTransaction(@NonNull IApplicationThread client, @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest) throws RemoteException { final ClientTransaction clientTransaction = transactionWithState(client, activityToken, stateRequest); scheduleTransaction(clientTransaction); } void scheduleTransaction(ClientTransaction transaction) throws RemoteException { final IApplicationThread client = transaction.getClient(); transaction.schedule(); if (!(client instanceof Binder)) { transaction.recycle(); } }/frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java public void schedule() throws RemoteException { mClient.scheduleTransaction(this); } mClient是IApplicationThread，这里使用了Binder通信，从源码的位置我们也能看出来从/frameworks/base/services到/frameworks/base/core/从服务进程到了应用程序进程。 ApplicationThread是ActivityThread的内部类1234567891011public final class ActivityThread extends ClientTransactionHandler { ...... private class ApplicationThread extends IApplicationThread.Stub { ...... public void scheduleTransaction(ClientTransaction transaction) throws RemoteException { ActivityThread.this.scheduleTransaction(transaction); } ...... } } ...... ApplicationThread继承了IApplicationThread.Stub，也就是IApplicationThread这个AIDL接口在service端（也就是应用端）的实现类，同时它是ActivityThread的内部类，然后调用了 ActivityThread中的scheduleTransaction(transaction)方法。ActivityThread继承了ClientTransactionHandler这个方法在ClientTransactionHandler中 /frameworks/base/core/java/android/app/ClientTransactionHandler.java 1234void scheduleTransaction(ClientTransaction transaction) { transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); } 上面的方法将transaction进行预处理，然后封装成一个消息发从出去，sendMessage是个抽象方法，实现类在其子类ActivityThread中 1234567891011121314151617181920212223242526void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } private void sendMessage(int what, Object obj, int arg1) { sendMessage(what, obj, arg1, 0, false); } private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } mH是一个H类class H extends Handler {...}H类是继承自Handler，所以它也是个Handler，那么具体实现就是在其handleMessage方法中了 123456789101112131415public void handleMessage(Message msg) { ... switch (msg.what) { ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); if (isSystem()) { //系统流程中的客户端事务在客户端回收 // instead of ClientLifecycleManager to avoid being cleared before this transaction.recycle(); } break; ... } 执行了mTransactionExecutor的execute方法，mTransactionExecutor是一个TransactionExecutor 类型的成员变量，用来执行多步骤事物。 /frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java12345678910public void execute(ClientTransaction transaction) { final IBinder token = transaction.getActivityToken(); log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); log(\"End resolving transaction\"); } 前面看过的ClientLifecycleManager类中在封装ClientTransaction 的时候，有transactionWithState和transactionWithCallback两个方法，我们当时追的代码是执行的transactionWithState这个方法，所以此处executeCallbacks是没法执行回调的，executeLifecycleState会处理activity的pause请求1234567891011121314151617181920212223242526272829303132333435 private void executeLifecycleState(ClientTransaction transaction) { //从前面代码中知道lifecycleItem就是PauseActivityItem final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest(); if (lifecycleItem == null) { // No lifecycle request, return early. return; } log(\"Resolving lifecycle state: \" + lifecycleItem); final IBinder token = transaction.getActivityToken(); //通过token获取activity的信息 final ActivityClientRecord r = mTransactionHandler.getActivityClient(token); if (r == null) { // Ignore requests for non-existent client records for now. return; } // 检查activity的当前状态是否直接切换到transaction请求状态， //如果存在中间状态，需要完成这些中间状态的切换 //这里是resume状态到pause状态，中间没有别的状态，所以其实没执行什么 cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */); //lifecycleItem是PauseActivityItem lifecycleItem.execute(mTransactionHandler, token, mPendingActions); lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions); } //r和finish是一样的private void cycleToPath(ActivityClientRecord r, int finish, boolean excludeLastState) { final int start = r.getLifecycleState(); log(\"Cycle from: \" + start + \" to: \" + finish + \" excludeLastState:\" + excludeLastState); final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState); performLifecycleSequence(r, path); } 因为lifecycleItem是PauseActivityItem，所以execute方法是在PauseActivityItem中执行/frameworks/base/core/java/android/app/servertransaction/PauseActivityItem.java1234567public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions, \"PAUSE_ACTIVITY_ITEM\"); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); } 上面调用了ClientTransactionHandler中的handlePauseActivity方法public abstract void handlePauseActivity这个方法是个抽象方法，所以由它的子类ActivityThread类来实现123456789101112131415161718public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, PendingTransactionActions pendingActions, String reason) { ActivityClientRecord r = mActivities.get(token); if (r != null) { if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(r, finished, reason, pendingActions); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } mSomeActivitiesChanged = true; } } ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;()mActivities是一个ArrayMap，键是匿名实体列ActivityRecord.Token，主要用来记录一个activity在AMS进程中的ActivityClientRecord对象。可以看出它是维护了一个activity在AMS进程和应用进程之间的映射关系12345678910111213141516private Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason, PendingTransactionActions pendingActions) { ... performPauseActivityIfNeeded(r, reason); ... }private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) { if (r.paused) { return; } ... //当不是pause状态时委托 mInstrumentation执行pause mInstrumentation.callActivityOnPause(r.activity); ...} /frameworks/base/core/java/android/app/Instrumentation.java123public void callActivityOnPause(Activity activity) { activity.performPause(); } frameworks/base/core/java/android/app/Activity.java1234567891011121314final void performPause() { mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); writeEventLog(LOG_AM_ON_PAUSE_CALLED, \"performPause\"); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) { throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); }} 这里我们看到了我们熟悉是 onPause() 方法，到此旧的activity就暂停了，下一篇在看新的activity的启动流程。","link":"/2019/03/06/technology/Activity启动流程-上/"},{"title":"Activity启动流程(下)","text":"继续上一篇Activity启动流程（上）下面继续新activity的启动流程mStackSupervisor.startSpecificActivityLocked(next, true, true); /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java123456789101112131415161718192021222324252627void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // 获取要启动activity的进程信息 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); getLaunchTimeTracker().setLaunchTime(r); //判断进程是否是null if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) { app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode, mService.mProcessStats); } realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); } } //如果进程是null，告诉AMS启动进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true); } 上面代码：判断要启动的activity的进程是否存在，如果存在就执行realStartActivityLocked方法，如果不存在就调用AMS的startProcessLocked方法创建新的进程。也就是说我们的app是否已经启动，如果启动了就执行realStartActivityLocked方法，如果没启动比如点击应手机用图标后，就执行startProcessLocked创建应用的进程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); }final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) { app = getProcessRecordLocked(processName, info.uid, keepIfLarge); ... final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride); ... return success ? app : null; }private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) { startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */); } @GuardedBy(\"this\")private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride) { return startProcessLocked(app, hostingType, hostingNameStr, false /* disableHiddenApiChecks */, abiOverride); }private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) { ...... final String entryPoint = \"android.app.ActivityThread\"; return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); }private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) { //新进程的启动过程是否需要异步执行（默认值为true） if (mConstants.FLAG_PROCESS_START_ASYNC) { ... final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime); synchronized (ActivityManagerService.this) { handleProcessStartedLocked(app, startResult, startSeq); } ... }else{ ... final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false); ... } return app.pid &gt; 0; } 上面的代码经过一系列的startProcessLocked的重载方法的调用，最后调用到startProcess方法12345678910111213141516171819202122232425262728private ProcessStartResult startProcess(String hostingType, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) { try { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); final ProcessStartResult startResult; if (hostingType.equals(\"webview_service\")) { startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, new String[] {PROC_START_SEQ_IDENT + app.startSeq}); } else { startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, new String[] {PROC_START_SEQ_IDENT + app.startSeq}); } checkTime(startTime, \"startProcess: returned from zygote!\"); return startResult; } finally { Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } } hostingType代表我们是使用何种方式启动的，我们这里不是webview_service，所以走else中的方法Process.start /frameworks/base/core/java/android/os/Process.java123456789101112131415public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) { return zygoteProcess.start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs); } start方法通过Socket通信，把新进程的创建请求交给zygote进程处理。zygoteProcess是ZygoteProcess对象/frameworks/base/core/java/android/os/ZygoteProcess.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); } } private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean startChildZygote, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(mLock) { ...... //计算并配置启动进程的各种参数，之后调用下面方法 //第一个参数根据abi来选择跟32位的zygote还是64位的zygote进程通信 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); }private static Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { //如果有任何格式的参数错误尽早抛出异常 int sz = args.size(); for (int i = 0; i &lt; sz; i++) { if (args.get(i).indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); } } final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? Process.ProcessStartResult result = new Process.ProcessStartResult(); result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(\"fork() failed\"); } return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } }} 到这里result.pid = inputStream.readInt() 新进程创建成功并返回该进程就有了它自己的pid，下面就是这个新的应用进程启动activity 上面的方法我们知道了最终创建了一个新的进程并返回了新进程的pid,那么这个新的进程到底是怎么创建的呢 看一下上面startViaZygote这个方法调用zygoteSendArgsAndGetResult方法传入的第一个参数openZygoteSocketIfNeeded(abi)，这里是根据不同的cpu开启socket通信。也就是说AMS是通过socket跟zygote进程通信的。 看一下Process类的几个成员变量/frameworks/base/core/java/android/os/Process.java1234567891011121314public class Process { ... public static final String ZYGOTE_SOCKET = \"zygote\"; public static final String SECONDARY_ZYGOTE_SOCKET = \"zygote_secondary\"; ... public static final ZygoteProcess zygoteProcess = new ZygoteProcess(ZYGOTE_SOCKET, SECONDARY_ZYGOTE_SOCKET); ....} public ZygoteProcess(LocalSocketAddress primarySocket, LocalSocketAddress secondarySocket) { mSocket = primarySocket; mSecondarySocket = secondarySocket; } 上面是两个socket服务，先连接第一个连不上在连接第二个尽可能保证服务正常然后看openZygoteSocketIfNeeded(abi)是怎连接socket的12345678private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx { ... primaryZygoteState = ZygoteState.connect(mSocket); ... secondaryZygoteState = ZygoteState.connect(mSecondarySocket);} ZygoteState是ZygoteProcess的一个内部类/frameworks/base/core/java/android/os/ZygoteProcess.java 看起静态连接方法123456789101112131415161718192021222324252627public static ZygoteState connect(LocalSocketAddress address) throws IOException { DataInputStream zygoteInputStream = null; BufferedWriter zygoteWriter = null; final LocalSocket zygoteSocket = new LocalSocket(); try { zygoteSocket.connect(address); zygoteInputStream = new DataInputStream(zygoteSocket.getInputStream()); zygoteWriter = new BufferedWriter(new OutputStreamWriter( zygoteSocket.getOutputStream()), 256); } catch (IOException ex) { try { zygoteSocket.close(); } catch (IOException ignore) { } throw ex; } String abiListString = getAbiList(zygoteWriter, zygoteInputStream); Log.i(\"Zygote\", \"Process: zygote socket \" + address.getNamespace() + \"/\" + address.getName() + \" opened, supported ABIS: \" + abiListString); return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter, Arrays.asList(abiListString.split(\",\"))); 通过LocalSocket来连接zygote或者zygote_secondary进程，写出流zygoteWriter 然后回到前面的zygoteSendArgsAndGetResult方法，通过写出流将要创建的信息发送给zygote进程。 那zygote进程是怎么接收这个信息的呢，在Android系统中，所有的应用程序进程以及系统服务进程SystemServer都是由Zygote进程孕育（fork）出来的 /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java Zygote进程在启动的时候，在其main方法中会调用其forkSystemServer方法1234567891011121314151617181920212223public static void main(String argv[]) { ZygoteServer zygoteServer = new ZygoteServer(); ... final Runnable caller; ... Runnable r = forkSystemServer(abiList, socketName, zygoteServer); ... caller = zygoteServer.runSelectLoop(abiList); if (caller != null) { caller.run(); }}private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) { ... if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); } 在创建system_sever的时候会执行waitForSecondaryZygote方法12345678910111213141516171819202122232425 private static void waitForSecondaryZygote(String socketName) { String otherZygoteName = Process.ZYGOTE_SOCKET.equals(socketName) ? Process.SECONDARY_ZYGOTE_SOCKET : Process.ZYGOTE_SOCKET; ZygoteProcess.waitForConnectionToZygote(otherZygoteName); }/frameworks/base/core/java/android/os/ZygoteProcess.javapublic static void waitForConnectionToZygote(String socketName) { final LocalSocketAddress address = new LocalSocketAddress(socketName, LocalSocketAddress.Namespace.RESERVED); waitForConnectionToZygote(address); } //尝试连接Zygote 进程直到超时public static void waitForConnectionToZygote(LocalSocketAddress address) { for (int n = 20; n &gt;= 0; n--) { try { final ZygoteState zs = ZygoteState.connect(address); zs.close(); return; } catch (IOException ioe) {} try { Thread.sleep(1000); } catch (InterruptedException ie) { } } } 可以看到它也会连接到这个socket上，这样就可以跟客户端通信了，在回到上面的main方法中，caller = zygoteServer.runSelectLoop(abiList)caller是一个Runnable，执行它的run方法。其实就是在一个子线程中等待接收客户端发来的信息。 123456789101112131415161718192021222324252627282930313233343536Runnable runSelectLoop(String abiList) { ... ZygoteConnection connection = peers.get(i); final Runnable command = connection.processOneCommand(this); ...}/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.javaRunnable processOneCommand(ZygoteServer zygoteServer) { ... int pid = -1; ... //创建新进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote, parsedArgs.instructionSet, parsedArgs.appDataDir); ... if (pid == 0) { // 我们要创建activity的子进程 zygoteServer.setForkChild(); zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.startChildZygote); } else { // In the parent. A pid &lt; 0 indicates a failure and will be handled in // handleParentProc. IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, descriptors, serverPipeFd); return null; }} 当pid=0的时候，就是在当前新建的进程中执行12345678910111213141516171819202122private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, boolean isZygote) { ... if (parsedArgs.invokeWith != null) { WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); // Should not get here. throw new IllegalStateException(\"WrapperInit.execApplication unexpectedly returned\"); } else { if (!isZygote) {//是否启动zygote的子进程这里是false return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); } else { return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); } } ... } 这里没有传入没有传入–invoke-with，所以走else，是否启动zygote的子进程这里是false所以走ZygoteInit.zygoteInit123456789101112public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) { if (RuntimeInit.DEBUG) { Slog.d(RuntimeInit.TAG, \"RuntimeInit: Starting application from zygote\"); } Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ZygoteInit\"); RuntimeInit.redirectLogStreams(); RuntimeInit.commonInit(); ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); } 返回了RuntimeInit.applicationInit方法，传入sdk的版本，各种参数和类加载器classloader123456789101112131415161718192021222324252627282930313233343536373839404142434445protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) { nativeSetExitWithoutCleanup(true); VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args = new Arguments(argv); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); return findStaticMain(args.startClass, args.startArgs, classLoader); } protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class&lt;?&gt; cl; try { cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); } Method m; try { m = cl.getMethod(\"main\", new Class[] { String[].class }); } catch (NoSuchMethodException ex) { throw new RuntimeException( \"Missing static main on \" + className, ex); } catch (SecurityException ex) { throw new RuntimeException( \"Problem getting static main on \" + className, ex); } int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( \"Main method is not public and static on \" + className); } return new MethodAndArgsCaller(m, argv); } 这里的className是在上面的ActivityManagerService中的startProcessLocked方法entryPoint一步一步传过来的final String entryPoint = &quot;android.app.ActivityThread&quot;; 所以这里通过反射创建了ActivityThread类并执行其main方法 /frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); ... //为主线程创建一个消息循环对象 Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); //绑定应用程序 thread.attach(false, startSeq); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } ... Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //启动消息循环 Looper.loop();} 创建主线程的Looper对象，绑定应用程序，启动Looper12345678private void attach(boolean system, long startSeq) { ... final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); } ...} ActivityManager.getService()返回的是IActivityManager的binder代理对象，用于应用进程向AMS通信 mgr这个代理对象通过AIDL调用AMS中的attachApplication方法，mAppThread就是需要为应用绑定的ApplicationThread对象 /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 public final void attachApplication(IApplicationThread thread, long startSeq) { synchronized (this) { int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); } }private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) { ... if (app.isolatedEntryPoint != null) { thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs); } else if (app.instr != null) { thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); } else { thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); } ... //检查当前栈顶的activity是否满足要启动的activity if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e); badApp = true; } } ... } app.isolatedEntryPoint很明显我们不是一个隔离的进程，我们是为了创建activity所有走else方法，最终都会进入 thread.bindApplication thread是IApplicationThread的binder对象，也就是AMS通过AIDL调用应用进程的ApplicationThread方法。所以说AMS不直接参与Application的初始化流程，而是配置一些参数之后交给应用自己处理 mStackSupervisor.attachApplicationLocked(app)检查当前栈顶的activity是否是要启动的activity 先看bindApplication方法，这个就是初始化Application/frameworks/base/core/java/android/app/ActivityThread.java12345678910111213141516171819202122232425public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, boolean autofillCompatibilityEnabled) { ... sendMessage(H.BIND_APPLICATION, data); } class H extends Handler { public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) { case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... } } 这里跟前面暂停一个activity一样，发从一个消息，然后去H这个Handler中执行 123456789101112private void handleBindApplication(AppBindData data) { //设置进程名 Process.setArgV0(data.processName); ... app = data.info.makeApplication(data.restrictedBackupMode, null); ... mInstrumentation.callApplicationOnCreate(app); ...}public void callApplicationOnCreate(Application app) { app.onCreate(); } 上面最终执行了Application的onCreate方法 在回到attachApplicationLocked中看mStackSupervisor.attachApplicationLocked(app)方法/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java1234567891011121314151617181920212223242526boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { ... stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList); final ActivityRecord top = stack.topRunningActivityLocked(); ... //需要启动的Activity final ActivityRecord top = stack.topRunningActivityLocked(); final int size = mTmpActivityList.size(); //遍历所有的activity for (int i = 0; i &lt; size; i++) { final ActivityRecord activity = mTmpActivityList.get(i); //如果未启动并且属于当前线程 if (activity.app == null &amp;&amp; app.uid == activity.info.applicationInfo.uid &amp;&amp; processName.equals(activity.processName)) { try { if (realStartActivityLocked(activity, app, top == activity /* andResume */, true /* checkConfig */)) { didSomething = true; } } catch (RemoteException e) { throw e; } } } ...} 这里又看到了realStartActivityLocked这个方法，很熟悉吧，我们在前面startSpecificActivityLocked方法中判断要启动的activity的进程是否存在，如果存在就执行realStartActivityLocked方法，如果不存在就调用AMS的startProcessLocked方法创建新的进程，所以这里我们转了一圈启动了进程之后又回到realStartActivityLocked这个方法来真正的启动一个activity。 /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java12345678910111213141516171819202122232425262728final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ...... // 为Activity的launch创建 transaction final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread, r.appToken); //创建一个LaunchActivityItem对象，并传添加到事物中 clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, mService.isNextTransitionForward(), profilerInfo)); //设置Activity的最终状态 final ActivityLifecycleItem lifecycleItem; if (andResume) { lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward()); } else { lifecycleItem = PauseActivityItem.obtain(); } clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. mService.getLifecycleManager().scheduleTransaction(clientTransaction); ......} 创建一个LaunchActivityItem对象，并传添加到事物中，这里跟前面的pause的流程一样，添加到事物中后，通过ClientLifecycleManager 执行事物。通过ClientLifecycleManager中的scheduleTransaction方法跟前面pause中的是一样的，就不贴出来了。 大体流程就是最后执行到IApplicationThread中的scheduleTransaction方法，又回到ActivityThread中，也就是AMS交给应用进程自己创建activity自己创建，scheduleTransaction中发从了一个message交给H这个handler处理。最终执行到TransactionExecutor中的execute方法 上面代码中clientTransaction.addCallback中传入的是LaunchActivityItem.obtain方法，它返回了一个addCallback中传入的是LaunchActivityItem对象 /frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java12345678910public void execute(ClientTransaction transaction) { final IBinder token = transaction.getActivityToken(); log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); log(\"End resolving transaction\"); } 因为前面代码是addCallback，所以这里执行executeCallbacks方法12345678910111213141516171819202122public void executeCallbacks(ClientTransaction transaction) {//通过前面传的我们知道ClientTransactionItem就是是LaunchActivityItem final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null) { return; } .... final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) { final ClientTransactionItem item = callbacks.get(i); final int postExecutionState = item.getPostExecutionState(); final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r, item.getPostExecutionState()); if (closestPreExecutionState != UNDEFINED) { cycleToPath(r, closestPreExecutionState); } item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ...... }} 首先获得callback然后执行callback的execute方法。这里的callback是LaunchActivityItem对象，LaunchActivityItem只实现了ClientTransactionItem中的execute方法，所以不执行postExecute /frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java12345678910public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client); client.handleLaunchActivity(r, pendingActions, null /* customIntent */); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); } 可以看到这里封装了一个activity客户端记录类，然后执行ClientTransactionHandler中的handleLaunchActivity方法，ClientTransactionHandler 是一个抽象类，ActivityThread继承了它，所以其实又回到了ActivityThread中 1234567public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) { ...... WindowManagerGlobal.initialize(); final Activity a = performLaunchActivity(r, customIntent); ...... } 这里初始化窗口管理器WindowManagerService之后，执行performLaunchActivity方法创建一个activity12345678910111213141516171819202122232425262728293031323334353637private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... //ContextImpl类继承自Context抽象类, ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) {...} ... //检查Application是否存在如果不存在尝试创建 Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... //把ContextImpl的成员变量mOuterContext赋值成activity appContext.setOuterContext(activity); //完成activity大部分成员变量的初始化 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... //要启动的activity是不是持久的，对应Manifest中Application标签的android:persistent属性 if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } //设置 Activity 当前状态为 ON_CREATE r.setState(ON_CREATE);} 拿到类加载器ClassLoader然后委托给mInstrumentation去创建activity，然后初始化成员变量，最后走到mInstrumentation.callActivityOnCreate方法12345public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 执行activity的performCreate方法/frameworks/base/core/java/android/app/Activity.java123456789101112final void performCreate(Bundle icicle) { performCreate(icicle, null); }final void performCreate(Bundle icicle, PersistableBundle persistentState) { ... if (persistentState != null) { onCreate(icicle, persistentState); } else { onCreate(icicle); } ...} 到这里终于看到了我们熟悉的onCreate方法啦！！！别着急还没完呢 回到上面realStartActivityLocked方法中，我们传入的第二个参数是top == activity，很明显最顶层的就是我们要启动的activity，所以这里是true，所以lifecycleItem = ResumeActivityItem.obtain，然后执行了 clientTransaction.setLifecycleStateRequest(lifecycleItem);方法。所以我们上面TransactionExecutor类中的execute方法中的executeLifecycleState(transaction)方法也会执行12345678910public void executeCallbacks(ClientTransaction transaction) { final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null) { return; } ... item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ...} 最终会执行ResumeActivityItem中的execute方法1234567public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\"); client.handleResumeActivity(token, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\"); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); } 跟上面思路一样一样回到ActivityThread中执行handleResumeActivity方法123456789101112131415161718public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... final Activity a = r.activity; ... ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ... a.mWindowAdded = true; wm.addView(decor, l); ... Looper.myQueue().addIdleHandler(new Idler()); } performResumeActivity就是去执行activity的onResume方法，然后创建WindowManager，把DecorView方法WindowManager中。123456789101112131415161718192021222324 public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest, String reason) { ... r.activity.performResume(r.startsNotResumed, reason); r.state = null; r.persistentState = null; r.setState(ON_RESUME); ... }/frameworks/base/core/java/android/app/Activity.java final void performResume(boolean followedByPause, String reason) { //判断是不是restart performRestart(true /* start */, reason); ... mInstrumentation.callActivityOnResume(this); ... } /frameworks/base/core/java/android/app/Instrumentation.java public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); ... } 看到了onResume，至此activity终于启动完成。 下面总结一下： 在我们调用startActivity或者startActityForResult方法的时候，通过Binder通信向ActivityManagerService发送Activity的启动请求 ActivityManagerService收到请求之后，进行合法检测和根据activity的启动模式进行一系列的初始化和准备工作 ActivityManagerService判断当前栈顶的activity是否能够复用，如果能复用并且启动模式为复用栈顶，就通知栈顶activity所在进程回调onNewIntent() 如果不能复用，那么通过Binder通知栈顶的activity执行onPause操作 栈顶的activity执行完onPause之后，开始启动将目标activity，判断目标activity所在进程是否已经启动，如果已经启动，则去执行目标activity的生命周期方法 如果目标activity所在进程没有启动，则通过Socket通知Zygote进程fork出一个新的进程，然后通过传过去的“android.app.ActivityThread”字符串反射出ActivityThread对象，并执行它的main方法初始化主线程。 新进程中的activity依次调用onCreate-&gt;onStart-&gt;onResume方法来完成activity的启动流程。 参考连接： https://blog.csdn.net/hongchi110/article/details/82890180#ch2-5https://blog.csdn.net/cjh_android/article/details/82533321https://blog.csdn.net/lj19851227/article/details/82562115","link":"/2019/03/06/technology/Activity启动流程-下/"},{"title":"Android资料","text":"Anroid学习平时收集的一些资料，方便查找。 学习 安卓资料 BeesAndroid项目旨在通过提供一系列的工具与方法，降低阅读系统源码的门槛，帮助更多的Android工程师理解Andriod系统，掌握Android系统。 算法 为了进阶高级 Android，定下了刷 LeetCode 的计划 计算机速成课 | Crash Course 字幕组 (全40集 2018-5-1 精校完成) 笔试面试知识整理 安卓学习资料 android开发诀窍 tips java算法 数据结构 通用流行框架大全 android 面试资料 亲爱的面试官，这个我可没看过！ 面试 非常全面 掘金翻译计划，翻译掘金上优质的英文文章 Android 开源项目分类汇总 自学Android编程，你需要的都在这里 有哪些 Android 大牛的 blog 值得推荐？ 一些国内 Android 开发者信息，欢迎提交修改 安卓学习自资料(安卓同道总结) 常用Github项目类库(安卓同道总结) Android 开源项目分类汇总(好多好多项目非常全) GitHub Top 100的Android开源库 &gt;AndroidStudyDemo(里面包含很多Android开发中经常用的功能的demo) Android Tips - 填坑手册 史上最全WebView使用 android开源项目分析、学习、仿写，最终理解 android sdk 源码解析——旨在帮助Android开发者更好的学习Android！ Android开发技巧的集合 正在成为史上最全分类 Android 开源代码大全~~~~ 安卓学习笔记 安卓最新源码总汇 stackoverflow上Java相关回答整理翻译 整理的android学习技巧 Android 学习资料收集 带动画的顶部导航栏 Android 开源项目源码解析 Android 史上最全WebView使用，附送Html5Activity一份 Fragment全解析系列（一）：那些年踩过的坑 Android Tips 8 Android N多窗口支持 一个清华研究生的博客站 android多主题之坑 android多主题之坑 学习 React Native 必看的几个开源项目 (第一波) 三次贝塞尔曲线练习之弹性的圆 android滤镜 屏幕上的悬图标 看，这个工具栏能伸缩折叠——AndroidCollapsingToolbarLayout使用介绍 Android App支付系列（一）：微信支付接入详细指南 App 不死之路 进程保活 Android去除烦人的默认闪退DialogAndroid去除烦人的默认闪退Dialog 手把手教你逆向分析 Android 程序 Android WebView 上传文件支持全解析 收集Android相关blog 有许多语言的视频教程的网站 系统学习Android从Activity的原理，biander,ClassLoader说起 牛人博客有okhttp retrofit等源码解析 GitHub优秀源码分类 android产品研发过程中常用的技术，技巧，实践等 Android架构集合文章 技术知识点索引，每日一读 15 个 Android 通用流行框架大全 安卓学习资料 Android高工必备技能！ 2017android 面试资料 前端资料大全 Android 技能总结，各种基础和进阶内容的资料收集 android 面试资料 Android常见的问题 国外著名 Android 开发者及公司信息 Android代码规范，可在组内推行 安卓开发规范 各种开源的书籍 真棒Android完整参考 安卓学习资料 这个项目的目标是提供一个精心挑选的Android图书馆，工具，开源项目，图书，博客，教程等等。 安卓相关博客 数据结构与算法 Android 一些重要知识点解析整理 Android百大框架排行榜 GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频 安卓面试题 面试宝典 正则表达式学习 混淆手册 AndResGuard是一个帮助你缩小APK大小的工具 工具 开发工具总结（1）之图文并茂全面总结上百个AS好用的插件 App安全（一） Android防止升级过程被劫持和换包 远离手机 / 百度网盘 下载器 适用于Android的安全，简单的键值存储 保存 缓存 翻墙 翻墙软件 翻墙！科学上网，免费ss帐号分享、ssr订阅源，免费VPN下载，获取及使用教程请看 UETool 是一个各方人员（设计师、程序员、测试）都可以使用的调试工具 百度网盘不限速下载 支持Windows和Mac 2018年1月16日更新 Android开发人员不得不收集的工具类集合 utils 使用GitHub的信息生成的简历 博客生成器 免费翻墙镜像和工具 ［Android Studio 权威教程］AS中配置强大的版本管理系统(Git、SVN、等) Android Studio详细教程汇总 如何把你的App加入白名单 MarkDown在线简历工具，可在线预览、编辑和生成PDF AndroidStudio 优秀插件汇总 Android开发中的工具类 Android内存检测工具 10个免费高逼格的icon网站 下一代Android渠道打包工具 各种Utils keystore密码找回 阿里巴巴矢量图库 Android开发人员不得不收集的工具代码 分享能增大你工作效率的工具 最新可用hosts镜像 适用于Java和Android的快速、低内存占用的汉字转拼音库 AES-256 encrypted SharedPreferences for Android. FaceBook加密技术ConCeal的一个Demo. 音频格式转换 A crash recovery framework! 崩溃恢复框架 DiffUtils是Google官方在support-v7-24.2.0新出的一个工具类，本工程为一个讲解它使用的Demo,RecyclerView刷新时 5.0 SnackbarUtils 加密库 pdf 一个Java ePub读者和解析器框架为Android。阅读 PDF Reader in JavaScript 程序员如何优雅的挣零花钱 赚钱 JSON Editor ZIP - convenience methods 硬盘缓存 代码作图 Show Vector Drawable usage in Android 2.1+ log工具 安卓逆向 反编译工具 更换icon图标 拦截手机短信验证码 打不死的小强,永不crash的Android 一个能让你了解所有函数调用顺序的Android库（无需侵入式代码） googlesamples 处理png压缩图片 Guetzli是一种JPEG编码器，旨在在高视觉质量下实现出色的压缩密度 Application Crash Reports for Android 崩溃收集 基于Android系统Api封装常用工具类 各种开发的工具 facebook UI构建框架 不用root就可以查看数据库 仿茄子快传的一款文件传输应用， 涉及到Socket通信，包括TCP，UDP通信。 http调试工具 记录主线程中执行的所有方法和它们的执行时间，当app卡顿时，将所有耗时方法直接展示给开发者，节省开发者定位卡顿问题的时间。 PDMan是一款开源免费的数据库模型建模工具 崩溃日志手机端显示 ，测试妹妹的最爱，开发哥哥的小棉袄 Transforming SVG to android VectorDrawable 根据年份统计各个版本的android手机的占有率 UC 浏览器复制，剪切 无需权限提示悬浮窗实现 Android Studio 在线查看 Android 和 Java 指定版本源码插件 Android WiFi ADB 婚礼大屏互动，微信请柬一站式解决方案 翻墙 梯子翻墙 基于腾讯浏览服务Tbs,使用X5Webkit内核,实现文件的展示功能，支持多种文件格式 doc、excel、ppt、excel、pdf 快速开发工具类收集，史上最全的开发工具类 util 免费api 免费API接口 免费api 免费API 通知工具类 git忽略文件 studio 翻译插件 studio 插件 可以查看color的引用个数 判断App位于前台或者后台的6种方法 一个超轻超薄的Android工具库，阻止三方SDK中常见的有害行为，而不影响应用自身的功能。（例如严重影响用户体验的『链式唤醒』） 记录主线程中执行的所有方法和它们的执行时间，当app卡顿时，将所有耗时方法直接展示给开发者，节省开发者定位卡顿问题的时间。 此项目基于 BlockCanary。 SharedPreferences a SharedPreferences replacement for Android with multiprocess support 监听网络的变化 帮助Android开发者，让项目在崩溃时从异常堆栈中，自动寻找Stack Overflow的回答。 Android App监听自身卸载，反馈统计 Python 资源大全中文版 [ Python frameworks](https://github.com/vinta/awesome-python Android 网络和数据库 OKHttp源码解析(一)–初阶 深入解析http和https那点事 可靠，灵活，高性能以及强大的下载引擎。 本库是一款基于RxJava2+Retrofit2实现简单易用的网络请求框架 主要是封装有Http网络隔离框架、日志、缓存、加载等待、toast、页面状态布局管理、权限、自定义view等常用的集合框架，减少开发成本，提高软件体验！ Retrofit分析-漂亮的解耦套路 Retrofit分析-经典设计模式案例 Retrofit2完全教程 你真的会用Retrofit2吗?Retrofit2完全教程 封装了okhttp的网络框架 android平台ssl单双向验证 支持HTTP/HTTPS, 自动维持Cookie, 异步/同步请求, 大文件/多文件上传, 文件下载; 支持304缓存, 302/303重定向, 支持代理服务器 从HTTP到HTTPS OKHttp源码浅析与最佳实践 HTTP响应头信息和请求头信息详解 AndroidHttpCapture网络诊断工具 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能 断点上传 网络开发框架 基于 ViewModel + LiveData + Retrofit + RxJava 封装的网络请求框架 RxJava + Retrofit封装，包含对相同格式请求数据、相同格式返回数据处理，显示Material Design加载dialog，文件上传下载进度展示、全局异常捕捉。 安卓下载库 Android高性能数据库框架 Android另一个高性能数据库框架 轻量但功能强大的ORM和SQL查询生成 微信的数据库 LiteOrm Android 进阶 Android的Context Manager（服务管理器）源码剖析 Android应用程序启动过程源代码分析 JVM结构、GC工作机制详解 JVM结构、GC工作机制详解 一种进程保活的方法 使用EventBus进程间通讯 android framework层源码解析，不定时更新哈 RxJava Essentials 中文翻译版 Rx和RxJava文档中文翻译项目 RxJava-Android-Samples RxJava的调试器 RxJava Javadoc Android 适配 Android屏幕适配全攻略 巧用dimens适配多个分辨率 显示gif图片 android各版本分辨率适配 今日头条屏幕适配方案终极版，一个极低成本的 Android 屏幕适配方案 Android UI适配方案 一行代码搞定安卓全屏幕适配——简单粗暴-低入侵，无继承，简单高效 一种粗暴快速的Android全屏幕适配方案 Android 插件化和更新 滴滴的热更新 Android插件框架，免安装运行插件APK ，支持独立插件和非独立插件 阿里巴巴 强大的Android动态组件框架 美团热修复 Robust是具有高兼容性和高稳定性的Android HotFix解决方案.Robust可以立即修复错误，而无需发布apk。 Dex分包之旅 Sample app to demonstrate multidex 当你准备开发一个热修复框架的时候，你需要了解的一切 Android中的动态加载机制 深入理解插件化 插件化 AndFix 可以快速开发电商应用中既要求体验又要求灵活性的页面功能 实现Android App多apk插件化和动态加载 Alibaba-AndFix Bug热修复框架原理及源码解析 Nuwa, pure java implementation, can hotfix your android application 热修复，没你想的那么难 Android 插件化原理解析——Service的插件化 Android 热修复其实很简单 为什么我说Android插件化从入门到放弃？ Android热修复实践应用–AndFix 掌阅Android App插件补丁实践 热修复框架 最简单易懂的Android插件补丁框架 Android应用增量更新 腾讯的热更新 微信tinker补丁管理，后端代码+客户端sdk Android应用增量更新 Android app 增量更新 增量更新Demo和Library 跨平台插件化方案 android app自动检测更新库 TinkerPatch 接入指南 万能更新库，修改只要一点点 增量更新等 美丽说的 热修复方案 Android 版本更新 支持强制更新 安卓应用自动更新 热修复——深入浅出原理与实现 Android 混合开发 CacheWebView是Android WebView 缓存的自定义实现 android java和javascript桥梁 超完整的React Native项目，功能丰富，适合学习和日常使用 Android基于腾讯X5内核的WebView(超级浏览器)，拥有文件上传、下载、浏览（支持PDF/PPT/DOC/EXCEL/TXT格式）、Android与JS的交互、视频播放、自定义进度条、下拉回弹等功能 腾讯的Hybrid 方案 H5框架 轻量可扩展 Android WebView 和 Javascript 双向交互框架 .从浏览器中打开客户端 2.实现在客户端内部与h5混编 WebView Android WebView 混合应用基础架构 跨平台热更新方案 Js双向通信 基础WebView AgentWeb 是基于 Android WebView 一个功能完善小型浏览器库 。 使用很方便 ， 集成进你应用 ，只需几行代码 。 React Native 官方文档。 a collection of simple demos of React.js 为WebView中的Java与JavaScript提供【安全可靠】的多样互通方案 React Native 实例 - BBC新闻客户端 React Native开发技术周报 React Native 高质量学习资料汇总 Android 项目中嵌入 ReactNative 模块 React Native新建项目 这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。 React Native 研究与实践 React Native 学习资源精选仓库(汇聚知识，分享精华) React Native优秀博客，以及优秀的Github库列表 React-Native学习指南 致力于帮助Android开发者转react-native开发 react-native 热更新 react-native掘金客户端 react-native 底部菜单 一个基于 React Native 的 Android 企业级应用。 基于React-Native、Redux实现的「漫画书」App，兼容Android移动端 Native navigation library for React Native applications react-native wrapper for android BottomSheetBehavior React Native 二维码扫描 高仿美团客户端 React-Native版，支持iOS、Android kotlin kotlin 官方文档翻译 Kotlin项目 Kotlin 视频教程 组件化 + MVP + Retrofit + RxKotlin + Dagger2实现的一款用Kotlin语言编写的多媒体类应用 一个用Kotlin写的简单漫画APP Kotlin 资源大全，包括教程文章、开源库和框架、Demo 等，由掘金技术社区整理和维护。 精彩的Kotlin相关的东西 kotlin 例子 kotlin 官方例子 kotlin 协程 第一本 PWA 中文书 kotlin 协程 Kotlin for android developers in chinese. Kotlin 开发框架 使用Kotlin撸一款Eyepetizer，学习Kotlin语言 超完整的Android Kotlin 项目，功能丰富，适合学习和日常使用。 KOIN - Kotlin的一个实用的轻量级依赖注入框架 kotlin文件选择器 Λrrow是Kotlin中的类型化函数式编程库。它包括最流行的数据类型 kotlin android 例子 一个支持多种场景的Android换肤框架 Android应用程序开发的一套Kotlin扩展。 用Kotlin去提高生产力 Flutter flutter 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档 Flutter完整项目，玩Android-Flutter版客户端。 Flutter完整项目，WanAndroid客户端，BLoC、RxDart 、国际化、主题色、启动页、引导页，拥有较好的项目结构&amp;比较规范的代码！ 超完整的Flutter项目，功能丰富 基于Google Flutter的开源中国客户端，支持Android和iOS。 Android 音视频开发 视频播放器 直播推拉流 音视频，直播SDK，rtmp推流，录制视频，滤镜。百万用户，线上迭代半年，已经稳定。 Android上基于FFmpeg开发的视频处理框架 包含美颜等40余种实时滤镜相机，可拍照、录像、图片修改 仿微信拍照Android控件（轻触拍照，长按摄像）微信拍视频 Easily integrate Camera features into your Android app Android播放器基础库，专注于播放视图组件的高复用性和组件间的低耦合，轻松处理复杂业务。 安卓平台下，图片或视频转化为ascii，合并视频用到ffmpeg库。后期会加入带色彩的ascii码图片或视频 音乐播放器，可播放本地音乐，百度音乐，qq音乐，虾米音乐，网易云音乐 是七牛推出的一款适用于 Android 平台的短视频 SDK，提供了包括美颜、滤镜、水印、断点录制、分段回删、视频编辑、混音特效、视频剪辑、本地转码、视频上传在内的多种功能，支持高度定制以及二次开发 视频播放器（IJKplayer），HTTPS支持，支持弹幕，支持基本的拖动，声音、亮度调节，支持边播边缓存，支持视频本身自带rotation的旋转（90,270之类） 最新版ffmpeg3.3-android，并通过CMake方式移植到Android中,并实现编解码，转码，推拉流，滤镜等各种功能 支持直播的播放器 ，支持手势 亮度，音量，快进，等手势 ，广告视频预览 ，视频清晰度切换 Android录屏框架，目的是使用system uid实现（内录）submix的录制。 大牛直播，跨平台(windows/android/iOS)推送(rtmp)、播放器(rtmp/rtsp)，支持录像、导播、动态视频合成、实时快照、水印、音频混音、互动等，国内外为数不多不依赖开源框架，业界真正靠谱的超低延迟(1秒左右)。 添加 视频录制 音频 混合器 仿网易云音乐 安卓版，netease android，音乐播放器 在线 下载 视频录制 视频压缩（使用FFMpeg）Android Video Recorder/Video Compressor 音乐播放器 视频观看 bilibili非官方客户端 一款优雅的遵循 Material Design 的开源音乐播放器 A material designed music player for Android 材料设计的 音乐播放器 recyclelerview中自动播放/暂停来自网址的视频。视频中自动播放视频。 利用FFmpeg视频录制微信小视频与其压缩处理 即时通讯 视频进度 【VLC-Android】vlc-android简例 Android视频录制 Android上定义播放器控件UniversalVideoView 安卓视频播放器 全屏 播放器列表全屏 仿今日头条UI 控制视频播放 VCL-Android VCL-Android 直播解决方案 Android/iOS video player based on FFmpeg n3.0, with MediaCodec, VideoToolbox support. android platform. multirmedia Player. play video 视频的最小化 一个面向Android设备的互联网免费视频播放客户端 android video player base on ijkplayer 视频剪辑 一个视频播放列表demo，视频播放使用的ijkplayer,正在播放视频拖动到不可见区域小窗口播放，可全屏切换一个视频播放列表demo，视频播放使用的ijkplayer,正在播放视频拖动到不可见区域小窗口播放，可全屏切换 一个可扩展的媒体播放器 goole的 Lollipop (5.0) 屏幕录制实现 Android中直播视频技术探究之—基础知识大纲介绍 微信小视频+秒拍,FFmpeg库封装 滑动时自动播放/停止的功能 PLDroidPlayer 是一个适用于 Android 平台的音视频播放器 SDK，可高度定制化和二次开发，为 Android 开发者提供了简单、快捷的接口，帮助开发者在 Android 平台上快速开发播放器应用。 基于RTMP协议的直播sdk Android录音的demo 基于IjkPlayer的控制器，支持手势操作，滑动快进，快退，支持，上滑音量亮度的变化，支持指点位置播放，播放源的切换 音乐播放器 XMPP开源项目 仿微信录制视频 仿泰捷视频最新TV版 Metro UI效果. 2、仿腾讯视频TV版(云视听·极光) 列表页 一款用集成多人视频通话，群聊功能应用，多达4同时实现通话，多人群聊 直播技术 视频直播技术 基于RTMP和RTC混合引擎的在线视频连麦互动直播 Android TV直播电视节目 ,包含各央视频道及卫视频道 RTMP 推流器，RTMP播放器（秒开），跨平台（Win,IOS,Android）开源代码 仿爱奇艺视频，腾讯视频，搜狐视频首页推荐位轮播图 可以拖拽的视频播放器 很好的一个音乐客户端 视频播放器 可移动的视频 图像 视频项目 FFmpeg Android 好看的效果和牛逼的功能 RxJava 2 和 Retrofit 结合使用的几个最常见使用方式举例 一款仿miui，仿小米，日历，周日历，月日历，月视图、周视图滑动切换，农历,Andriod Calendar , MIUI Calendar,小米日历 Andorid 任意界面悬浮窗，实现悬浮窗如此简单 支持异步弹出软键盘，实时弹出软键盘，关闭软键盘，软键盘弹出不遮挡指定区域 iSparta 是一款 APNG 和 Webp 转换工具。 分享 GitHub 上好玩、容易上手的项目，帮你找到编程的乐趣。欢迎推荐、自荐项目，让更多人知道你的项目 eventbus3插件 使用ionic3/ag4编写模仿京东商城的demo 用RecyclerView实现无限轮播图，有普通版和3d版 一款android自动生成表格框架 Excel excel 切换不同的数据状态布局，包含加载中、空数据和出错状态，可自定义状态布局。 跟miui一样的自动滚动截屏 Excel excel 表格 手势浏览器 Android全手势浏览器 使用Snake，Android也可以轻松实现类iOS滑动关闭效果 滑动退出 Android 股票图表库 高颜值、好用、易扩展的微信小程序 UI 库，Powered by 有赞 简洁优雅可点击的toast控件，仿手机百度9.0，无BadTokenException风险。 Android下WIFI隔空apk安装 年会抽奖项目 Good looking curved Android SeekBar 监控日志并区分日志类型. Android上一个优雅、万能自定义UI、支持周视图、性能高效的日历控件 一个自定义的轮播控件 一个高仿闲鱼键自定义数字键盘特效 自定义下拉刷新和上拉加载框架 Android应用内展示word、excel、pdf、ppt等文件 [开源] Android InDoorView 室内选位控件 该库使用OpenGL着色器在运行时对ExoPlayer视频应用效果 在线制作sorry 为所欲为的gif https://sorry.xuty.tk/ TextPathView是一个把文字转化为路径动画然后展现出来的自定义控件 可以使任何一个View or layout展示出不同形状，并且代替重复创建不同shape文件 Android TreeView is used to display data in tree structures.树形 可以定制一些简单的路径，按想要的绘制顺序添加，SimpleLineView会依次展现路径动画。path 线性图 表情 一个支持多种场景的Android换肤框架 Android 主题换肤的开源库（插件化换肤） k线图 图表 Android开发专业k线图表组件，支持JDK,MACD,MA，VOL等指标，后续指标陆续更新 Android拼图支持库，想法来自Layout for Instagram。2.0发布了，支持超级酷炫的斜线拼图，圆角模式 地图点 一款万能遥控器的交互效果 Android平台下的富文本解析器，支持Html和Markdown A tool to edit colors in Lottie animations Android动画 KChart for Android ；股票k线图 字母，符号，数字&amp;自定义安全键盘 直播间礼物动画控件 小程序生成图片库，轻松通过 json 方式绘制一张可以发到朋友圈的图片 停车王车牌键盘-Android Android 仿钉钉、微信 群聊组合头像 各种自定义图表库，使用简单，支持扩展 一个android插件，允许你轻松地改变你的设备语言。 一个扩展Android toast框架的库。 Android Sku属性选择器, 类似于淘宝，天猫，京东，支持MVVM，直接使用 loading动画 A powerful library that manage Fragment for Android! Android integration of multiple icon providers such as FontAwesome, Entypo, Typicons,… 一起来撸个朋友圈吧 打造通用的popupwindow MediaUtils : a demo of record audio and video.一个在 Android 上实现录像和录音功能的小例子。 漂亮的区间选择器，贝塞尔曲线优雅实现 轻松实现Android ShareElement动画 堆叠头像的点赞Layout 随机布满屏幕的文字，飞入飞出动画效果的控件 自定义组织机构图 &amp; 层次图 一个顺滑的、高度自定义的滚轮控件和选择器，支持类似 iOS 的 3D 效果 Android优秀开源框架汇总 高仿抖音照片电影功能 Android 微信自动回复功能，使用的知识为 AccessibilityService。 沉浸式 RecyclerView 分割线 Android物料设计文件管理器 RecyclerView最顶部的itemView，会随着手指滑动实现收缩隐藏与放大显示，并伴随recycler的回收与复用 编译时注解 自动生成注册文件 dialog google api可一个统计应用的使用 微信个人号接口、微信机器人及命令行微信，三十行即可自定义个人号机器人。 五种实现activity动画切换的方式 可展开的TextView 一款支持复数运算和解方程等功能的计算器 星期选择 安卓页面编辑 A rich text editor sample 类似魅族清除内存的卡片效果 加载失败 一个带渐变层叠动画的左右滑动效果（类似于探探、tinder） 卡片 在任何非 MIUI 设备上体验小米系统级推送。 类似滴滴地图上汽车移动路线 带动画的启动页面 The Google I/O 2017 Android App 简单易用的第三方可扩展支付框架。 用于调试自适应图标的Android应用程序。 文本编辑器的破解 一款基于Android开发的纵版飞行射击游戏 一个可以让自己子视图滚动起来的控件(仿[淘宝头条])。 可以展开的LinearLayout A library that manages state using RxJava 2.状态管理 柱状图 自定义控件 刻度尺 自定义控件有备选词的完形填空，无备选词完形填空 Android歌词控件，支持上下拖动歌词，歌词自动换行，自定义属性。 进度按钮自 自定义view实现的滚动刻度尺 一个小巧且高效的线性图表组件。 那些你应该知道却不一定知道的——View坐标分析汇总 Andorid自定义圆形渐变色进度条的从实现到开源 Android自定义控件三部曲文章索引 Android自定义密码输入框控件 一步一步教你 150 行代码实现简书滑动返回效果 一步一步教你 150 行代码实现简书滑动返回效果 android 自定义键盘，在页面嵌入的。使用还算简单 自定义view3步的视频讲解 仪表盘开源项目 Android Canvas练习 下载进度动画 模仿掌上英雄联盟能力分析效果 仪表盘 蜘蛛图标 网状图 可旋转的扇形图，可以更改样式。 在 Android端app上，自定义View，仿一个斗鱼web端滑动验证码。 可以展开的textview 自定义圆形菜单 Switch View开关按钮 利用三阶贝塞尔曲线模仿QQ空间直播时右下角的礼物冒泡特效 数字增加动画的 TextView 类似股票实时联动效果 自定义view下雪效果 圆形进度条 Android-Charts 图表 一个可以自由定制外观、支持拖拽消除的MaterialDesign风格Android BadgeView 小红点提示 水波纹效果加载动画 加载动画 水波纹效果的选择器 手势解锁 android 4.4以上沉浸式状态栏和沉浸式导航栏管理，一句代码轻松实现，以及对bar的其他设置 A draggable PointView for Android. qq红点拖拽效果 查看pdf 基于Glide V4.0封装的图片加载库，可以监听加载图片时的进度 权限管理 夜间模式 强大的下拉刷新库，定制任意Header。比官方SwipRefrehLayout处理更加友好(Kotlin、Java双版本) Making Camera for Android more friendly. 📸 相机 一个强大的下拉刷新框架 引导页 点亮 高亮 文件管理器 文件夹 各种开源框架的demo 优雅地处理加载中，重试，无数据等) 引导界面滑动导航 + 大于等于1页时无限轮播 + 各种切换动画轮播效果 安卓选择器类库，包括日期选择器、时间选择器、单项选择器、城市地址选择器、车牌号选择器、数字选择器、星座选择器、生肖选择器、颜色选择器、文件选择器、目录选择器等，可自定义顶部及底部界面，可自定义窗口动画…… 可以读取，编辑和写入CSV文件。 Android 检索手机目录方式的文件选择器，轻量且界面友好，定制性高 由RxJava提供的Android运行时权限 为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来） Custom status view for Android.顶部状态加载 Android 富文本编辑器 Android runtime theme library 主题更换 Android-skin-support: 一款用心去做的Android 换肤框架, 极低的学习成本, 极好的用户体验. 只需要两行代码, 就可以实现换肤, 你值得拥有!!! 可拖拽的流式布局 机票座位选择 一个用于app指向性功能高亮的库 引导页 github上的安卓开源库汇总 Android源码大放送之material design类型 消息提示AppMsg代替系统Toast Android显示gif图片 桌面渲染可显示带根号的数字运算 Android聊天界面 Android图表 股票实时查询联动列表 股票实时查询联动列表2 主题换肤 完全仿微信的图片选择，并且提供了多种图片加载接口，选择图片后可以旋转，可以裁剪成矩形或圆形，可以配置各种其他的参数 Android Dynamic Action，简称DA，是一种简便、可变Action的实现方案。你可以像访问网页一样地访问Activity。 谷歌材料设计风格的日历控件 有与微信相同的下级activity联动效果 带动画的顶部导航 一个强大并且灵活的RecyclerViewAdapter tv常用效果控件，包括焦点、边框处理等 一个Android自定义粘性控件(跟qq气泡相似) 正弦波浪 一个安卓中处理图片的各种形状库 安卓快速开发框架易维护 给EditText添加Tag 下拉刷新A custom view can pull up and down,support ScrollView,ListView,RecyclerView,WebView and all another views, easy to use MaterialDrawer 抽屉 代码家的veiw的各种动画库 Android端的Bootstrap 点击指示动画 可以让子View展开的动画 recyclerview的动画 Android Design library 仿UC天气下拉和微信下拉眼睛 TLint for 虎扑体育 基于Dagger2+RxJava+Retrofit开发，采用MVP模式 一个漂亮的弹出框 弹出提示气泡 这是一个圆形的小部件,可以用来显示倒计时定时器或计数定时器 在状态栏显示toast 提示 Android库来简化检测手势 可以简单的获取设备的信息 可以拖动滑动图片 谷歌风格的语音识别动画 小点可旋转 EditText in Material Design 单页显示3个Item的ViewPager炫酷切换效果，适用于Banner等 自定义toast 这是Android一个雷达扫描显示的扫描图，超高仿QQ附近的人搜索展示 切换页面的圆形动画效果 android 悬浮窗菜单，可在launcher或app中使用 android 动画库 android Material下拉刷新库 android 模糊效果 一个android密码视图看起来像支付宝支付密码在微信应用程序和应用程序 一个圆形梯度Android进度条 Android开源弹幕引擎·烈焰弹幕使 谷歌开源的响应式编程库 类似RxJava 很棒的音频部件 一个Android部件为选择项,旋转轮 Android键盘面板冲突 布局闪动处理方案 AndroidImageEdit 安卓设备上图形编辑开源控件，支持自定义贴图 图片滤镜 图片旋转 以及图片剪裁操作 贴纸标签相机,功能:拍照,相片裁剪,给图片贴贴纸,打标签 单手操作图片控件 镜像、置顶、缩放、移动 一款加载动画，不同的物体加速下落砸到了文字上，文字逞阻尼效果，向下弯曲并像橡皮筋一样弹动回去的效果 各种加载动画 谷歌的MVP MVP例子 一个开放的学习项目基于材料设计支持库 一个通过动态加载本地皮肤包进行换肤的皮肤框架 3d旋转切换view，类似旋转木马效果。可以自动切换！ 仿微信小视频录制，基于GitHub上的javacv 导航标签栏和丰富多彩的交互 一个很酷的搜索视图动画库 音频软件中可以跟着声音跳动的wave 一个Android拼图的demo，类似于Layout，Moldiv，美图秀秀的拼图功能 可以展开的按钮 也许是最良心的开源表情键盘解决方案 设置状态栏样式在Android应用程序 沉浸式状态栏 高仿微信手势滑动返回 在ListView中实现日历视图 可翻转的view Android流式布局，支持点击、单选、多选等，适合用于产品标签等 富文本编辑 底部的菜单 减少APP被杀死的机率 材料设计的底部导航栏material design 用于学习RxJava操作符的APP 通过RecyclerView实现的联系人 这是一个基于Flux架构,使用Retrofit RxJava Dagger2创建的示例 可以张开的viewpager 垂直的viewpager 各种各样的recycleview 100多种UI效果，加载动画，viewpager翻，各种菜单等等转等等 下拉刷新的ExpandableListView 可以添加头部的ScrollView 类似UC 非常全的RxJava学习资料 下拉刷新库，非常牛掰 点赞的动画效果 Andorid屏幕截图类库 基于Theme的Android动态换肤库，无需重启Activity、无需自定义View，方便的实现日间、夜间模式 viewpager翻转效果 屏幕手势锁 实用的下拉菜单 带动画的ExpandableListView 各种Material Design 效果 多线程下载 微信抢红包插件, 帮助你在微信群聊抢红包时战无不胜 图表库 牛逼的图表库 又一个牛逼的图表库 简单的图标库 recycleview加头部 弹出菜单 Android分屏开发 Android富文本编辑器edittext textview高级用法 Android字体库 高仿网易新闻首页Tabs添加，删除，排序 一个非常全的沉浸式顶栏的例子 用于展示注册进度的view 垂直跑马灯；学名：垂直翻页公告 带动画的类似 PIN 的 EditText 基于Android系统Api封装常用工具类 可以读取SD卡，asset文件夹，或者网络下载的pdf文件的widget 手势滑动返回的Fragment 一种可根据展开是否超出屏幕来判断父控件是否自动滚动的ExpandableLayout 一个支持多种状态的自定义View,可以方便的切换到：加载中视图、错误视图、空数据视图、网络异常视图、内容视图 锁屏 截屏 Animated SVG Drawing for Android 一个类似支付宝、微信输入支付密码的控件 那些酷炫的RecyclerView开源库整理 能够快速的为一个Activity里的任何一个View控件创建一个遮罩式的导航页 流程只是示意图 Android 多主题框架 Android 多主题框架又一个 ProgressBar 顶部进度条 解析XML 图片裁剪 旋转 动画的插值器 手势返回 Lifecycle handling APIs for Android apps using RxJava这里提供的实用程序允许基于Activity或Fragment 生命周期事件自动完成序列 安卓手势控制 控制图片 材料设计的日历 终端系统监控仪表板 Material Design 系列控件samples,讲了Material Design 系列新控件的使用方法和一些场景示例，使用详情请看对应博客，持续更新中… 表情 抛物线的UI绘制教程 按钮点击状态 一个强大的selector注入器，它可以让view自动产生selector状态，免去了写selector文件的麻烦。 可伸缩布局方案 一个用粒子动画显示文字的 Android 自定义 View textview 一个帮助您完成从缩略图到原图无缝过渡转变的神奇组件 安卓平面图 布局图 A periodic text updating library 广告轮训效果textview 安卓微信防撤回神器 ! 新闻加载效果 图片放大效果 列表多类型布局方案 Image Cropping Library for Android 图片裁剪 图片切换 旋转木马效果 android 自定义日历控件 支持左右无限滑动 周月切换 标记日期显示 跳转到指定日期 利用RecyclerView.ItemDecoration实现顶部悬浮效果 沉浸栏 瀑布流式的时间轴 优雅地刷新Recyclerview(可配合大多数Adapter ； 一行代码刷新相应viewType ； 支持facebook的shimmer加载效果 ； 仿美团城市选择界面，可直接用在实际项目中 动画 一个支持 AOP、栈控制、跨页面带信、和动态变更映射的 URL 路由库。 DialogFragment 的封装 Android 快速实现新手引导层的库 在QQ登录界面上加点特效 动态主题 A Markdown parser for javascript 解析Markdown 一行代码实现Android软键盘和EditText各种交互 提高 Android UI 开发效率的 UI 库 Groupie helps you display and manage complex RecyclerView layouts. 说话按钮变化 Google ARCore SDK for Android Studio 通过手势滑动关闭Activity的库 下拉刷新demo 照相机 悬浮的activity Android RichText 富文本解析器，支持网络图片，图片和链接点击事件 点击阴影效果 横向进度条 伸缩的布局 缩放 知乎 x RxJava Meetup 点击查看动画 viewpager with parallax pages, together with vertical sliding (or click) and activity transition Android三种姿势带你玩转360度全景图功能 A simple library to add Emoji support to your Android app. 表情 仿小米运动的运动记录界面 动态背景界面 How to create instagram like Gradient color transition in android. 自动, can be selected to auto generator findViewById code in Activity or etc, 圆形 圆角图片 点击浮动动画 泡椒网游戏SDK Float View(悬浮窗) 简单的下拉刷新框架 RecyclerView高仿效果合集 用RecyclerView实现无限轮播图，有普通版和3d版 各种金融类的自定义View,在不断完善中…. Android 分页 安卓饼状图 TextView 点击链接到某处 自定义安全键盘 可以在Android上运行仪器测试时生成快速确定性的屏幕截图。 Android OpenGL ES从零开始的Demo TextView 滚动显示 可展开的RecyclerView 一个简洁而优雅的Android原生UI框架，解放你的双手 Android 一键加入侧滑返回 (类似“小米MIX”和新版“即刻”滑动返回) Aurora IMUI 是个通用的即时通讯（IM）UI 库，不特定于任何 IM SDK。 描边/内间距/四个角不同弧度（包括圆角）ImageView 一个通用的Android端弹窗管理框架,内部维护弹窗优先级队列 具备弹窗管理扩展功能 类似淘宝的商品详情页，继续拖动查看详情，其中拖动增加了阻尼 仿斗鱼直播送礼物和连击效果动画 Android复杂红包雨实现，带点击事件处理 垂直纵向的TabLayout、轻松创建纵向导航 散列图效果 雪花飘落效果，可以实现自定义 Android 室内场景构建组件，帮你快速的完成室内场景 View 的展示 多边形的绘制 绘制多边形 各种带背景的textview 仿魅族内存清理的UI 支付密码输入框 点赞的动画 好看的引导页 滑动的时候底部和顶部出来 自定义View和属性动画结合实现支持动态修改指示点位置，拖拽或点击改变指示点位置，点击位置监听及切换动画自定义的圆点指示器。 可自定义动效的卡片切换视图 底部Tab 顶部Tab 各种Tab页面 一种支持多种弹幕样式的弹幕视图控件 使得 SQLite 和 Excel 之间相互转换更加便捷。 viewpager 图片查看 密码锁 波浪加载动画 沉浸式状态栏 仿nice图片上打标签控件 RecyclerViewSidebar 选择器 帮助快速查阅对应分组的侧边栏 Android广告图片轮播控件，支持无限循环和多种主题，可以灵活设置轮播样式、动画、轮播和切换时间、位置、图片加载框架等！ 通用的广告栏控件，让你轻松实现广告头效果。支持无限循环 半圆锯齿背景虚线边框组合实现简单优惠券效果，可实现一些简单组合 卡卷 跟随手势滑动，显示隐藏标题栏、底部导航栏及悬浮按钮的Android Behavior Library 类似新闻加载的动画库 Android 立体的3d Android各种粒子效果 UltraViewPager 各种风格的ViewPager 仿微信(weixin wechat)实现的朋友圈 评价的进度 自定义SeekBar，进度变化由可视化气泡样式呈现 应为需要实现一个类似于双向滑动的SeekBar 离散的ScrollView 图片的展示 1行代码让你的ViewGroup拥有华丽的布局动画！ RecyclerView侧滑 RecyclerView解决方案，支持addHeaderView，addFooterView和页面加载 这是一个包含一个有趣的动画的自定义拉到刷新布局的项目 下拉刷新 Android Gradle Java应用程序模板 一个圆形的ImageView for Android 基于RecyclerView的Android的材料横向日历视图 CoordinatorTabLayout是一个自定义组合控件 各种toast 请求网络之后的各种状态的展示 loading 悬浮的 材料风格的查找 MaterialSearchView 材料风格的查找 TextView跨度行为，支持惊人的recyclelerView功能的流式布局行为 淡入淡出的textview 新闻客户端的加载动画效果 Behavior实现的漂亮的效果 从桌面启动应用 桌面操作应用 Android日历 仿小米 华为 滴答清单 365日历（农历），周视图 月视图 平滑滚动 节假日 week or month calendar An imageView can auto scroll with device rotating.图像跟随手机转动 漂亮的toast text path显示动画 Android 单击listview弹出popupwindow弹出框 可缩放矢量图形为Android android高仿微信表情输入与键盘输入详解 还在羡慕微信／微博的图片处理?－android酷炫图片处理(下) 悬浮球-一个服务开启悬浮球，任何界面都可以使用 vr 虚拟现实的app Material Design 的搜索框 可展开的RecycleView 不一样的toast 点赞的动画 显示gif图 一个简单，强大的广告活动弹窗控件 为任何视图添加一个headview和支持ItemView卷轴时坚持顶部导航器。 密码解锁的样式 下拉刷新的RecycleView Androi可拖拽的ListView 高仿微信数字键盘、支付键盘（密码键盘） 上拉刷新下拉加载 app icon 上加气泡 仿应用宝下载进度条 类似于映客，快手，等直播APP布局，直播刷礼物特效，定时清除礼物，计时器，圆形头像，横行listview等！！！， TextView中输入表情 树形RecyclerView 这是一个简单而精致的 Fragment 菜单控件，它可以让你切换 Fragment 的时候不再单调、死板。 仿网易新闻加载效果 五星评价 AppBarLayout 下拉拉伸 仿锤子 拖拽选择 使用风扇布局管理器可以实现水平列表的项目像风机叶片recycleview ViewPager转换效果 高仿微信底部状态栏的轻量级库 日历 和支付宝一样的密码验证框 RecyclerView下拉刷新 安卓选择器类库，包括日期时间选择器、单项选择器、地址选择器、颜色选择器、文件目录选择器、数字选择器、星座选择器 音乐播放器中显示歌词 android高仿钉钉和小米的自定义日历控件 googledemo 日期选择器 Android 中各种绚丽的效果 像微信中的那种下雨的效果 下表情 无缝为Activity、Fragment、任何View设置加载（loading）、重试(retry)和无数据（empty）页面。 神交互。模仿饿了么详情页可以跟随手指移动 viewpager变详情页 股票中固定左边滑动 仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果 圆形进度条 RecyclerView实现的excelPanel左右上下滑动 类似QQ空间，微信朋友圈，微博主页等，展示图片的九宫格控件 通过MarqueeFactory来提供各种样式的跑马灯View， 支持自定义跑马灯ItemView 广告 一个带伸缩位移旋转动画的购物车按钮 各种各样的Notification效果 嵌套滚动的多种实现方案Demo excelPanel 上滑和左滑 下载进度按钮 淘宝 VirtualLayout是一个针对RecyclerView的LayoutManager扩展, 主要提供一整套布局方案和布局间的组件复用的问题。 密码输入 加载动画 loading 支持水平方向上滑动和竖直方向上的滑动，直接修改的官方提供的ViewPager的源码 精仿iOS的PickerView控件 wheelview 各种加载动画 activity场景切换动画 Android进程保活招式大全 进程保活的一般套路 android 后台运行 系统进程守护 Android 端外推送到底有多烦？ 集成第三方推送最佳实践 推送sdk 推送集成 二维码 A better way to operate quick response code in Swift各种类型二维码 几行代码快速集成二维码扫描功能 QR code ASCII art for java 二维码 图片二维码 艺术二维码生成器 （GIF动态二维码、图片二维码） 一个长按扫描 View 上的二维码的工具库。webView 也可以。 一个很全的二维码扫描例子 zxing二维码扫描例子 ZXing and ZBar 二维码 Gradle多渠道打包(动态设定App名称，应用图标，替换常量，更改包名，变更渠道) 快速多渠道打包工具 Gradle 多渠道打包实践 最简单的Android studio发布Library到Jcenter Android Signature V2 Scheme签名下的新一代渠道包打包神器 git Git GUI使用方法 闯过这 54 关，点亮你的 Git 技能树 (二) 常用git命令手册 有关 git 的学习资料 Android 测试和性能优化 安卓单元测试 简化测试 Android自动化测试例子 Google官方提供的Android UI自动化测试的框架. leakcanary测试 (MVP+RxJava+Retrofit)解耦+Mockito单元测试 经验分享 Android严苛模式StrictMode使用详解 Mocking framework for unit tests written in Java Android 单元测试框架 Android 单UI试框架 Android客户端性能优化 App瘦身最佳实践 App优化之性能分析工具 360开源又一力作——ArgusAPM移动性能监控平台 页面启动速度优化利器 预加载 支持网络数据、网络图片、本地图片、数据库查询及文件I/O等各种耗时操作的预加载 Android APP 性能优化的一些思考 Android瘦身不反弹最佳实践 JS Vue2 全家桶仿 微信App 项目，支持多人在线聊天和机器人聊天 js 图表框架 vue demo 工作中经常用到github上优秀、实用、轻量级、无依赖的插件和库 js库 Free Bootstrap 3 Admin Template HTML5弹幕播放器 使用JavaScript，HTML和CSS构建跨平台桌面应用程序 從零開始學 ReactJS（ReactJS 101） vue.js demo Javascript框架学习 Javascript engine Vue.js 点赞效果 vue写的网易音乐客户端 Vue 全家桶 + axios 前端实现登录拦截、登出、拦截器等功能 基于Vue2.0 + vuex + vue-router + axios +更少的图片社交分享应用程序 Material design for AngularJS Material Design components for Angularhttps://github.com/angular/material2) vue2.0版英雄联盟助手 Vue2.0版-仿知乎日报SPA js 可伸缩布局方案 Vue.js相关组件 案例 vue写的豆瓣案例 Vue2.0版-仿知乎日报SPA 基于 G6 和 React 的可视化图编辑器 基于 G6 和 React 的可视化图编辑器 Vue.js 源码解析 腾讯移动Web前端知识库 手摸手，带你用 vue 撸后台 VUE 组件 VUE2.0 优雅的H5 下拉刷新。零依赖，高性能，多主题，易拓展。 vue组件 Vue写的网页 vue2.0+vuex+vue-router+vux 基于React的滑尺数值选择器 NDK AndroidStudio NDK开发最佳入门实践 图像 Similar to Lottie. Render After Effects / Animate CC (Flash) animations natively on Android and iOS, Web. 使用 SVGAPlayer 在 Android、iOS、Web中播放 After Effects / Animate CC (Flash) 动画 Android Image Edit Lib. Android 图片编辑库，微信图片编辑库 截屏 屏幕截图 轻量级安卓水印框架，支持隐形数字水印 查看大图 android图片压缩的处理 图片压缩 裁剪 图片压缩工具 一个Android转换库，为(picasso)提供各种图像转换 图片选择工具 LeafPic是一个流畅的，材料设计的替代画廊 相册选择器 Android裁剪图像的demo 图片的模糊效果 可能是最接近微信朋友圈的图片压缩算法 可以给图片添加标签 放大 缩小 删除 Android动态模糊图像 Android仿微信图片选择器 图片选择器 多图片像选择器 Android获取图片的三种方法 给图片加标签 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 图片选择 world level Gallery , from Telegram ，QQ 相册风格，相册选择器 图片模糊效果 仿微信图片选择器 各种类型的imageview显示 圆角等 实现imageview的各种效果 android多图选择器 图片/视频 单选or多选，以及视频录制。 一个可配置的迷你版轻量级 Label 辅助类，支持多种配置效果。图片加标签 模糊效果 图片选择 模糊效果 基于MVP模式的Android多媒体选择器支持多/单图片选择和预览，单图裁剪功能 知乎的图片选择器 架构 终极组件化框架项目方案 android 官方mvp框架优化：lifecycle-mvp，像前端那样组合式写页面 带你高效学习MVP+RxJava+Retrofit Android 组件化 —— 路由设计最佳实践 使用简单但功能强大的安卓组件化框架 多个维度对比一些有代表性的开源android组件化开发方案 一个基于AOP设计的Fragment管理框架 阿里的动态组件化 基于DataBinding框架，MVVM设计模式的一套快速开发库，整合Okhttp+RxJava+Retrofit+Glide等主流库 Androdid组件化实战 互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构 MVP架构 Retrofit+RxJava请求接口数据 Dagger、ButterKnife简化代码 持续更新Android架构文章大全 WMRouter是一款Android路由框架，基于组件化的设计思路，有功能灵活、使用简单的特点 模板工程 极简 Android 组件化方案。仅包含 3 个注解加 1 个 API，超低学习成本，支持渐进式组件化。 组件化demo 安卓框架源码 阿里巴巴开源路由框架 Android项目组件化 Android项目组件化示例代码 Router activities and methods with url for android 路由 仿京东app 采用组件化架构 首页采用屏幕适配的较好方案 基于MVP开发的Android应用程序的通用架构集成了许多开源项目 Android MVP+Retrofit+RxJava 实例 Mars 是微信官方的跨平台跨业务的终端基础组件 轻量级的Android MVP快速开发框架 安居客模块化架构 Android MVP Architecture Study MVP开发框架 优雅的路由框架 Router Android 应用开发框架（模块开发非常棒） Android 应用开发框架 EasyMVP 项目架构采用MVP模式，使用 Retorfit2.0+RxJava1.0+OKhttp+Fresco+Rtmp直播，高仿斗鱼TV项目，仅供代码参考学习！ 材料设计风格的开源照片笔记（MVP + Dagger2 + RxJava + AspectJ + Dex处理） HiBeaver是一个用于进行Android字节码插桩的Gradle插件，可以用于实现Android轻量级AOP设计 简单路由框架 a MVP library for Android favoring a stateful Presenter RxJava+Retrofit封装，基于RxJava2和Retrofit2重构，便捷使用 The MVVM Architecture in Android（MVVM+Jetpack的开发实践） mvvm响应式开发框架 谷歌mvvm例子Android Architecture Components samples 滴滴跨端解决方案Chameleon终于发布 跨平台方案 一套完整有效的android组件化方案 小程序 基于规范的小程序 UI 组件库，自定义标签组件 微信小应用资源汇总整理 一套高质量的微信小程序 UI 组件库 基于鸿洋大神的玩android开放API完成的《玩android》微信小程序版本 基于 Vue.js 的小程序开发框架 微信小程序开发资源汇总 小程序组件化开发框架 微信小程序图表charts组件 WeUI 是一套同微信原生视觉体验一致的基础样式库 小程序 微信小程序(微信应用号)微信小程序官方demo,官方文档,开发工具，高仿手机QQ应用程序,持续更新中… 小程序可滑动得tab-view 硬件 这是一个可拓展的Android指纹识别API兼容库，目前集成了 安卓标准API 以及 三星 和 魅族 的指纹SDK。 指纹识别 指纹识别 一个可拓展的Android指纹识别API兼容库，目前集成了 安卓原生API 以及 三星 和 魅族 的指纹SDK。 Android BLE 蓝牙开发框架 Android BLE 蓝牙快速开发框架，使用回调方式处理 蓝牙操作库 蓝牙开发 指纹识别 人脸识别 android BLE蓝牙框架，包括扫描、连接、设置通知、发送数据、读取和接收数据以及各种直观的回调，近乎一行代码植入项目，可扩展配置蓝牙相关操作。 完整项目 一款新闻客户端, MVP + RxJava + Retrofit + Dagger2 Android开源项目-微Yue电子书阅读（MD设计） 一款纯粹的ACG聚合类App项目 一款采用MVP模式的设计的仿造腾讯漫画的APP 新浪微博第三方Android客户端 一款多视图记账APP 在线商城 仿有宠商城APP 一款第三方今日头条客户端, MVP + RxJava + Retrofit 咕咚翻译 MVP + RxJava + Retrofit 一个仿京东商城的个人练手项目 Android免费开源漫画阅读器 吐槽第三方Android客户端 项目例子 萤火小程序商城 Espresso是一种采用材料设计风格设计的快递跟踪应用程序，建立在具有RxJava2，Retrofit2，Realm数据库和ZXing的MVP（Model-View-Presenter）架构上。 高仿铜板街 一款基于Google Material Design设计开发的Android客户端 新浪微博客户端 高仿Bilibili客户端 创业的完整项目 开源小说阅读器 GSD_WeiXin（高仿微信） 仿知乎日报 仿ireader阅读器 一个天气app 项目源码开源的 Material Design 豆瓣客户端 基于融云开发的 Android 版即时通讯（IM）可以发红包 项目源码开源商城 Android平台开源天气App，采用MVP+RxJava+Retrofit2+OKHttp3+Dagger2+RetroLambda等开源库来实现。架构 订餐app 一款基于网易云音乐UI，使用Gank.Io及豆瓣api开发的符合Google Material Design的Android客户端 本项目高仿微信6.3.31 项目实战 A news-reading App (MVP+Dagger2+RxJava+Retrofit2+Material Design) diycode 项目客户端 高仿全民直播（全民TV），项目采用 MVP + RXJava + Retrofit + OKHttp + Material Design + Dagger2 + Base + Glide + GreenDao构建。视频 java项目 基于JAVA的模块化开发框架，它提供在运行时动态加载模块 ”乡吧“社交项目后台代码（Spring+Springmvc+mybatis） 基于SpringBoot2.0的权限管理系统 是用JAVA语言,基于t-io开发的轻量、高性能、单机支持几十万至百万在线用户IM 一个基于SpringBoot 2的管理后台系统 后台管理界面 Tiny, easily embeddable HTTP server in Java. 基于Spring+SpringMVC+Mybatis分布式敏捷开发系统架构","link":"/2019/02/27/technology/Android资料/"}],"tags":[{"name":"架构","slug":"架构","link":"/tags/架构/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"感悟","slug":"感悟","link":"/tags/感悟/"},{"name":"读书","slug":"读书","link":"/tags/读书/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"进阶","slug":"进阶","link":"/tags/进阶/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"jetpack","slug":"jetpack","link":"/tags/jetpack/"},{"name":"c/c++","slug":"c-c","link":"/tags/c-c/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"资料","slug":"资料","link":"/tags/资料/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"架构","slug":"Android/架构","link":"/categories/Android/架构/"},{"name":"人生","slug":"人生","link":"/categories/人生/"},{"name":"设计模式","slug":"Java/设计模式","link":"/categories/Java/设计模式/"},{"name":"UI","slug":"Android/UI","link":"/categories/Android/UI/"},{"name":"源码","slug":"Android/源码","link":"/categories/Android/源码/"},{"name":"感悟","slug":"人生/感悟","link":"/categories/人生/感悟/"},{"name":"读书","slug":"人生/读书","link":"/categories/人生/读书/"},{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"jetpack","slug":"Android/jetpack","link":"/categories/Android/jetpack/"},{"name":"跨平台","slug":"flutter/跨平台","link":"/categories/flutter/跨平台/"},{"name":"c/c++","slug":"Android/c-c","link":"/categories/Android/c-c/"},{"name":"性能优化","slug":"Android/性能优化","link":"/categories/Android/性能优化/"},{"name":"资料","slug":"Android/资料","link":"/categories/Android/资料/"}]}